# ---- buildenums -t obj/platform_os/structs.txt : ---- 
# ---- bugbuild arm7tdmi.h : ---- 

BEGIN CORE 0
BEGIN ENUM "NvControl"
"NV_CONT_USE_DATA", 0x0
"NV_CONT_USE_POINTER", 0x1
"NV_CONT_GET_POINTER", 0x2
"NV_CONT_EXT_DATA", 0x3
END ENUM "NvControl"

BEGIN ENUM "SLOW_CLOCK_RATIO"
"SC_LCD_RATIO", 0x0
"SC_L1_RATIO", 0x1
"SC_L2_RATIO", 0x2
"SC_PL2_RATIO", 0x3
"SC_AUDIO_RATIO", 0x4
"SC_GPS_RATIO", 0x5
"SC_WIFI_RATIO", 0x6
"SC_COMMS_L2_RATIO", 0x7
"SC_DVFM_1_RATIO", 0x8
"SC_DVFM_2_RATIO", 0x9
"SC_DVFM_3_RATIO", 0xA
"SC_DVFM_4_RATIO", 0xB
END ENUM "SLOW_CLOCK_RATIO"

BEGIN ENUM "DeviceMode"
"PRODUCTION_MODE", 0x0
"DEVELOPER_MODE", 0x1
END ENUM "DeviceMode"

BEGIN ENUM "NvFlashStatus"
"NV_FLASH_DENIED", 0xFFFFFFEF
"NV_FLASH_FAILED", 0xFFFFFFF0
"NV_FLASH_FULL", 0xFFFFFFF1
"NV_FLASH_RETRY", 0xFFFFFFF2
"NV_FLASH_MULTIPLE_UPDATE", 0xFFFFFFF3
"NV_FLASH_NOT_SHARED_MEMORY", 0xFFFFFFF4
"NV_PASS", 0xFFFFFFF5
"NV_FAIL", 0xFFFFFFF6
"PACK_REQUIRED", 0xFFFFFFF7
"PACK_SUCCESSFUL", 0xFFFFFFF8
"PACK_FAILED", 0xFFFFFFF9
"NV_HASH_EXISTS", 0xFFFFFFFA
"NV_FLASH_OK", 0x0
END ENUM "NvFlashStatus"

BEGIN ENUM "FATFSImageStatus"
"FAT_FS_IMAGE_STATUS_OK", 0x0
"FAT_FS_IMAGE_STATUS_FAILED", 0x1
"NUM_FAT_FS_IMAGE_STATUS", 0x2
END ENUM "FATFSImageStatus"

BEGIN ENUM "SDBusWidth"
"SD_BUSWIDTH_1BIT", 0x0
"SD_BUSWIDTH_4BIT", 0x1
"SD_BUSWIDTH_8BIT", 0x2
"NUM_SD_BUSWIDTHS", 0x3
END ENUM "SDBusWidth"

BEGIN ENUM "MMUCacheSet"
"MMU_CacheDisable", 0x0
"MMU_CacheEnable", 0x1
END ENUM "MMUCacheSet"

BEGIN ENUM "VersionFormat"
"VER_8_8_8_8", 0x0
"VER_16_16", 0x1
"VER_8_8_1_15", 0x2
"VER_8_16_8", 0x3
"VER_8_8_2_14", 0x4
"VER_BCD_16", 0x5
"MAX_VERSION_FORMAT", 0x6
END ENUM "VersionFormat"

BEGIN ENUM "HeadsetMute"
"MUTE_LEFT", 0x0
"MUTE_RIGHT", 0x1
"MUTE_NONE", 0x2
"MUTE_ALL", 0x3
END ENUM "HeadsetMute"

BEGIN ENUM "SoftReconnectState"
"SOFTRECONNECT_INACTIVE", 0x0
"SOFTRECONNECT_STOPPED", 0x1
"SOFTRECONNECT_STOPPED_CABLE_REMOVED", 0x2
"SOFTRECONNECT_STARTED", 0x3
"SOFTRECONNECT_STARTED_CABLE_REMOVED", 0x4
END ENUM "SoftReconnectState"

BEGIN ENUM "LikelyResetCause"
"UNKNOWN_RESET", 0x0
"APPS_RESET", 0x1
"WIFI_RESET", 0x2
"GPRS_RESET", 0x3
"UMTS_RESET", 0x4
"OS_RESET", 0x5
"MWAF_RESET", 0x6
"CDMA_RESET", 0x7
"IDEN_RESET", 0x8
"THREE_G_RESET", 0x9
"USER_INITIATED_RESET", 0xA
"BATTERY_PULL", 0xB
"RESET_CALLED", 0xC
END ENUM "LikelyResetCause"

BEGIN ENUM "BFS_STATUS"
"BFS_OK", 0x0
"BFS_WRITE_OUT_OF_FS", 0x1
"BFS_WRITE_OUT_OF_BLOCK", 0x2
"BFS_WRITE_FAIL", 0x3
"BFS_ERASE_OUT_OF_FS", 0x4
"BFS_ERASE_NOT_ALIGNED", 0x5
"BFS_ERASE_FAIL", 0x6
"BFS_BAD_OS_END", 0x7
"BFS_ERASE_SUSPENDED", 0x8
"BFS_ERASE_RESUME_ADDR_ERROR", 0x9
END ENUM "BFS_STATUS"

BEGIN ENUM "PadInterruptType"
"PAD_INTERRUPT_NONE", 0x0
"PAD_INTERRUPT_RISING_EDGE", 0x1
"PAD_INTERRUPT_FALLING_EDGE", 0x2
"PAD_INTERRUPT_BOTH_EDGES", 0x3
"PAD_INTERRUPT_HIGH_LEVEL", 0x4
"PAD_INTERRUPT_LOW_LEVEL", 0x5
END ENUM "PadInterruptType"

BEGIN ENUM "ChargingStatus"
"CHARGING_STATUS_FAULT", 0x0
"CHARGING_STATUS_DONE", 0x1
"CHARGING_STATUS_FAST", 0x2
"CHARGING_STATUS_PRE", 0x3
END ENUM "ChargingStatus"

BEGIN ENUM "BugDispRequests"
"BUGDISP_TIMESTAMPS", 0x0
"BUGDISP_MESSAGES", 0x1
"BUGDISP_SPEECHLOGGING", 0x2
"BUGDISP_QUINCYSPEECHLOGGING", 0x3
"BUGDISP_ALL_LOGGING", 0x4
"BUGDISP_PCMSPEECHLOGGING", 0x5
"BUGDISP_SD_CARD_LOGGING", 0x6
"BUGDISP_KEYPAD_LOGGING", 0x7
"NUM_BUGDISP_REQUESTS", 0x8
END ENUM "BugDispRequests"

BEGIN ENUM "ThreadClass"
"IDEN_THREAD", 0x0
"MWAF_THREAD", 0x1
"WIFI_THREAD", 0x2
"GPRS_THREAD", 0x3
"UMTS_THREAD", 0x4
"OS_THREAD", 0x5
END ENUM "ThreadClass"

BEGIN ENUM "CalSignalType"
"STP_USB_SOFT_RECONNECT_REQ", 0xE210
"STP_USB_SOFT_RECONNECT_CNF", 0xE211
"STP_USB_GET_FEATURES_REQ", 0xE212
"STP_USB_GET_FEATURES_CNF", 0xE213
"SIG_RIM_FT2_MALLOC_REQ", 0xF40C
"SIG_RIM_FT2_MALLOC_CNF", 0xF40D
"SIG_RIM_FT2_FREE_REQ", 0xF40E
"SIG_RIM_FT2_FREE_CNF", 0xF40F
"SIG_RIM_FT2_MEMSET_REQ", 0xF410
"SIG_RIM_FT2_MEMSET_CNF", 0xF411
"SIG_RIM_FT2_MEMCPY_REQ", 0xF412
"SIG_RIM_FT2_MEMCPY_CNF", 0xF413
"SIG_RIM_FT2_WRITE_TO_BUFFER_REQ", 0xF414
"SIG_RIM_FT2_WRITE_TO_BUFFER_CNF", 0xF415
"SIG_RIM_FT2_READ_FROM_BUFFER_REQ", 0xF416
"SIG_RIM_FT2_READ_FROM_BUFFER_CNF", 0xF417
"SIG_RIM_FT_NVRAM_BIT_FLAG_REQ", 0xFD1C
"SIG_RIM_FT_NVRAM_BIT_FLAG_CNF", 0xFD1D
"SIG_RIM_CAL_SET_RAMP_SCALE_REQ", 0xFD1E
"SIG_RIM_CAL_SET_RAMP_SCALE_CNF", 0xFD1F
"SIG_RIM_CAL_SET_BAND_MODE_REQ", 0xFD20
"SIG_RIM_CAL_SET_BAND_MODE_CNF", 0xFD21
"SIG_RIM_CAL_WIPE_CAL_DATA_REQ", 0xFD22
"SIG_RIM_CAL_WIPE_CAL_DATA_CNF", 0xFD23
"SIG_RIM_FT_SET_LED_REQ", 0xFE10
"SIG_RIM_FT_SET_LED_CNF", 0xFE11
"STP_SENSOR_GET_VALUE_REQ", 0xFE12
"STP_SENSOR_GET_VALUE_CNF", 0xFE13
"SIG_RIM_FT_GET_KEYS_REQ", 0xFE18
"SIG_RIM_FT_GET_KEYS_CNF", 0xFE19
"SIG_RIM_FT_GET_SIM_STATUS_REQ", 0xFE1A
"SIG_RIM_FT_GET_SIM_STATUS_CNF", 0xFE1B
"SIG_RIM_FT_GET_HEADSET_STATUS_REQ", 0xFE1C
"SIG_RIM_FT_GET_HEADSET_STATUS_CNF", 0xFE1D
"SIG_RIM_FT_GET_BATTERY_LEVEL_REQ", 0xFE22
"SIG_RIM_FT_GET_BATTERY_LEVEL_CNF", 0xFE23
"SIG_RIM_FT_GET_TEMPERATURE_REQ", 0xFE24
"SIG_RIM_FT_GET_TEMPERATURE_CNF", 0xFE25
"SIG_RIM_FT_INIT_CONSOLE_REQ", 0xFE26
"SIG_RIM_FT_INIT_CONSOLE_CNF", 0xFE27
"SIG_RIM_FT_SET_AUDIO_PATH_REQ", 0xFE28
"SIG_RIM_FT_SET_AUDIO_PATH_CNF", 0xFE29
"SIG_RIM_FT_GET_BATTERY_ID_REQ", 0xFE2C
"SIG_RIM_FT_GET_BATTERY_ID_CNF", 0xFE2D
"SIG_RIM_FT_SET_UTC_REQ", 0xFE3A
"SIG_RIM_FT_SET_UTC_CNF", 0xFE3B
"SIG_RIM_FT_GET_UTC_REQ", 0xFE3C
"SIG_RIM_FT_GET_UTC_CNF", 0xFE3D
"SIG_RIM_FT_LCD_AUTO_DETECT_REQ", 0xFE46
"SIG_RIM_FT_LCD_AUTO_DETECT_CNF", 0xFE47
"SIG_RIM_FT_POWER_OFF_REQ", 0xFE50
"SIG_RIM_FT_POWER_OFF_CNF", 0xFE51
"SIG_RIM_FT_GET_BATTERY_STATUS_REQ", 0xFE52
"SIG_RIM_FT_GET_BATTERY_STATUS_CNF", 0xFE53
"SIG_RIM_FT_MFG_ERROR_LIST_REQ", 0xFE54
"SIG_RIM_FT_MFG_ERROR_LIST_CNF", 0xFE55
"SIG_RIM_FT_INTERAC_TEST_SEL_REQ", 0xFE56
"SIG_RIM_FT_INTERAC_TEST_SEL_CNF", 0xFE57
"SIG_RIM_FT_VERIFY_ALL_COMMANDS_REQ", 0xFE60
"SIG_RIM_FT_VERIFY_ALL_COMMANDS_CNF", 0xFE61
"SIG_RIM_FT_GET_JVM_REPORTED_STATE_REQ", 0xFE68
"SIG_RIM_FT_GET_JVM_REPORTED_STATE_CNF", 0xFE69
"SIG_RIM_DC_ACCESS_ID_REQ", 0xFE80
"SIG_RIM_DC_ACCESS_ID_CNF", 0xFE81
"STP_DC_VERIFY_MEMORY_REQ", 0xFE82
"STP_DC_VERIFY_MEMORY_CNF", 0xFE83
"SIG_RIM_FT_VERIFY_JTAG_DISCONNECTED_REQ", 0xFE8A
"SIG_RIM_FT_VERIFY_JTAG_DISCONNECTED_CNF", 0xFE8B
"STP_ACCESS_ID_EXTERNAL_REQ", 0xFE92
"STP_ACCESS_ID_EXTERNAL_CNF", 0xFE93
"SIG_RIM_CAL_INIT_REQ", 0xFF08
"SIG_RIM_CAL_INIT_CNF", 0xFF09
"SIG_RIM_CAL_START_CALL_REQ", 0xFF0C
"SIG_RIM_CAL_START_CALL_CNF", 0xFF0D
"SIG_RIM_CAL_STOP_CALL_REQ", 0xFF10
"SIG_RIM_CAL_STOP_CALL_CNF", 0xFF11
"SIG_RIM_CAL_ACCESS_AUDIO_VOLUME_REQ", 0xFF12
"SIG_RIM_CAL_ACCESS_AUDIO_VOLUME_CNF", 0xFF13
"SIG_RIM_CAL_RESET_DEVICE_REQ", 0xFF14
"SIG_RIM_CAL_RESET_DEVICE_CNF", 0xFF15
"SIG_RIM_CAL_GET_PROTOCOL_VERSION_REQ", 0xFF16
"SIG_RIM_CAL_GET_PROTOCOL_VERSION_CNF", 0xFF17
"SIG_RIM_CAL_SET_SERIAL_MODE_REQ", 0xFF18
"SIG_RIM_CAL_SET_SERIAL_MODE_CNF", 0xFF19
"SIG_RIM_CAL_ACCESS_JVM_START_STATUS_REQ", 0xFF1C
"SIG_RIM_CAL_ACCESS_JVM_START_STATUS_CNF", 0xFF1D
"SIG_RIM_CAL_ACCESS_EXT_CAL_TEST_STATUS_REQ", 0xFF1E
"SIG_RIM_CAL_ACCESS_EXT_CAL_TEST_STATUS_CNF", 0xFF1F
"SIG_RIM_CAL_GET_COVERAGE_INFO_REQ", 0xFF20
"SIG_RIM_CAL_GET_COVERAGE_INFO_CNF", 0xFF21
"SIG_RIM_CAL_ENABLE_POWER_SAVING_REQ", 0xFF22
"SIG_RIM_CAL_ENABLE_POWER_SAVING_CNF", 0xFF23
"SIG_RIM_CAL_GET_MEP_DATA_REQ", 0xFF2C
"SIG_RIM_CAL_GET_MEP_DATA_CNF", 0xFF2D
"SIG_RIM_CAL_SET_MEP_DATA_REQ", 0xFF2E
"SIG_RIM_CAL_SET_MEP_DATA_CNF", 0xFF2F
"SIG_RIM_CAL_ACCESS_LOCALIZATION_INFO_REQ", 0xFF32
"SIG_RIM_CAL_ACCESS_LOCALIZATION_INFO_CNF", 0xFF33
"SIG_RIM_CAL_RADIO_ON_OFF_REQ", 0xFF34
"SIG_RIM_CAL_RADIO_ON_OFF_CNF", 0xFF35
"SIG_RIM_CAL_ACCESS_DEVICE_RANDOM_NUMBER_REQ", 0xFF36
"SIG_RIM_CAL_ACCESS_DEVICE_RANDOM_NUMBER_CNF", 0xFF37
"SIG_RIM_CAL_ACCESS_SW_PART_LIST_REQ", 0xFF38
"SIG_RIM_CAL_ACCESS_SW_PART_LIST_CNF", 0xFF39
"SIG_RIM_CAL_ACCESS_DEVICE_PROFILE_REQ", 0xFF3C
"SIG_RIM_CAL_ACCESS_DEVICE_PROFILE_CNF", 0xFF3D
"STP_READ_ADC_VALUE_REQ", 0xFF3E
"STP_READ_ADC_VALUE_CNF", 0xFF3F
"SIG_RIM_CAL_SUPPORTED_FEATURE_REQ", 0xFF40
"SIG_RIM_CAL_SUPPORTED_FEATURE_CNF", 0xFF41
"SIG_RIM_CAL_ACCESS_DEVICE_MODE_REQ", 0xFF42
"SIG_RIM_CAL_ACCESS_DEVICE_MODE_CNF", 0xFF43
"SIG_RIM_CAL_GET_HW_VERSION_REQ", 0xFF4C
"SIG_RIM_CAL_GET_HW_VERSION_CNF", 0xFF4D
"SIG_RIM_CAL_ECHO_STRING_REQ", 0xFF4E
"SIG_RIM_CAL_ECHO_STRING_CNF", 0xFF4F
"SIG_RIM_CAL_GET_CUSTOM_INFO_REQ", 0xFF50
"SIG_RIM_CAL_GET_CUSTOM_INFO_CNF", 0xFF51
"SIG_RIM_CAL_SET_CUSTOM_INFO_REQ", 0xFF52
"SIG_RIM_CAL_SET_CUSTOM_INFO_CNF", 0xFF53
"SIG_RIM_CAL_SET_RS232_REQ", 0xFF54
"SIG_RIM_CAL_SET_RS232_CNF", 0xFF55
"SIG_RIM_CAL_ACCESS_TEST_OP_NAME_REQ", 0xFF56
"SIG_RIM_CAL_ACCESS_TEST_OP_NAME_CNF", 0xFF57
"SIG_RIM_CAL_HWV_TABLE_ACCESS_REQ", 0xFF58
"SIG_RIM_CAL_HWV_TABLE_ACCESS_CNF", 0xFF59
"SIG_RIM_CAL_NVRAM_DELETE_CAL_REQ", 0xFF5A
"SIG_RIM_CAL_NVRAM_DELETE_CAL_CNF", 0xFF5B
"SIG_RIM_CAL_GET_DEVICE_FEATURE_REQ", 0xFF5C
"SIG_RIM_CAL_GET_DEVICE_FEATURE_CNF", 0xFF5D
"SIG_RIM_WP_VERIFY_BYTE_REQ", 0xFF5E
"SIG_RIM_WP_VERIFY_BYTE_CNF", 0xFF5F
"SIG_RIM_CAL_NVRAM_STORE_OS_ID_REQ", 0xFF62
"SIG_RIM_CAL_NVRAM_STORE_OS_ID_CNF", 0xFF63
"SIG_RIM_CAL_NVRAM_STORE_CRYPTOBATT_CHALLENGE_REQ", 0xFF64
"SIG_RIM_CAL_NVRAM_STORE_CRYPTOBATT_CHALLENGE_CNF", 0xFF65
"SIG_RIM_CAL_GET_NO_BAT_N_REQ", 0xFF66
"SIG_RIM_CAL_GET_NO_BAT_N_CNF", 0xFF67
"SIG_RIM_AUDIO_ACCESS_AVP_REQ", 0xFF6C
"SIG_RIM_AUDIO_ACCESS_AVP_CNF", 0xFF6D
"SIG_RIM_AUDIO_DELETE_AVP_REQ", 0xFF6E
"SIG_RIM_AUDIO_DELETE_AVP_CNF", 0xFF6F
"SIG_RIM_SVP_ACCESS_REQ", 0xFF70
"SIG_RIM_SVP_ACCESS_CNF", 0xFF71
"SIG_RIM_CAL_SET_DEFAULT_RADIO_REQ", 0xFF72
"SIG_RIM_CAL_SET_DEFAULT_RADIO_CNF", 0xFF73
"SIG_RIM_AUDIO_MUTE_HEADSET_REQ", 0xFF74
"SIG_RIM_AUDIO_MUTE_HEADSET_CNF", 0xFF75
"SIG_RIM_GET_METRICS_DATA_REQ", 0xFF76
"SIG_RIM_GET_METRICS_DATA_CNF", 0xFF77
"SIG_RIM_GET_INTERACTIVE_TEST_RESULTS_REQ", 0xFF7E
"SIG_RIM_GET_INTERACTIVE_TEST_RESULTS_CNF", 0xFF7F
"SIG_RIM_SET_AUDIO_TRIMMING_REQ", 0xFF82
"SIG_RIM_SET_AUDIO_TRIMMING_CNF", 0xFF83
"SIG_RIM_GET_AUDIO_TRIMMING_REQ", 0xFF84
"SIG_RIM_GET_AUDIO_TRIMMING_CNF", 0xFF85
"SIG_RIM_DELETE_AUDIO_TRIMMING_REQ", 0xFF86
"SIG_RIM_DELETE_AUDIO_TRIMMING_CNF", 0xFF87
"STP_BUGDISP_REQ", 0xFF8E
"STP_BUGDISP_CNF", 0xFF8F
"SIG_RIM_GET_STP_COMMAND_VERSION_REQ", 0xFF90
"SIG_RIM_GET_STP_COMMAND_VERSION_CNF", 0xFF91
"SIG_RIM_REQUEST_NVRAM_SIGNATURE_REQ", 0xFF92
"SIG_RIM_REQUEST_NVRAM_SIGNATURE_CNF", 0xFF93
"SIG_RIM_STORE_NVRAM_SIGNATURE_REQ", 0xFF94
"SIG_RIM_STORE_NVRAM_SIGNATURE_CNF", 0xFF95
"SIG_RIM_VERIFY_NVRAM_SIGNATURE_REQ", 0xFF96
"SIG_RIM_VERIFY_NVRAM_SIGNATURE_CNF", 0xFF97
"SIG_RIM_WIPE_NVRAM_SIGNATURES_REQ", 0xFF98
"SIG_RIM_WIPE_NVRAM_SIGNATURES_CNF", 0xFF99
"SIG_RIM_GET_REQUIRED_SIGNATURES_REQ", 0xFF9A
"SIG_RIM_GET_REQUIRED_SIGNATURES_CNF", 0xFF9B
"STP_SMARTCARD_TEST_REQ", 0xFF9C
"STP_SMARTCARD_TEST_CNF", 0xFF9D
"STP_NVRAM_COND_WRITE_PROTECT_REQ", 0xFFA8
"STP_NVRAM_COND_WRITE_PROTECT_CNF", 0xFFA9
"STP_REFURBISHED_FLAG_REQ", 0xFFB6
"STP_REFURBISHED_FLAG_CNF", 0xFFB7
"STP_IN_PRODUCTION_FLAG_REQ", 0xFFB8
"STP_IN_PRODUCTION_FLAG_CNF", 0xFFB9
"STP_GET_MAX_BRANDING_SIZE_REQ", 0xFFA0
"STP_GET_MAX_BRANDING_SIZE_CNF", 0xFFA1
"STP_HW_ID_OVERRIDE_REQ", 0xFFC2
"STP_HW_ID_OVERRIDE_CNF", 0xFFC3
"STP_MFG_PERSISTENT_DATA_REQ", 0xFFD0
"STP_MFG_PERSISTENT_DATA_CNF", 0xFFD1
"SIG_RIM_CAL_UNSUPPORTED_COMMAND_REQ", 0xFFFE
"SIG_RIM_CAL_UNSUPPORTED_COMMAND_CNF", 0xFFFF
END ENUM "CalSignalType"

BEGIN ENUM "PmProfileCore"
"PM_APPS_CORE", 0x0
"PM_DSP_CORE", 0x1
"PM_NUM_CORES", 0x2
END ENUM "PmProfileCore"

BEGIN ENUM "UsbPowerLevel"
"USB_PWR_LOW", 0x32
"USB_PWR_HIGH", 0xFA
END ENUM "UsbPowerLevel"

BEGIN ENUM "Language_t"
"LANGUAGE_ENGLISH", 0x1
"LANGUAGE_KOREAN", 0x2
"LANGUAGE_MANDARIN_SIMPLIFIED", 0x3
"LANGUAGE_MANDARIN_TRADITIONAL", 0x4
"LANGUAGE_ENGLISH_UK", 0x5
"LANGUAGE_FRENCH", 0x6
"LANGUAGE_GERMAN", 0x7
"LANGUAGE_SPANISH_US", 0x8
"LANGUAGE_PORTUGUESE_BRAZIL", 0x9
"LANGUAGE_FRENCH_CANADA", 0xA
"LANGUAGE_ITALIAN", 0xB
"LANGUAGE_SPANISH", 0xC
"LANGUAGE_PORTUGUESE_EUROPEAN", 0xD
"LANGUAGE_FINNISH", 0xE
"LANGUAGE_CANTONESE_TRADITIONAL", 0xF
"LANGUAGE_CANTONESE_SIMPLIFIED", 0x10
"LANGUAGE_RUSSIAN", 0x11
"LANGUAGE_MANGLISH_SIMPLIFIED", 0x12
"LANGUAGE_MANGLISH_TRADITIONAL", 0x13
"LANGUAGE_ZEHK_TRADITIONAL", 0x14
"LANGUAGE_ZEHK_SIMPLIFIED", 0x15
"LANGUAGE_DUTCH", 0x16
"LANGUAGE_SWEDISH", 0x17
"LANGUAGE_NORWEGIAN", 0x18
"LANGUAGE_JAPANESE", 0x19
"LANGUAGE_POLISH", 0x1A
"LANGUAGE_UKRAINIAN", 0x1B
"LANGUAGE_AFRIKAANS", 0x1C
"LANGUAGE_ARABIC", 0x1D
"LANGUAGE_CATALAN", 0x1E
"LANGUAGE_CZECH", 0x1F
"LANGUAGE_DANISH", 0x20
"LANGUAGE_GREEK", 0x21
"LANGUAGE_HEBREW", 0x22
"LANGUAGE_HUNGARIAN", 0x23
"LANGUAGE_TURKISH", 0x24
"LANGUAGE_MAX", 0x25
"LANGUAGE_CUSTOM", 0x2710
END ENUM "Language_t"

BEGIN ENUM "UsbChannel"
"USB_CONTROL_CHANNEL", 0x0
"USB_BUGDISP_CHANNEL", 0x1
"USB_MUX_CHANNEL", 0x2
"USB_HOST_VERSIONS_CHANNEL", 0x3
"USB_INVALID_CHANNEL", 0x4
"USB_BROADCAST_CONTROL_MSG", 0xFD
"USB_THREAD_CONTROL_MSG", 0xFE
"USB_DEBUG_CONTROL_MSG", 0xFF
END ENUM "UsbChannel"

BEGIN ENUM "HwVersionType"
"BOOTROM_HW_VERSION", 0x0
"OS_HW_VERSION", 0x1
END ENUM "HwVersionType"

BEGIN ENUM "HybridBuddyBlockType_e"
"HBB_TYPE_SMALL", 0x0
"HBB_TYPE_MEDIUM", 0x1
"HBB_TYPE_LARGE", 0x2
"HBB_TYPE_EXTRA_LARGE", 0x3
"HBB_NUMBER_OF_TYPES", 0x4
"HBB_TYPE_INVALID", 0xFFFFFFFF
END ENUM "HybridBuddyBlockType_e"

BEGIN ENUM "IntController"
"PRIMARY_IRQ", 0x0
"SECONDARY_IRQ", 0x1
"GPIO_IRQ", 0x2
"DMA_IRQ", 0x3
"GSM_IRQ", 0x4
"SECONDARY_L_IRQ", 0x5
"SECONDARY_H_IRQ", 0x6
"WCDMA_H_IRQ", 0x7
"WCDMA_L_IRQ", 0x8
"WCDMA_HL_IRQ", 0x9
"REMOTE_XSCALE_IRQ", 0xA
"REMOTE_ARM9_IRQ", 0xB
"REMOTE_MSA_IRQ", 0xC
"MU_GP_IRQ", 0xD
"SDMA_IRQ", 0xE
"BDMA_IRQ", 0xF
"IPU_IRQ", 0x10
"SECONDARY_INT4", 0x11
"SECONDARY_INT5", 0x12
"SECONDARY_INT17", 0x13
"SECONDARY_INT35", 0x14
"SECONDARY_INT51", 0x15
"MAX_CONTROLLERS", 0x16
END ENUM "IntController"

BEGIN ENUM "OvlIconBuiltIn"
"OVL_ICON_BUILTIN_UNKNOWN", 0x0
"OVL_ICON_BUILTIN_BATTERY_LEVEL", 0x1
"OVL_ICON_BUILTIN_BLUETOOTH", 0x2
"OVL_ICON_BUILTIN_CHARGER", 0x3
"OVL_ICON_BUILTIN_NUM", 0x4
END ENUM "OvlIconBuiltIn"

BEGIN ENUM "USB_FUNCTIONALITY"
"RIM_HANDHELD", 0x0
"RIM_MODEM", 0x1
"RIM_NUM_FUNCTIONALITIES", 0x2
END ENUM "USB_FUNCTIONALITY"

BEGIN ENUM "DEVICE_SECURITY_FEATURE"
"SECURITY_FEATURE_RTAS_BUGDISP_ENABLED", 0x1
"SECURITY_FEATURE_RTAS_STP_ENABLED", 0x2
"SECURITY_FEATURE_NEVER_BEEN_SIGNED", 0x3
"SECURITY_FEATURE_SDCARD_LOGGING_ALLOWED", 0x4
"SECURITY_FEATURE_SNAPSHOT_ENABLED", 0x5
"SECURITY_FEATURE_SDCARD_RAMDUMP_ENABLED", 0x6
END ENUM "DEVICE_SECURITY_FEATURE"

BEGIN ENUM "SDCardType"
"SDMEM_CARD", 0x0
"MMC_CARD", 0x1
"SDIO_CARD", 0x2
"NUM_SD_TYPES", 0x3
END ENUM "SDCardType"

BEGIN ENUM "PmInputRate"
"PM_INPUT_UNSET", 0xFFFFFFFF
"PM_INPUT_OFF", 0x0
"PM_INPUT_100mA", 0x64
"PM_INPUT_500mA", 0x1F4
"PM_INPUT_UNLIM", 0x800
END ENUM "PmInputRate"

BEGIN ENUM "FlagOp"
"FLAG_OR", 0x0
"FLAG_OR_CLEAR", 0x1
"FLAG_AND", 0x2
"FLAG_AND_CLEAR", 0x3
END ENUM "FlagOp"

BEGIN ENUM "descriptorState"
"DESC_UNKNOWN", 0x0
"DESC_AVAILABLE", 0x1
"DESC_UNAVAILABLE", 0x2
END ENUM "descriptorState"

BEGIN ENUM "displayOrientation"
"NORTH", 0x0
"EAST", 0x1
"SOUTH", 0x2
"WEST", 0x3
"ORIENTATION_ERROR", 0x4
END ENUM "displayOrientation"

BEGIN ENUM "PadSleepDirection"
"SLEEP_DIRECTION_DEFAULT", 0x0
"SLEEP_DIRECTION_INPUT", 0x1
"SLEEP_DIRECTION_OUTPUT", 0x2
END ENUM "PadSleepDirection"

BEGIN ENUM "SDPort"
"SD_PORT0", 0x0
"NUM_SD_PORTS", 0x1
END ENUM "SDPort"

BEGIN ENUM "HeapBlockOwnerStatus_e"
"NEVER_OWNED", 0x0
"CURRENTLY_OWNED", 0x1
"PREVIOUSLY_OWNED", 0x2
END ENUM "HeapBlockOwnerStatus_e"

BEGIN ENUM "AudioShortDet"
"AUDIO_SHORT_DET_DISABLE", 0x0
"AUDIO_SHORT_DET_ENABLE_HIGH", 0x1
"AUDIO_SHORT_DET_ENABLE_LOW", 0x2
END ENUM "AudioShortDet"

BEGIN ENUM "USB_ERROR_CODE"
"USB_NO_ERROR", 0x0
"USB_CHANNEL_ILLEGAL", 0x1
"USB_CHANNEL_STATE_ERROR", 0x2
"USB_CHANNEL_BUFFER_ERROR", 0x3
"USB_CHANNEL_NAME_ERROR", 0x4
"USB_CHANNEL_BUFFER_OVERFLOW", 0x5
"USB_REG_OVERFLOW", 0x6
"USB_OPEN_OVERFLOW", 0x7
"USB_PARAMETER_ERROR", 0x8
"USB_MS_BUSY", 0x9
"USB_MS_NOT_AVAILABLE", 0xA
"USB_SWITCH_VETOED", 0xB
"USB_SWITCH_NO_CHANGE", 0xC
"USB_SWITCH_MODE_UNAVAILABLE", 0xD
"USB_SWITCH_MODE_DISABLED", 0xE
"USB_SWITCH_NO_VALID_MODE", 0xF
END ENUM "USB_ERROR_CODE"

BEGIN ENUM "FATFSImagePartition"
"PARTITION_NONE", 0x0
"PARTITION_ONE", 0x1
"PARTITION_TWO", 0x2
"NUM_PARTITIONS", 0x3
END ENUM "FATFSImagePartition"

BEGIN ENUM "ProfileThruData_e"
"OSPROF_THRU_DATA_ITER", 0x0
"OSPROF_THRU_TICKS_TOTAL", 0x1
"OSPROF_THRU_BYTES_CUR", 0x2
"OSPROF_THRU_BYTES_TOTAL", 0x3
"OSPROF_THRU_CORE_ID", 0x4
END ENUM "ProfileThruData_e"

BEGIN ENUM "NUKE_STATUS"
"NUKE_OK", 0x0
"NUKE_NUKING", 0x1
"NUKE_COMPLETE", 0x2
"NUKE_NUKING_0", 0x3
"NUKE_NUKING_1", 0x4
"NUKE_NUKING_2", 0x5
"NUKE_NUKING_3", 0x6
"NUKE_NUKING_4", 0x7
"NUKE_NUKING_5", 0x8
END ENUM "NUKE_STATUS"

BEGIN ENUM "VolumeMode"
"SPEECH_VOLUME", 0x0
"DTMF_VOLUME", 0x1
END ENUM "VolumeMode"

BEGIN ENUM "BugdispBufferType"
"BUGDISP_BUFFER_APPS", 0x0
"BUGDISP_BUFFER_RADIO", 0x1
"BUGDISP_BUFFER_DSP", 0x2
"BUGDISP_BUFFER_RADIO_LP", 0x3
"BUGDISP_BUFFER_DSP_LP", 0x4
"BUGDISP_BUFFER_SPEECH", 0x5
END ENUM "BugdispBufferType"

BEGIN ENUM "ChargingRate"
"CHARGING_DEFAULT", 0x0
"CHARGING_85mA", 0x1
"CHARGING_450mA", 0x2
"CHARGING_750mA", 0x3
"CHARGING_102mA", 0x4
"CHARGING_353mA", 0x5
"CHARGING_455mA", 0x6
"CHARGING_CHRG_HI", 0x7
"CHARGING_CHRG_LO", 0x8
"CHARGING_USB_HI", 0x9
"CHARGING_USB_LO", 0xA
"CHARGING_1500mA", 0xB
"CHARGING_1350mA", 0xC
END ENUM "ChargingRate"

BEGIN ENUM "PERFMON_STAT_TYPE"
"PERFMON_NOT_SUPPORTED", 0x0
"PERFMON_STATIC", 0x1
"PERFMON_DYNAMIC", 0x2
END ENUM "PERFMON_STAT_TYPE"

BEGIN ENUM "ESCREEN_MENU_ITEM"
"ESCREEN_RADIO_CONTENTS", 0x0
"ESCREEN_WAF_CONTENTS", 0x1
"ESCREEN_OS_CONTENTS", 0x2
"ESCREEN_JVM_CONTENTS", 0x3
"ESCREEN_EVENT_LOG", 0x4
"ESCREEN_TOGGLE_RADIO", 0x5
"ESCREEN_POWER_OFF", 0x6
"ESCREEN_NUM_ITEM", 0x7
END ENUM "ESCREEN_MENU_ITEM"

BEGIN ENUM "VoltageTypes"
"REDUCE_VCORE", 0x0
"INCREASE_VCORE", 0x1
"NOMINAL_VCORE", 0x2
END ENUM "VoltageTypes"

BEGIN ENUM "CalNetworkModePref"
"CAL_NETWORK_MODE_GLOBAL", 0x1
"CAL_NETWORK_MODE_CDMA_EVDO_HYBRID_OFF", 0x2
"CAL_NETWORK_MODE_EVDO_ONLY", 0x3
"CAL_NETWORK_MODE_CDMA_ONLY", 0x4
"CAL_NETWORK_MODE_GSM", 0x5
"CAL_NETWORK_MODE_CDMA_EVDO", 0x6
"CAL_NETWORK_MODE_WCDMA", 0x7
"CAL_NETWORK_MODE_INVALID", 0xFF
END ENUM "CalNetworkModePref"

BEGIN ENUM "RimUsbMsMMCPartitionNumber"
"MMC_PARTITION_PRIMARY", 0x0
"MMC_PARTITION_SECONDARY", 0x1
"MMC_NUM_PARTITIONS", 0x2
END ENUM "RimUsbMsMMCPartitionNumber"

BEGIN ENUM "TrnType"
"TRN_TYPE_NONE", 0x0
"TRN_TYPE_SETUP", 0x1
"TRN_TYPE_IN", 0x2
"TRN_TYPE_OUT", 0x3
END ENUM "TrnType"

BEGIN ENUM "TickFrequency"
"SLOW_FREQUENCY", 0x0
"FAST_FREQUENCY", 0x1
END ENUM "TickFrequency"

BEGIN ENUM "ResetCode"
"RESET_CODE_UNCLASSIFIED", 0x0
"RESET_CODE_USER_INITIATED", 0x1
"RESET_CODE_ERROR", 0x2
"RESET_CODE_APPS_REQUIRED", 0x3
"RESET_CODE_BATTERY_PULL", 0x4
"RESET_CODE_DEAD_BATTERY_CHARGE", 0x5
"RESET_CODE_USB_MUX", 0x6
"RESET_CODE_STP", 0x7
"RESET_CODE_BUGDISP", 0x8
"RESET_CODE_TEST", 0x9
"RESET_CODE_DEVICE_NUKE", 0xA
"RESET_CODE_SERIAL_CODE_LOAD", 0xB
"RESET_CODE_RIMINITIATERESET", 0xC
END ENUM "ResetCode"

BEGIN ENUM "MemoryTestTypes"
"STRICT_TEST", 0x0
"RELAXED_TEST", 0x1
"RESET_VALUES", 0x2
"COMPLETE_TEST", 0x3
"VERIFY_HMC", 0x4
"VERIFY_HMC_SHORT", 0x5
END ENUM "MemoryTestTypes"

BEGIN ENUM "MMUWriteBackBufferSet"
"MMU_WBBufDisable", 0x0
"MMU_WBBufEnable", 0x1
END ENUM "MMUWriteBackBufferSet"

BEGIN ENUM "AutomaticBacklightMode"
"AUTOMATIC_BACKLIGHT_ON", 0x0
"AUTOMATIC_BACKLIGHT_OFF", 0x1
END ENUM "AutomaticBacklightMode"

BEGIN ENUM "RimUsbFeature"
"USB_FEATURE_BB", 0x1
"USB_FEATURE_MS", 0x2
"USB_FEATURE_MTP", 0x4
"USB_FEATURE_VSP", 0x8
END ENUM "RimUsbFeature"

BEGIN ENUM "UsbEnumMode"
"USB_ENUM_RE_ENUM", 0x0
"USB_ENUM_LOW_POWER", 0x1
"USB_ENUM_HIGH_POWER", 0x2
END ENUM "UsbEnumMode"

BEGIN ENUM "PadSleepData"
"SLEEP_DATA_DEFAULT", 0x0
"SLEEP_DATA_HIGH", 0x1
"SLEEP_DATA_LOW", 0x2
END ENUM "PadSleepData"

BEGIN ENUM "GenericHeapErr_e"
"GENERIC_HEAP_SUCCESS", 0x0
"GENERIC_HEAP_FAILURE", 0x1
"GENERIC_HEAP_FAILURE_OUT_OF_MEMORY", 0x2
"GENERIC_HEAP_FAILURE_SIZE_OUT_OF_RANGE", 0x3
"GENERIC_HEAP_FAILURE_ALIGNMENT", 0x4
"GENERIC_HEAP_FAILURE_ACCESS_RESTRICTION", 0x5
"GENERIC_HEAP_FAILURE_BLOCK_ALREADY_OWNED", 0x6
"GENERIC_HEAP_FAILURE_NOT_BLOCK_OWNER", 0x7
"GENERIC_HEAP_FAILURE_MAX_WATERMARK_LISTENERS", 0x8
"GENERIC_HEAP_FAILURE_EXISTING_WATERMARK_LISTENER", 0x9
"GENERIC_HEAP_FAILURE_INVALID_BLOCK", 0xA
END ENUM "GenericHeapErr_e"

BEGIN ENUM "FILE_SEEK_MODE"
"FILE_SEEK_ABSOLUTE", 0x0
"FILE_SEEK_RELATIVE", 0x1
"FILE_SEEK_END", 0x2
END ENUM "FILE_SEEK_MODE"

BEGIN ENUM "ResetPower"
"RESET_POWER_UNKNOWN", 0x0
"RESET_POWER_LOST", 0x1
"RESET_POWER_KEPT", 0x2
"RESET_POWER_KEPT_UNEXPECTED", 0x3
END ENUM "ResetPower"

BEGIN ENUM "GenericHeapStatsType_e"
"HEAP_STATS_BASIC", 0x0
"HEAP_STATS_BASIC_AND_TAG", 0x1
"HEAP_STATS_BASIC_AND_ALLOC_SCHEME", 0x2
END ENUM "GenericHeapStatsType_e"

BEGIN ENUM "RollingBufferType"
"BATTERY_BUF", 0x0
"SYSPROF_BUF", 0x1
"UTC_BUF", 0x2
"NUM_ROLLING_BUFS", 0x3
END ENUM "RollingBufferType"

BEGIN ENUM "ProfileTimeData_e"
"OSPROF_TIME_DATA_ITER", 0x0
"OSPROF_TIME_DATA_TICKS_TOTAL", 0x1
"OSPROF_TIME_DATA_TICKS_MIN", 0x2
"OSPROF_TIME_DATA_TICKS_MAX", 0x3
"OSPROF_TIME_DATA_TICKS_LAST", 0x4
"OSPROF_TIME_CORE_ID", 0x5
END ENUM "ProfileTimeData_e"

BEGIN ENUM "SetupXferState"
"SXS_SETUP", 0x0
"SXS_DATA", 0x1
"SXS_STATUS", 0x2
END ENUM "SetupXferState"

BEGIN ENUM "LEDColour"
"LED_RED", 0x1
"LED_GREEN", 0x2
"LED_BLUE", 0x3
"LED_WHITE", 0x4
END ENUM "LEDColour"

BEGIN ENUM "OvlIconBuiltInErr"
"OVL_ICON_BUILTIN_SUCCESS", 0x0
"OVL_ICON_BUILTIN_NOT_SUPPORTED", 0x1
"OVL_ICON_BUILTIN_ERROR", 0x2
"OVL_ICON_BUILTIN_ERR_NUM", 0x3
END ENUM "OvlIconBuiltInErr"

BEGIN ENUM "IconPosition"
"UPPER_RIGHT", 0x0
"UPPER_LEFT", 0x1
"NUM_ICON_POSITIONS", 0x2
END ENUM "IconPosition"

BEGIN ENUM "TestCryptoBatteryStatus"
"CBAUTH_SUCCESS", 0x0
"CBAUTH_FAILED", 0x1
"CBAUTH_BUSY", 0x2
END ENUM "TestCryptoBatteryStatus"

BEGIN ENUM "DcCommand"
"CAL_OFF", 0x0
"CAL_ON", 0x1
"VERIFY_FLASH", 0x2
"VERIFY_RAM", 0x3
"READ_ID", 0x4
"WRITE_ID", 0x5
"SET_CONTROL_SIGNALS", 0x6
"CLR_CONTROL_SIGNALS", 0x7
"READ_CONTROL_SIGNALS", 0x8
"INIT_AUDIO_VIB_DRIVER", 0x9
"VERIFY_SD_CARD", 0xA
"FORMAT_SD_CARD", 0xB
"VERIFY_SD_CARD_ND", 0xC
"VERIFY_SD_CONNECTION", 0xD
"VERIFY_MMC_ND", 0xE
"FORMAT_MMC_PRI", 0xF
"FORMAT_MMC_SEC", 0x10
END ENUM "DcCommand"

BEGIN ENUM "CommandErrorType"
"COMMAND_UNSUPPORTED", 0x0
"INVALID_ARGUMENT", 0x1
"RTAS_PERMISSION_DENIED", 0x2
END ENUM "CommandErrorType"

BEGIN ENUM "MemCfgTableEntryType"
"MCT_ERASED_ENTRY", 0x0
"MCT_OS_FIXED", 0x1
"MCT_OS_DYNAMIC", 0x2
"MCT_FLASH_CHIP", 0x3
"MCT_MAPPING", 0x4
"MCT_OS_NV", 0x5
"MCT_QC_NV", 0x6
"MCT_FS_FIXED", 0x7
"MCT_FS_DYNAMIC", 0x8
"MCT_CRC", 0x9
"MCT_PASSWORD_ADDRESS", 0xA
"MCT_HWV_ENTRY", 0xB
"MCT_BRANDING", 0xC
"MCT_FAT_FS", 0xD
"MCT_APPSTORE", 0xE
"MCT_BUGDISP", 0xF
"MCT_INSTALLER", 0x10
"MCT_DSP_OS", 0x12
"MCT_OS_EXTENDED", 0x13
"MCT_BSN_REGION", 0x14
"MCT_FS_DYNAMIC_MINSTART", 0x15
"MCT_FS_FIXED_MINSTART", 0x16
"MCT_BOOTROM_START", 0x17
"MCT_BOOTROM_NAND", 0x18
"MCT_OS_DYNAMIC_NAND", 0x19
"MCT_FS_DYNAMIC_NAND", 0x1A
"MCT_OS_FIXED_NAND", 0x1B
"MCT_FS_FIXED_NAND", 0x1C
"MCT_FLASH_CHIP_NAND", 0x1D
"MCT_OS_NV_NAND", 0x1E
"MCT_INSTALLER_NAND", 0x1F
"MCT_EFS_MODEM_PARTITION", 0x20
"MCT_EFS_APPS_PARTITION", 0x21
"MCT_FAT_FS_NAND", 0x22
"MCT_RAM_CHIP", 0x23
"MCT_EMPTY_ENTRY", 0xFF
"MCT_LAST", 0x100
END ENUM "MemCfgTableEntryType"

BEGIN ENUM "RefCalStatus"
"REF_CAL_FAIL", 0x0
"REF_CAL_PASS", 0x1
"NO_EXT_REF_APPLIED", 0x2
END ENUM "RefCalStatus"

BEGIN ENUM "AudioPort"
"INT_SPK", 0x0
"INT_MIC", 0x1
"EXT_SPK", 0x2
"EXT_MIC", 0x3
"HEADSET_SPK", 0x4
"HEADSET_MIC", 0x5
"BT_SPK", 0x6
"BT_MIC", 0x7
"INT_TELECOIL", 0x8
END ENUM "AudioPort"

BEGIN ENUM "SDMMCSubCommand"
"SDMMC_CMD_FAKE_SDCARD_PRESENCE", 0x0
END ENUM "SDMMCSubCommand"

BEGIN ENUM "CoreMode"
"CORE_MODE_RESET", 0x0
"CORE_MODE_CATFAIL", 0x1
"CORE_MODE_RESET_OR_CATFAIL", 0x2
"CORE_MODE_IN_INTERRUPT", 0x3
"CORE_MODE_IN_RESET_OR_INTERRUPT", 0x4
"CORE_MODE_KERNEL_ENTRYPOINT", 0x5
"CORE_MODE_KERNEL_INTS_ENABLED", 0x6
"CORE_MODE_IN_KERNEL", 0x7
"CORE_MODE_USER", 0x8
END ENUM "CoreMode"

BEGIN ENUM "PowerMode"
"POWER_MODE_NONE", 0x0
"POWER_MODE_PWM", 0x1
"POWER_MODE_AUTO", 0x2
END ENUM "PowerMode"

BEGIN ENUM "PERFMON_STAT"
"PERFMON_CLOCK", 0x0
"PERFMON_CLOCK_FREQUENCY", 0x1
"PERFMON_ICACHE_MISSES", 0x2
"PERFMON_ICACHE_STALL_CYCLES", 0x3
"PERFMON_DATA_DEPENDENCY_STALL_CYCLES", 0x4
"PERFMON_ITLB_MISSES", 0x5
"PERFMON_DTLB_MISSES", 0x6
"PERFMON_BRANCHES", 0x7
"PERFMON_MISPREDICTED_BRANCHES", 0x8
"PERFMON_INSTRUCTIONS_EXECUTED", 0x9
"PERFMON_DCACHE_FULL_STALL_CYCLES", 0xA
"PERFMON_DCACHE_FULL_STALLS", 0xB
"PERFMON_DCACHE_ACCESSES", 0xC
"PERFMON_DCACHE_MISSES", 0xD
"PERFMON_DCACHE_WRITEBACKS", 0xE
"PERFMON_PC_CHANGES", 0xF
"PERFMON_32KHZ_TICKS", 0x10
"PERFMON_DCACHE_HITS", 0x11
"PERFMON_DCACHE_PREFETCH_HITS", 0x12
"PERFMON_DCACHE_THRASHES_DUE_TO_MISS", 0x13
"PERFMON_DCACHE_THRASHES_DUE_TO_SWEEP", 0x14
"PERFMON_DCACHE_STALL_CYCLES", 0x15
"PERFMON_ICACHE_PREFETCH_HITS", 0x16
"PERFMON_ICACHE_HITS", 0x17
"PERFMON_ICACHE_BANK_CONFLICTS", 0x18
"PERFMON_ICACHE_FILL_BUFFER_HITS", 0x19
"PERFMON_LOOP0_ITERATIONS", 0x1A
"PERFMON_LOOP1_ITERATIONS", 0x1B
"PERFMON_LOOP0_BUFFER_INVALIDATES", 0x1C
"PERFMON_LOOP1_BUFFER_INVALIDATES", 0x1D
"PERFMON_PC_RELATIVE_BRANCHES", 0x1E
"PERFMON_INDIRECT_BRANCHES", 0x1F
"PERFMON_TOTAL_BRANCHES", 0x20
"PERFMON_NOT_TAKEN_BRANCHES", 0x21
"PERFMON_CSYNC_SSYNC_STALLS", 0x22
"PERFMON_EXCPT_INSTRUCTIONS", 0x23
"PERFMON_CSYNC_SSYNC_INSTRUCTIONS", 0x24
"PERFMON_COMMITTED_INSTRUCTIONS", 0x25
"PERFMON_INTERRUPTS_TAKEN", 0x26
"PERFMON_MISALIGNED_ADDRESS_EXCEPTIONS", 0x27
"PERFMON_READ_AFTER_WRITE_STALLS", 0x28
"PERFMON_WRITE_AFTER_WRITE_STALLS", 0x29
"PERFMON_LOAD_HITS", 0x2A
"PERFMON_LOAD_MISSES", 0x2B
"PERFMON_STORE_HITS", 0x2C
"PERFMON_STORE_MISSES", 0x2D
"PERFMON_DATABANK_A_LOAD_HITS", 0x2E
"PERFMON_DATABANK_A_STORE_HITS", 0x2F
"PERFMON_DATABANK_B_LOAD_HITS", 0x30
"PERFMON_DATABANK_B_STORE_HITS", 0x31
"PERFMON_DCACHE_MEMORY_HITS", 0x32
"PERFMON_DCACHE_MEMORY_MISSES", 0x33
"PERFMON_STORE_BUFFER_FULL", 0x34
"PERFMON_WRITE_BUFFER_FULL", 0x35
"PERFMON_CORE_BANK_CONFLICTS", 0x36
"PERFMON_DAG_REGISTER_BANK_CONFLICTS", 0x37
"PERFMON_SCRATCH_SRAM_HITS", 0x38
"PERFMON_DMA_READS", 0x39
"PERFMON_DMA_WRITES", 0x3A
"PERFMON_LMU_STALLS_EX2", 0x3B
"PERFMON_LMU_STALLS_EX3", 0x3C
"PERFMON_LMU_EXCEPTIONS", 0x3D
"PERFMON_STORE_BUFFER_CANCEL_STALLS", 0x3E
"PERFMON_STORE_TO_LOAD_FORWARDS", 0x3F
"PERFMON_EX_DATA_HAZARDS_STALLS", 0x40
"PERFMON_CORE_STALL_CYCLES", 0x41
"PERFMON_CHIP_STAT0", 0x42
"PERFMON_CHIP_STAT1", 0x43
"PERFMON_CHIP_STAT2", 0x44
"PERFMON_CHIP_STAT3", 0x45
"PERFMON_CHIP_STAT4", 0x46
"PERFMON_CHIP_STAT5", 0x47
"PERFMON_CHIP_STAT6", 0x48
"PERFMON_CHIP_STAT7", 0x49
"PERFMON_MEM_ACCESSES", 0x4A
"PERFMON_MEM_ACCESS_CYCLES", 0x4B
"PERFMON_DATA_ACCESSES", 0x4C
"PERFMON_DIRECT_BRANCHES", 0x4D
"PERFMON_INST_ISSUE_CYCLES", 0x4E
"PERFMON_PC_CHANGES_ALL", 0x4F
"PERFMON_PIPELINE_FLUSH", 0x50
"PERFMON_BACKEND_STALL_CYCLES", 0x51
"PERFMON_MULT_ACTIVE_CYCLES", 0x52
"PERFMON_MULT_STALL_CYCLES", 0x53
"PERFMON_COPROC_STALL_CYCLES", 0x54
"PERFMON_L2_ACCESSES", 0x55
"PERFMON_L2_MISSES", 0x56
"PERFMON_ADDR_BUS_TRANS", 0x57
"PERFMON_ADDR_BUS_TRANS_SELF", 0x58
"PERFMON_BUS_CLOCK", 0x59
"PERFMON_DATA_BUS_TRANS", 0x5A
"PERFMON_DATA_BUS_TRANS_SELF", 0x5B
"PERFMON_DCACHE_ACCESSES_TOTAL", 0x5C
"PERFMON_MAIN_TLB_MISS", 0x5D
"PERFMON_LOAD_STORE_UNIT_FULL", 0x5E
"PERFMON_WRITE_BUFFER_DRAIN", 0x5F
"PERFMON_L2_COUNTER_DISABLE", 0x60
"PERFMON_L2_BUFFERED_WRITE_ABORT", 0x61
"PERFMON_L2_CACHE_EVICTION", 0x62
"PERFMON_L2_DATA_READ_HIT", 0x63
"PERFMON_L2_DATA_READ_REQUEST", 0x64
"PERFMON_L2_DATA_WRITE_HIT", 0x65
"PERFMON_L2_DATA_WRITE_REQUEST", 0x66
"PERFMON_L2_DATA_WRITE_REQUEST_WITH_WRITE_THROUGH", 0x67
"PERFMON_L2_INSTRUCTION_READ_HIT", 0x68
"PERFMON_L2_INSTRUCTION_READ_REQUEST", 0x69
"PERFMON_L2_WRITE_ALLOCATION", 0x6A
"PERFMON_L2_EMC5_OVERFLOW", 0x6B
"PERFMON_L2_EMC4_OVERFLOW", 0x6C
"PERFMON_L2_EMC3_OVERFLOW", 0x6D
"PERFMON_L2_EMC2_OVERFLOW", 0x6E
"PERFMON_L2_EMC1_OVERFLOW", 0x6F
"PERFMON_L2_EMC0_OVERFLOW", 0x70
"PERFMON_L2_CLK_CYCLE", 0x71
"PERFMON_INSTRUCTIONS_DISPATCHED", 0x72
"PERFMON_IMEM_BUBBLES", 0x73
"PERFMON_SRAM_INSTRUCTIONS", 0x74
"PERFMON_CACHEABLE_INSTRUCTIONS", 0x75
"PERFMON_ICACHE_DMA_ACCESSES", 0x76
"PERFMON_DMA_STALL_CYCLES", 0x77
"PERFMON_DDR_INSTRUCTIONS", 0x78
"PERFMON_DDR_INSTRUCTION_STALL_CYCLES", 0x79
"PERFMON_TAKEN_BRANCHES", 0x7A
"PERFMON_LOAD_HIT_STALL_CYCLES", 0x7B
"PERFMON_CACHEABLE_LOADS", 0x7C
"PERFMON_CACHEABLE_STORES", 0x7D
"PERFMON_LOAD_DCACHE_HITS", 0x7E
"PERFMON_STORE_DCACHE_HITS", 0x7F
"PERFMON_LOAD_FILL_BUFFER_HITS", 0x80
"PERFMON_LOAD_FILL_BUFFER_STALL_CYCLES", 0x81
"PERFMON_STORE_FILL_BUFFER_HITS", 0x82
"PERFMON_STORE_FILL_BUFFER_STALL_CYCLES", 0x83
"PERFMON_LOAD_L1_MISSES", 0x84
"PERFMON_STORE_L1_MISSES", 0x85
"PERFMON_LOAD_L1_MISS_STALL_CYCLES", 0x86
"PERFMON_STORE_L1_MISS_STALL_CYCLES", 0x87
"PERFMON_LOAD_L1_HITS", 0x88
"PERFMON_L1_ACCESSES", 0x89
"PERFMON_L1_DSRAM_DMA_ACCESSES", 0x8A
"PERFMON_L1_DSRAM_DMA_CONFLICTS", 0x8B
"PERFMON_L2_DSRAM_DMA_ACCESSES", 0x8C
"PERFMON_L2_DSRAM_DMA_CONFLICTS", 0x8D
"PERFMON_STORE_BUFFER_FULL_STALL_CYCLES", 0x8E
"PERFMON_WRITE_BUFFER_FULL_STALL_CYCLES", 0x8F
"PERFMON_L1_DSRAM_DAG_CONFLICTS", 0x90
"PERFMON_L1_DCACHE_DAG_CONFLICTS", 0x91
"PERFMON_DAG1_CONFLICTS", 0x92
"PERFMON_DAG1_L1_STORE_CONFLICT_STALL_CYCLES", 0x93
"PERFMON_MSA_GPB_ACCESSES", 0x94
"PERFMON_MSA_GPB_ACCESS_STALL_CYCLES", 0x95
"PERFMON_L2_DSRAM_LOAD_REQUESTS", 0x96
"PERFMON_L2_DSRAM_LOAD_STALL_CYCLES", 0x97
"PERFMON_L2_DSRAM_REQUESTS", 0x98
"PERFMON_GPB_LOADS", 0x99
"PERFMON_GPB_LOAD_STALL_CYCLES", 0x9A
"PERFMON_GPB_ACCESSES", 0x9B
"PERFMON_ASPEC_LOADS", 0x9C
"PERFMON_ASPEC_LOAD_STALL_CYCLES", 0x9D
"PERFMON_ASPEC_ACCESSES", 0x9E
"PERFMON_DDR_DATA_LOAD_REQUESTS", 0x9F
"PERFMON_DDR_DATA_LOAD_STALL_CYCLES", 0xA0
"PERFMON_DDR_DATA_REQUESTS", 0xA1
"PERFMON_MMR_LOAD_REQUESTS", 0xA2
"PERFMON_MMR_LOAD_STALL_CYCLES", 0xA3
"PERFMON_MMR_ACCESSES", 0xA4
"PERFMON_L2_ISRAM_DWORD_ACCESSES", 0xA5
"PERFMON_INSTRUCTION_ARBITRATION_CYCLES", 0xA6
"PERFMON_ARM9_L2_SRAM_LOADS", 0xA7
"PERFMON_ARM9_L2_SRAM_STORES", 0xA8
"PERFMON_ARM9_L2_SRAM_LOAD_DWORD_HITS", 0xA9
"PERFMON_ARM9_L2_SRAM_LOAD_ARBITRATION_CYCLES", 0xAA
"PERFMON_ARM9_L2_SRAM_CYCLES", 0xAB
"PERFMON_EX_DATA_HAZARD_STALL_CYCLES", 0xAC
"PERFMON_ARM9_GPB_LOADS", 0xAD
"PERFMON_ARM9_GPB_ACCESS_CYCLES", 0xAE
"PERFMON_ARM9_GPB_STORES", 0xAF
"PERFMON_DDR_LOADS", 0xB0
"PERFMON_DDR_LOAD_CYCLES", 0xB1
"PERFMON_DDR_STORES", 0xB2
"PERFMON_DDR_DMA_WAIT_CYCLES", 0xB3
"PERFMON_ARM9_DDR_LOADS", 0xB4
"PERFMON_ARM9_DDR_LOAD_LINE_BUFFER_HITS", 0xB5
"PERFMON_ARM9_DDR_STORES", 0xB6
"PERFMON_ARM9_DDR_LOAD_ACCESS_CYCLES", 0xB7
"PERFMON_NUM_STATS", 0xB8
END ENUM "PERFMON_STAT"

BEGIN ENUM "SetChargingStatus"
"SETCHARGING_SUCCESS", 0x0
"SETCHARGING_FAILED", 0x1
"SETCHARGING_UNSUPPORTED_RATE", 0x2
END ENUM "SetChargingStatus"

BEGIN ENUM "DeviceProfileCommand"
"GET_DEVICE_PROFILE", 0x0
"SET_DEVICE_PROFILE", 0x1
"SEARCH_DEVICE_PROFILE", 0x2
END ENUM "DeviceProfileCommand"

BEGIN ENUM "USB_ENUM_MODE"
"USB_ENUM_MODE_BBMS", 0x1
"USB_ENUM_MODE_BBMSMTP", 0x4
END ENUM "USB_ENUM_MODE"

BEGIN ENUM "MMUDomainAC"
"MMU_NoAccess", 0x0
"MMU_Client", 0x1
"MMU_Reserved", 0x2
"MMU_Manager", 0x3
END ENUM "MMUDomainAC"

BEGIN ENUM "SDMMCSubCommandParam"
"SDMMC_PARAM_FAKE_SDCARD_INSERT", 0x0
"SDMMC_PARAM_FAKE_SDCARD_REMOVE", 0x1
END ENUM "SDMMCSubCommandParam"

BEGIN ENUM "RimSTPHWVTableAccess"
"STP_HWV_ADD", 0x0
"STP_HWV_READ", 0x1
"STP_HWV_APPEND", 0x2
END ENUM "RimSTPHWVTableAccess"

BEGIN ENUM "FrequencyChangeBlocker"
"FREQ_CHANGE_BLOCK_LCD", 0x0
"FREQ_CHANGE_BLOCK_NAND", 0x1
END ENUM "FrequencyChangeBlocker"

BEGIN ENUM "PadEdgeDetect"
"EDGE_DETECT_DEFAULT", 0x0
"EDGE_DETECT_ENABLE", 0x1
"EDGE_DETECT_DISABLE", 0x2
END ENUM "PadEdgeDetect"

BEGIN ENUM "PmProfileCoreStage"
"PM_CORE_STAGE_C0", 0x0
"PM_CORE_STAGE_C1L1", 0x1
"PM_CORE_STAGE_L2D2", 0x2
"PM_CORE_STAGE_ALL", 0x3
END ENUM "PmProfileCoreStage"

BEGIN ENUM "BatteryStatsType"
"BATT_STATS_UNKNOWN", 0x0
"BATT_STATS_PROTON", 0x1
"BATT_STATS_TACHYON", 0x2
END ENUM "BatteryStatsType"

BEGIN ENUM "DcIdType"
"BSN", 0x2
"IMEI", 0x3
"BBPIN", 0x4
"OS_VERSION_ID", 0x5
"HW_PLATFORM_ID", 0x6
"HW_FREQ_MAP", 0x7
"SIM_ICCID", 0x8
"SIM_IMSI", 0x9
"BSN_BARYON_RADIO", 0xA
"MSN_BARYON", 0xB
"PATRIOT_BINARY_VER", 0xC
"SIM_ID_BARYON", 0xD
"HW_BOARD_REV", 0xE
"IMEI_BARYON_GW", 0xF
"HW_STRING", 0x10
"BOOTROM_ID", 0x11
"BLUETOOTH_MAC", 0x12
"WLAN_MAC", 0x13
"RADIOCODE_LINKED_ID", 0x14
"OS_METRICS_VERSION", 0x15
"BARCODE_ID", 0x16
"MEID", 0x17
END ENUM "DcIdType"

BEGIN ENUM "PmProfileDynamicField"
"PM_ACTIVE_WAF", 0x0
"PM_NETWORK_SERVICE", 0x1
"PM_NETWORK_MODE", 0x2
"PM_GPS_LATITUDE", 0x3
"PM_GPS_LONGITUDE", 0x4
"PM_PA_TEMPERATURE", 0x5
"PM_GPS_TEMPERATURE", 0x6
"PM_RADIO_TX_POWER", 0x7
"PM_BT_TX_POWER", 0x8
"PM_WLAN_TX_POWER", 0x9
"PM_CHARGE_RATE", 0xA
"PM_DDR_OVERTEMP", 0xB
"PM_NUM_DYNAMIC_FIELDS", 0xC
END ENUM "PmProfileDynamicField"

BEGIN ENUM "PadDriveStrengthSlewRate"
"DEFAULT_STRENGTH_SLEW", 0x0
"PAD_DRIVE_SLOW", 0x1
"PAD_DRIVE_MEDIUM", 0x2
"PAD_DRIVE_FAST", 0x3
END ENUM "PadDriveStrengthSlewRate"

BEGIN ENUM "GpsStpErrorCode"
"GPSSTPERROR_SUCCESS", 0x0
"GPSSTPERROR_FAILURE", 0x1
"GPSSTPERROR_INVALID_PARAMETERS", 0x2
"GPSSTPERROR_INVALID_GPS_RESPONSE", 0x3
"GPSSTPERROR_TEST_NOT_STARTED", 0x10000
"GPSSTPERROR_TEST_IN_PROGRESS", 0x10001
"GPSSTPERROR_TEST_NO_RESULT_AVAILABLE", 0x10002
END ENUM "GpsStpErrorCode"

BEGIN ENUM "AdcValueType"
"ADC_VAMP", 0x0
"ADC_TEMP", 0x1
"ADC_MIC", 0x2
"ADC_EL_HEADSET_DET", 0x3
"ADC_EL_HEADSET_SW", 0x4
"ADC_EL_VBATT", 0x5
"ADC_EL_THERM", 0x6
"ADC_EL_CHG_MON", 0x7
"ADC_EL_THERM2", 0x8
"ADC_EL_BATT_ID1", 0x9
"ADC_EL_PA_I_SENS", 0xA
"ADC_EL_PA_V_SENS", 0xB
"ADC_EL_AUDIO_DET", 0xC
"ADC_MIC_HEADSET", 0xD
"ADC_MIC_BT", 0xE
"STPADC_RADIO_TEMP", 0xF
"STPADC_LIGHTSENSOR", 0x10
"STPADC_VRTC", 0x11
"STPADC_VSYS", 0x12
"STPADC_CHARGER_TEMP", 0x13
"STPADC_GPS_TEMP", 0x14
"STPADC_BATID", 0x15
"STPADC_LIGHTSENSOR_EXTERNAL", 0x16
"STPADC_DEPRECATED_1", 0x17
"STPADC_DEPRECATED_2", 0x18
"ADC_INVALID", 0xFF
END ENUM "AdcValueType"

BEGIN ENUM "HwVersionStatus"
"HWV_SUCCESS", 0x0
"HWV_UNKNOWN_TYPE", 0x1
"HWV_OLD_METRICS_DATA", 0x2
END ENUM "HwVersionStatus"

BEGIN ENUM "ScTestState"
"SCTEST_OFF", 0x0
"SCTEST_STARTED", 0x1
"SCTEST_PASSED", 0x2
END ENUM "ScTestState"

BEGIN ENUM "ToneMode"
"TONE_ON", 0x0
"TONE_OFF", 0x1
END ENUM "ToneMode"

BEGIN ENUM "SwPartListCommand"
"READ_PART_LIST", 0x0
"WRITE_PART_LIST", 0x1
"ERASE_PART_LIST", 0x2
"INSERT_PART_NUMBER", 0x3
"REMOVE_PART_NUMBER", 0x4
"REQUEST_VERSION", 0x5
END ENUM "SwPartListCommand"

BEGIN ENUM "FlagSuspend"
"FLAG_NO_SUSPEND", 0x4
"FLAG_SUSPEND", 0x5
END ENUM "FlagSuspend"

BEGIN ENUM "Error_t"
"E_OK", 0x0
"E_NOMEM", 0x1
"E_ARG", 0x2
"E_DEADLCK", 0x3
"E_PERM", 0x4
"E_ISBUSY", 0x5
"E_TIMEDOUT", 0x6
"E_CRITSEC", 0x7
"E_CATFAIL", 0x8
"E_NOTFOUND", 0x9
"E_EXIST", 0xA
"E_NODATA", 0xB
"E_FULL", 0xC
"RIM_E_FAIL", 0x100
"RIM_E_NOTSUP", 0x101
"RIM_E_CORENOTSUP", 0x102
"RIM_E_BUFSIZE", 0x103
"RIM_E_AGAIN", 0x104
END ENUM "Error_t"

BEGIN ENUM "MMUDomain"
"MMU_Domain0", 0x0
"MMU_Domain1", 0x1
"MMU_Domain2", 0x2
"MMU_Domain3", 0x3
"MMU_Domain4", 0x4
"MMU_Domain5", 0x5
"MMU_Domain6", 0x6
"MMU_Domain7", 0x7
"MMU_Domain8", 0x8
"MMU_Domain9", 0x9
"MMU_Domain10", 0xA
"MMU_Domain11", 0xB
"MMU_Domain12", 0xC
"MMU_Domain13", 0xD
"MMU_Domain14", 0xE
"MMU_Domain15", 0xF
END ENUM "MMUDomain"

BEGIN ENUM "HsioClk"
"HSIO_CLK_104", 0x0
"HSIO_CLK_156", 0x1
"HSIO_CLK_208", 0x2
"N_HSIO_CLKS", 0x3
END ENUM "HsioClk"

BEGIN ENUM "PmProfileInterval"
"PM_BATTERY_UPDATE_INTERVAL", 0x1
"PM_UPTIME_INTERVAL", 0x2
"PM_USER_INTERVAL", 0x3
"PM_BATTERY_CHECK_INTERVAL", 0x4
"PM_NUM_INTERVALS", 0x5
END ENUM "PmProfileInterval"

BEGIN ENUM "DisplayType"
"PRIMARY_DISPLAY", 0xFFFFFFFF
"AUXILLARY_DISPLAY", 0xFFFFFFFE
"TVOUT_DISPLAY", 0xFFFFFFFD
END ENUM "DisplayType"

BEGIN ENUM "PowerSavingMode"
"POWER_ICON_OFF", 0x0
END ENUM "PowerSavingMode"

BEGIN ENUM "FILE_STATUS"
"FILE_STATUS_SUCCESS", 0x0
"FILE_STATUS_PENDING", 0x1
"FILE_STATUS_INVALID_HANDLE", 0x2
"FILE_STATUS_INVALID_PARAMETER", 0x3
"FILE_STATUS_FILE_SYSTEM_UNAVAILABLE", 0x4
"FILE_STATUS_OS_BUSY", 0x5
"FILE_STATUS_GENERAL_ERROR", 0x6
"FILE_STATUS_FILENAME_ALREADY_EXISTS", 0x7
"FILE_STATUS_FILENAME_NOT_FOUND", 0x8
"FILE_STATUS_FILESYSTEM_FULL", 0x9
"FILE_STATUS_FILESYSTEM_EMPTY", 0xA
"FILE_STATUS_NO_FREE_HANDLES", 0xB
"FILE_STATUS_INVALID_OPERATION", 0xC
"FILE_STATUS_FILENAME_TOO_LONG", 0xD
"FILE_STATUS_DIRECTORY_FULL", 0xE
"FILE_STATUS_DIRECTORY_ALREADY_EXISTS", 0xF
"FILE_STATUS_DIRECTORY_NOT_FOUND", 0x10
"FILE_STATUS_DIRECTORY_NOT_EMPTY", 0x11
"FILE_STATUS_MEDIUM_NOT_FORMATTED", 0x12
"FILE_STATUS_FS_ALREADY_MOUNTED", 0x13
"FILE_STATUS_FILE_HANDLES_OPEN", 0x14
"FILE_STATUS_FS_NOT_MOUNTED", 0x15
"FILE_STATUS_FS_VERIFICATION_FAILED", 0x16
"FILE_STATUS_INVALID_PARTITION_SIZE", 0x17
"FILE_STATUS_FILE_SYSTEM_UNSUPPORTED", 0x18
"FILE_STATUS_FILE_BUSY", 0x19
"FILE_STATUS_FS_IRREPARABLE", 0x1A
"FILE_STATUS_HANDLE_FORCIBLY_CLOSED", 0x1B
"FILE_STATUS_OUT_OF_MEMORY", 0x1C
"FILE_STATUS_FILEPATH_TOO_LONG", 0x1D
"FILE_STATUS_DIRPATH_TOO_LONG", 0x1E
END ENUM "FILE_STATUS"

BEGIN ENUM "BkltStpOperation_t"
"BKLT_STP_OP_UNKNOWN", 0x0
"BKLT_STP_OP_GET_TUNING_POINT", 0x1
"BKLT_STP_OP_SET_TUNING_POINT", 0x2
"BKLT_STP_OP_BEGIN_TUNING_POINT", 0x3
"BKLT_STP_OP_SET_TUNING_POINT_ENABLED", 0x4
"BKLT_STP_OP_END_TUNING", 0x5
"BKLT_STP_OP_DELETE_NVRAM", 0x6
"BKLT_STP_OP_BSBT_ADJUST", 0x7
"BKLT_STP_OP_BSBT_BEGIN", 0x8
"BKLT_STP_OP_BSBT_CANCEL", 0x9
"BKLT_STP_OP_BSBT_CLEAR", 0xA
"BKLT_STP_OP_BSBT_CLEAR_ALL", 0xB
"BKLT_STP_OP_BSBT_COMMIT", 0xC
"BKLT_STP_OP_BSBT_LIST", 0xD
"BKLT_STP_OP_BSBT_SET", 0xE
END ENUM "BkltStpOperation_t"

BEGIN ENUM "GpsStpSubCommand"
"GPSSTPCMD_GET_FIRMWARE_VERSION_STRING", 0x0
"GPSSTPCMD_SIRF_TESTMODE4_START", 0x10000
"GPSSTPCMD_SIRF_TESTMODE4_STOP", 0x10001
"GPSSTPCMD_SIRF_TESTMODE4_GET_RESULT", 0x10002
"GPSSTPCMD_QC_STANDALONE_START", 0x20000
"GPSSTPCMD_QC_STANDALONE_STOP", 0x20001
"GPSSTPCMD_QC_STANDALONE_GET_RESULT", 0x20002
END ENUM "GpsStpSubCommand"

BEGIN ENUM "logEvents_t"
"AudioLoggingHSinserts", 0x0
"AudioLoggingModeAlertHandsfree", 0x1
"AudioLoggingModeAlertHeadset", 0x2
"AudioLoggingModeAlertHandset", 0x3
"AudioLoggingModeAlertHeadsetHandsfree", 0x4
"AudioLoggingModeAlertBluetoothHandsfree", 0x5
"AudioLoggingModeVoiceHandsfree", 0x6
"AudioLoggingModeVoiceHeadset", 0x7
"AudioLoggingModeVoiceHandset", 0x8
"AudioLoggingModeVoiceBluetooth", 0x9
"AudioLoggingModeVoiceBluetoothAudioProcessing", 0xA
"AudioLoggingModeVoiceTelecoil", 0xB
"AudioLoggingModeTtyExtFull", 0xC
"AudioLoggingModeTtyExtTalk", 0xD
"AudioLoggingModeTtyExtHear", 0xE
"AudioLoggingModeTtyIntFull", 0xF
"AudioLoggingModeTtyIntTalk", 0x10
"AudioLoggingModeTtyIntHear", 0x11
"AudioLoggingModeVADHeadset", 0x12
"AudioLoggingModeVADHandsfree", 0x13
"AudioLoggingModeVADBluetooth", 0x14
"AudioLoggingModeVADBluetoothAudioProcessing", 0x15
"AudioLoggingModeAlertBluetoothA2DPMono", 0x16
"AudioLoggingModeAlertBluetoothA2DPStereo", 0x17
"AudioLoggingModeCPHandsetHeadset", 0x18
"AudioLoggingModeCPHandsetBluetooth", 0x19
"AudioLoggingModeCPHeadsetHandset", 0x1A
"AudioLoggingModeCPHeadsetHandsfree", 0x1B
"AudioLoggingModeCPBluetoothHandset", 0x1C
"AudioLoggingModeCPBluetoothHandsfree", 0x1D
"AudioLoggingModeAlertHeadphones", 0x1E
"AudioLoggingModeMmHandsfree", 0x1F
"AudioLoggingModeMmHeadset", 0x20
"AudioLoggingModeMmHandset", 0x21
"AudioLoggingModeMmBluetoothA2DPMono", 0x22
"AudioLoggingModeMmBluetoothA2DPStereo", 0x23
"AudioLoggingModeMmHeadphones", 0x24
"AudioLoggingModeVADHeadphones", 0x25
"AudioLoggingModeVoiceHeadphones", 0x26
"AudioLoggingModeVoiceRecordingHandset", 0x27
"AudioLoggingModeVoiceRecordingHandsfree", 0x28
"AudioLoggingModeVoiceRecordingHeadset", 0x29
"AudioLoggingModeVoiceRecordingBluetooth", 0x2A
"AudioLoggingModeVoiceRecordingBluetoothAudioProcessing", 0x2B
"AudioLoggingModeVoiceRecordingHeadphones", 0x2C
"AudioLoggingHookswitchPressButton0", 0x2D
"AudioLoggingHookswitchPressButton1", 0x2E
"AudioLoggingHookswitchPressButton2", 0x2F
"AudioLoggingHookswitchPressButton3", 0x30
"AudioLoggingHookswitchPressButton4", 0x31
"AudioLoggingHookswitchPressButton5", 0x32
"AudioLoggingModeVideoPlaybackHandset", 0x33
"AudioLoggingModeVideoPlaybackHandsfree", 0x34
"AudioLoggingModeVideoPlaybackHeadset", 0x35
"AudioLoggingModeVideoPlaybackHeadphones", 0x36
"AudioLoggingModeVideoPlaybackBluetoothA2DPStereo", 0x37
"AudioLoggingModeVideoPlaybackBluetoothA2DPMono", 0x38
"AudioLoggingModeVoicePttHandsfree", 0x39
"AudioLoggingModeUnsupported", 0x3A
"RIM_NUM_AUDIO_LOG_EVENTS", 0x3B
END ENUM "logEvents_t"

BEGIN ENUM "DcErrorCode"
"DC_PASS", 0x0
"DC_FAIL", 0x1
"UNKNOWN_ACCESS_TYPE", 0x2
"UNKNOWN_ID_TYPE", 0x3
"UNAVAILABLE_ID", 0x4
"ID_NOT_READY", 0x5
END ENUM "DcErrorCode"

BEGIN ENUM "RimBluetoothRadioStatus"
"BT_STP_RADIO_STATE_SHUTDOWN", 0x0
"BT_STP_RADIO_STATE_SHUTTING_DOWN", 0x1
"BT_STP_RADIO_STATE_RESETTING", 0x2
"BT_STP_RADIO_STATE_INITIALIZING", 0x3
"BT_STP_RADIO_STATE_READY", 0x4
END ENUM "RimBluetoothRadioStatus"

BEGIN ENUM "FrequencyChangeMaxer"
"FREQ_CHANGE_MAX_GRAPHICS", 0x0
"FREQ_CHANGE_MAX_CAMERA_CLOCK", 0x1
"FREQ_CHANGE_MAX_CAMERA_I2C", 0x2
END ENUM "FrequencyChangeMaxer"

BEGIN ENUM "SDMMCSubCommandReturn"
"SDMMC_RET_FAILURE", 0x0
"SDMMC_RET_SUCCESS", 0x1
"SDMMC_RET_INVALID_PARAMETER", 0x2
"SDMMC_RET_CMD_UNSUPPORTED", 0x3
END ENUM "SDMMCSubCommandReturn"

BEGIN ENUM "USB_VETO_FUNCTIONS"
"USB_VETO_VSP1", 0x1
"USB_VETO_VSP2", 0x2
"USB_VETO_CALTASK", 0x4
"USB_VETO_USBMS", 0x8
"USB_VETO_BUGDISP", 0x10
"USB_VETO_ALL", 0x1F
END ENUM "USB_VETO_FUNCTIONS"

BEGIN ENUM "regionSize"
"size_4k", 0xB
"size_8k", 0xC
"size_16k", 0xD
"size_32k", 0xE
"size_64k", 0xF
"size_128k", 0x10
"size_256k", 0x11
"size_512k", 0x12
"size_1M", 0x13
"size_2M", 0x14
"size_4M", 0x15
"size_8M", 0x16
"size_16M", 0x17
"size_32M", 0x18
"size_64M", 0x19
"size_128M", 0x1A
"size_256M", 0x1B
"size_512M", 0x1C
"size_1G", 0x1D
"size_2G", 0x1E
"size_4G", 0x1F
END ENUM "regionSize"

BEGIN ENUM "LcdCalibCommand"
"USE_LCD_CALIBRATION", 0x0
"READ_LCD_CALIBRATION", 0x1
"WRITE_LCD_CALIBRATION", 0x2
END ENUM "LcdCalibCommand"

BEGIN ENUM "ChargingSource"
"CHARGING_SOURCE_NONE", 0x0
"CHARGING_SOURCE_USB", 0x1
"CHARGING_SOURCE_CONTACTS", 0x2
END ENUM "ChargingSource"

BEGIN ENUM "PadDirection"
"PAD_DIRECTION_INPUT", 0x0
"PAD_DIRECTION_OUTPUT", 0x1
END ENUM "PadDirection"

BEGIN ENUM "PadPullSel"
"PULL_SEL_DEFAULT", 0x0
"PULL_SEL_MFPR", 0x1
"PULL_SEL_ALT_MODE", 0x2
END ENUM "PadPullSel"

BEGIN ENUM "CalDataId"
"CAL_CF1_2VINTREFCALWORD", 0x17
"CAL_CFVAMPADCVALUE", 0x1D
"CAL_CFCHARGERTEMP", 0x26
"CAL_CFTCXOTEMP", 0x27
"CAL_CFBATTERYTEMP", 0x28
"CAL_LAST_ENTRY", 0x29
END ENUM "CalDataId"

BEGIN ENUM "displayControl"
"DISPLAY_CTRL_NONE", 0x0
"DISPLAY_CTRL_ENABLE_OS", 0x1
"DISPLAY_CTRL_ENABLE_APPS", 0x2
"DISPLAY_CTRL_ENABLE_ALL", 0x3
END ENUM "displayControl"

BEGIN ENUM "DEVICE_HARDWARE_CAPABILITY"
"HW_CAP_SERIAL", 0x0
"HW_CAP_USB", 0x1
"HW_CAP_IRDA", 0x2
"HW_CAP_BUILTIN_HEADSET", 0x3
"HW_CAP_REMOVABLE_BATTERY", 0x4
"HW_CAP_SMARTCARD_READER", 0x5
"HW_CAP_GPS", 0x6
"HW_CAP_LOUD_AUDIO", 0x7
"HW_CAP_BLUETOOTH", 0x8
"HW_CAP_BUZZER", 0x9
"HW_CAP_RESERVED_1", 0xA
"HW_CAP_TRICOLOUR_LED", 0xB
"HW_CAP_RF_AERO", 0xC
"HW_CAP_RTC_BACKUP_POWER", 0xD
"HW_CAP_NETWORK_TIME", 0xE
"HW_CAP_HEADSET_DETECT", 0xF
"HW_CAP_LIGHT_SENSOR", 0x10
"HW_CAP_OTA_UPDATE", 0x11
"HW_CAP_TRACKBALL", 0x12
"HW_CAP_SDCARD", 0x13
"HW_CAP_SDCARD_HOT_SWAPPABLE", 0x14
"HW_CAP_CAMERA", 0x15
"HW_CAP_WLAN", 0x16
"HW_CAP_TRACKBALL_LED", 0x17
"HW_CAP_BATTERY_DOOR_DETECT", 0x18
"HW_CAP_STYLUS", 0x19
"HW_CAP_TOUCHSCREEN", 0x1A
"HW_CAP_ACCELEROMETER", 0x1B
"HW_CAP_CAMERA_AF", 0x1C
"HW_CAP_CAMERA_NO_FLASH", 0x1D
"HW_CAP_VCLICK", 0x1E
"HW_CAP_TRACKBALL_OPTICAL", 0x1F
"HW_CAP_BLOCK_COMPACT", 0x20
"HW_CAP_NUM_ENTRIES", 0x21
END ENUM "DEVICE_HARDWARE_CAPABILITY"

BEGIN ENUM "ClockGuard"
"CLOCK_GUARD_INT", 0x0
"CLOCK_GUARD_SEM", 0x1
"CLOCK_GUARD_CRITICALINT", 0x2
END ENUM "ClockGuard"

BEGIN ENUM "PASSWORD_MATCH"
"PASSWORD_NOMATCH", 0x0
"PASSWORD_MATCH1", 0x1
"PASSWORD_MATCH2", 0x2
END ENUM "PASSWORD_MATCH"

BEGIN ENUM "AutofocusPositionTypes"
"AUTOFOCUS_MACRO", 0x0
"AUTOFOCUS_INFINITY", 0x1
END ENUM "AutofocusPositionTypes"

BEGIN ENUM "ProfileFlags_t"
"OSPROF_CODE_BLOCK_ACTIVE_MASK", 0x1
"OSPROF_NVFLAG_ENABLE_MASK", 0x2
"OSPROF_MEMORY_NOT_ALLOCATED_MASK", 0x4
"OSPROF_TIME_BASED_MASK", 0x8
"OSPROF_BLOCK_NAME_STRING", 0x10
END ENUM "ProfileFlags_t"

BEGIN ENUM "SLOW_CLOCK_INTERVAL"
"SC_BATTERY_UPDATE_INTERVAL", 0x1
"SC_UPTIME_INTERVAL", 0x2
END ENUM "SLOW_CLOCK_INTERVAL"

BEGIN ENUM "RimRadioCmdEnum"
"RADIO_CMD_ALL", 0x0
"RADIO_CMD_ORPHEUS", 0x1
"RADIO_CMD_CERBERUS", 0x2
END ENUM "RimRadioCmdEnum"

BEGIN ENUM "BindProcessorStatus"
"BIND_OK", 0x0
"BIND_FAILED_BAD_BOOTROM", 0x1
"BIND_FAILED_INVALID_BOOT_MODE", 0x2
"BIND_FAILED_OUT_OF_MEMORY", 0x3
"BIND_FAILED_BAD_BOOT_HEADER", 0x4
"BIND_FAILED_HARDWARE_ERROR", 0x5
"BIND_FAILED_VALIDATION_ERROR", 0x6
"BIND_FAILED_KEY_FUSES", 0x7
"BIND_FAILED_PLATFORM_FUSES", 0x8
"BIND_FAILED_ALREADY_BOUND", 0x9
END ENUM "BindProcessorStatus"

BEGIN ENUM "WlanWl6CalibrationAreaEnum"
"WLAN_WL6_CAL_AREA_NVS", 0x0
"WLAN_WL6_CAL_AREA_INI", 0x1
END ENUM "WlanWl6CalibrationAreaEnum"

BEGIN ENUM "AudioLoopBackTestStatus"
"AUDIO_LOOPBACK_TEST_UNSUPPORTED", 0x0
"AUDIO_LOOPBACK_TEST_PASS", 0x1
"AUDIO_LOOPBACK_TEST_FAIL", 0x2
END ENUM "AudioLoopBackTestStatus"

BEGIN ENUM "AudioLoopBackMode"
"AUDIO_LOOPBACK_ENABLE", 0x0
"AUDIO_LOOPBACK_DISABLE", 0x1
"AUDIO_LOOPBACK_BT_TEST", 0x2
"AUDIO_LOOPBACK_TI_TEST", 0x3
"AUDIO_LOOPBACK_PATRIOT_ENABLE", 0x4
"AUDIO_LOOPBACK_PATRIOT_DISABLE", 0x5
"AUDIO_LOOPBACK_DEEP_ENABLE", 0x6
"AUDIO_LOOPBACK_DEEP_DISABLE", 0x7
END ENUM "AudioLoopBackMode"

BEGIN ENUM "PadAttribute"
"PAD_OUTPUT", 0x0
"PAD_OUTPUT_SLEEP_OFF", 0x1
"PAD_OUTPUT_ENABLE", 0x2
"PAD_INPUT_ENABLE", 0x3
"PAD_PULL_UP", 0x4
"PAD_PULL_DOWN", 0x5
"PAD_INPUT", 0x6
"PAD_RISING_EDGE_LATCH", 0x7
"PAD_FALLING_EDGE_LATCH", 0x8
END ENUM "PadAttribute"

BEGIN ENUM "TaskID"
"TIMER_THREAD", 0x0
"DEBUG_THREAD", 0x1
"USB_THREAD", 0x2
"APP_THREAD", 0x3
"PLATFORM_THREAD", 0x4
"IDLE_THREAD", 0x5
"TASK_FIQ", 0xF1
END ENUM "TaskID"

BEGIN ENUM "GenericHeapBlockSearchType_e"
"SEARCH_NEVER_OWNED", 0x0
"SEARCH_CURRENTLY_OWNED", 0x1
"SEARCH_CURRENTLY_OWNED_BY_TASK", 0x2
"SEARCH_NOT_CURRENTLY_OWNED", 0x3
"SEARCH_PREVIOUSLY_OWNED", 0x4
"SEARCH_PREVIOUSLY_OWNED_BY_TASK", 0x5
"SEARCH_HAVING_TAG", 0x6
END ENUM "GenericHeapBlockSearchType_e"

BEGIN ENUM "FATFSImageCommand"
"FAT_FS_IMAGE_OPEN", 0x1
"FAT_FS_IMAGE_CLOSE", 0x2
"FAT_FS_IMAGE_WRITE", 0x3
"FAT_FS_IMAGE_READ", 0x4
"FAT_FS_IMAGE_RESIZE_MEDIUM", 0x5
"FAT_FS_IMAGE_WIPE_MEDIUM", 0x6
"FAT_FS_IMAGE_GET_FS_HASH", 0x7
"NUM_FAT_FS_IMAGE_COMMANDS", 0x8
END ENUM "FATFSImageCommand"

BEGIN ENUM "MutexStyle_t"
"MUTEXSTYLE_DEFAULT", 0x0
"MUTEXSTYLE_RECURSIVE", 0x1
END ENUM "MutexStyle_t"

BEGIN ENUM "FATFSImageMediumType"
"MEDIUM_TYPE_MMC", 0x1
"MEDIUM_TYPE_SDCARD", 0x2
"MEDIUM_TYPE_NAND", 0x3
"NUM_MEDIUM_TYPES", 0x4
END ENUM "FATFSImageMediumType"

BEGIN ENUM "NvramBitFlag"
"NVRAM_BITFLAGS_LOUD_AUDIO_ENABLED", 0x0
"NVRAM_BITFLAGS_NO_RADIO_CAL_SECTOR", 0x1
"NVRAM_BITFLAGS_GPS_FIRMWARE_UPDATE_DISABLED", 0x2
"NVRAM_BITFLAGS_SD_BUGDISP_LOG_ENABLED", 0x3
"NVRAM_BITFLAGS_GPS_PUSH_FREQ_AIDING", 0x4
"NVRAM_BITFLAGS_FORCE_BUGDISP_ENCRYPT", 0x5
"NVRAM_BITFLAGS_FORCE_BUGDISP_NO_RTAS", 0x6
"NVRAM_BITFLAGS_FORCE_STP_NO_RTAS", 0x7
"NVRAM_BITFLAGS_SOC_NO_CATFAIL_ON_SOCKET_FAILURE", 0x8
"NVRAM_BITFLAGS_AUTO_SAVE_SD_RESET_LOG_ENABLED", 0x9
"NVRAM_BITFLAGS_AUTO_MOVE_SD_LOGS_ENABLED", 0xA
"NVRAM_BITFLAGS_RAM_CORRUPTED", 0xB
"NVRAM_BITFLAGS_BLOCKMAP_SECURE_ERASE", 0xC
"NVRAM_BITFLAGS_PATRIOT_FLASHSTRAP_VER7", 0xD
"NVRAM_BITFLAGS_EFS_CACHE_FLUSH_INCOMPLETE", 0xE
"NVRAM_BITFLAGS_IN_PRODUCTION", 0xF
"NVRAM_BITFLAGS_RUN_NAND_FLASH_TEST", 0x10
"NVRAM_BITFLAGS_LOG_MEMTYPE_SDCARD_NOT_MMC", 0x11
"NVRAM_BITFLAGS_GPS_DISABLED", 0x12
"NVRAM_BITFLAGS_GPS_USE_ALT_FREQ", 0x13
"NVRAM_BITFLAGS_GPS_EGYPT_LEGAL", 0x14
"NVRAM_BITFLAGS_GPS_EE_CLEAR", 0x15
"NVRAM_BITFLAGS_FORCE_POWER_OFF_AFTER_BATTERY_INSERTION", 0x16
"NVRAM_BITFLAGS_REQUIRE_POWER_KEY_HOLD_5_SECS", 0x17
"NVRAM_BITFLAGS_IS_QC_NV_INVALID", 0x18
"NVRAM_BITFLAGS_BATTERY_CHARGING_SCREEN_ENABLED", 0x19
"NVRAM_BITFLAGS_RAM_DUMP_ENABLED", 0x1A
"NVRAM_BITFLAGS_OVERRIDE_JVM_BLOCK", 0x1B
END ENUM "NvramBitFlag"

BEGIN ENUM "TimerName"
"VOIP_ESCREEN_TIMER", 0x1
"RTC_TIMER", 0x2
"SC_WAKEUP_TIMER", 0x3
"DTR_DEBOUNCE_TIMER", 0x4
"DSR_TOGGLE_TIMER", 0x5
"SERIAL_SCAN_TIMER", 0x6
"SERIAL_NOTIFY_TIMER", 0x7
"BT_DTR_DEBOUNCE_TIMER", 0x8
"BT_SERIAL_NOTIFY_TIMER", 0x9
"DEBUG_SERIAL_NOTIFY_TIMER", 0xA
"DEBUG_SERIAL_SCAN_TIMER", 0xB
"CB_SERIAL_NOTIFY_TIMER", 0xC
"USB_INVALID_STATE_TIMER", 0xD
"USB_SOFTCONNECT_TIMER", 0xE
"USB_RECONNECT_TIMER", 0xF
"USB_DISCONNECT_TIMER", 0x10
"USB_SMART_CHARGER_TIMER", 0x11
"USB_QUINCY_TIMER", 0x12
"USB_POLL_TIMER", 0x13
"USB_CD_DEBOUNCE_TIMER", 0x14
"USB_INT_N_ENABLE_TIMER", 0x15
"USB_ANTIOCH_INT_N_CHECK_TIMER", 0x16
"UNIT_TEST_TIMER_1", 0x17
"UNIT_TEST_TIMER_2", 0x18
"UNIT_TEST_TIMER_3", 0x19
"STP_MELODY_TIMER", 0x1A
"DTMF_TIMER", 0x1B
"AUDIO_HEARTBEAT_TIMER", 0x1C
"AUDIO_TUNE_TIMER", 0x1D
"AUDIOLOGGING_NVRAM_TIMEOUT", 0x1E
"HEADSET_DEBOUNCE_TIMER", 0x1F
"HOOKSWITCH_EXCLUSION_TIMER", 0x20
"HOOKSWITCH_BIAS_EXCLUSION_TIMER", 0x21
"HOOKSWITCH_CHANGED_DELAY_TIMER", 0x22
"MBH_TIMEOUT_TIMER", 0x23
"HOOKSWITCH_DEBOUNCE_TIMER", 0x24
"HOOKSWITCH_POLL_TIMER", 0x25
"HEADSET_GPIO_DEBOUNCE_TIMER", 0x26
"CODEC_DEBOUNCE_TIMER", 0x27
"CODEC_POLL_TIMER", 0x28
"CODEC_PENDING_OFF_TIMER", 0x29
"CODEC_RESET_TIMER", 0x2A
"HOOKSWITCH_GPIO_DEBOUNCE", 0x30
"SIMCARD_TIMEOUT_TIMER", 0x31
"SIMCARD_CLOCK_STOP_TIMER", 0x32
"SIMCARD_PROACTIVE_POLL_TIMER", 0x33
"RIM_VIDEO_TICK_TIMER", 0x34
"RIM_VIDEO_SATURATION_TIMER", 0x35
"RIM_MEDIA_SYNC_TIMER", 0x36
"RIM_VIDEO_FRAME_REQ_TIMER", 0x37
"TOUCHSCREEN_TIMER", 0x38
"IP_FRAG_TIMEOUT_TIMER", 0x39
"IPTRACK_ENTRY_AGE_TIMER", 0x3A
"TCP_RETRANSMISSION_TIMER", 0x3B
"TCP_CLOSE_TIME_WAIT_TIMER", 0x3C
"TCP_DELAYED_ACK_TIMER", 0x3D
"NETTP_REQUEST_TIMER", 0x3E
"DNS_TIMER", 0x3F
"WAF_CDMA_DEACTIVATE_GUARD_TIMER", 0x40
"WM_TNLCTRL_SM_TIMER_TID1", 0x41
"WM_TNLCTRL_SM_TIMER_TID2", 0x42
"WM_TNLCTRL_SM_TIMER_TID3", 0x43
"WM_TNLCTRL_SM_TIMER_TID4", 0x44
"WM_TNLCTRL_SM_TIMER_TID5", 0x45
"WM_TNLCTRL_SM_TIMER_TID6", 0x46
"WM_TNLCTRL_SM_TIMER_TID7", 0x47
"WM_TNLCTRL_SM_TIMER_TID8", 0x48
"TUNNEL_FOCUS_TIMER", 0x49
"TUNNEL_FOCUS_DEBOUNCE_TIMER", 0x4A
"RTCP_STREAMING_TIMER", 0x4B
"RTP_MEDIA_LENGTH_TIMER", 0x4C
"RTP_MEDIA_END_TIMER", 0x4D
"RTSP_STREAMING_CHECK_TIMER", 0x4E
"RTSP_KEEP_ALIVE_TIMER", 0x4F
"RTP_RINGBACK_TIMEOUT_TIMER", 0x50
"RTCP_VOIP_TIMER", 0x51
"RTCP_UMA_TIMER", 0x52
"PMIC_PULL_INT_TIMER", 0x53
"ADC_TIMER_0", 0x54
"ADC_TIMER_1", 0x55
"ADC_TIMER_2", 0x56
"ADC_TIMER_3", 0x57
"RTCP_TIMER", 0x58
"RTP_TIMEOUT_TIMER", 0x59
"RTP_STATISTICS_REPORT_TIMER", 0x5A
"RTP_GAN_MEASUREMENT_REPORT_TIMER", 0x5B
"WLAN_SCAN_TIMER", 0x5C
"WLAN_BACKOFF_TIMER", 0x5D
"WLAN_SCAN_ENGINE_TIMER", 0x5E
"ARP_REPLY_CHECK_TIMER", 0x5F
"ARP_CLEAR_CACHE_TIMER", 0x60
"DHCP_STATE_TIMER", 0x61
"DHCP_TX_TIMER", 0x62
"WLAN_SIGNAL_TIMER", 0x63
"WLAN_TX_ICON_TIMER", 0x64
"WLAN_RX_ICON_TIMER", 0x65
"ESCREENS2_GENERIC_TIMER", 0x66
"ESCREENS2_REFRESH_TIMER", 0x67
"WLAN_STATE_MACHINE_TIMER", 0x68
"STACK_FREE_STATUS_TIMER", 0x69
"TEST_WLAN_TIMER", 0x6A
"SEMAPHORE_TIMER", 0x6B
"IOTCTRL_XMIT_TIMER", 0x6C
"WLAN_ACTIVITY_PERCENTAGE_TIMER", 0x6D
"WLAN_POWER_STATISTICS_TIMER", 0x6E
"TI_WLAN_TIMER_0", 0x6F
"TI_WLAN_TIMER_1", 0x70
"TI_WLAN_TIMER_2", 0x71
"TI_WLAN_TIMER_3", 0x72
"TI_WLAN_TIMER_4", 0x73
"TI_WLAN_TIMER_5", 0x74
"TI_WLAN_TIMER_6", 0x75
"TI_WLAN_TIMER_7", 0x76
"TI_WLAN_TIMER_8", 0x77
"TI_WLAN_TIMER_9", 0x78
"TI_WLAN_TIMER_10", 0x79
"TI_WLAN_TIMER_11", 0x7A
"TI_WLAN_TIMER_12", 0x7B
"TI_WLAN_TIMER_13", 0x7C
"TI_WLAN_TIMER_14", 0x7D
"TI_WLAN_TIMER_15", 0x7E
"TI_WLAN_TIMER_16", 0x7F
"TI_WLAN_TIMER_17", 0x80
"TI_WLAN_TIMER_18", 0x81
"TI_WLAN_TIMER_19", 0x82
"TI_WLAN_TIMER_20", 0x83
"TI_WLAN_TIMER_21", 0x84
"TI_WLAN_TIMER_22", 0x85
"TI_WLAN_TIMER_23", 0x86
"TI_WLAN_TIMER_24", 0x87
"TI_WLAN_TIMER_25", 0x88
"TI_WLAN_TIMER_26", 0x89
"TI_WLAN_TIMER_27", 0x8A
"TI_WLAN_TIMER_28", 0x8B
"TI_WLAN_TIMER_29", 0x8C
"TI_WLAN_TIMER_30", 0x8D
"TI_WLAN_TIMER_31", 0x8E
"TI_WLAN_TIMER_32", 0x8F
"TI_WLAN_TIMER_33", 0x90
"TI_WLAN_TIMER_34", 0x91
"TI_WLAN_TIMER_35", 0x92
"TI_WLAN_TIMER_36", 0x93
"TI_WLAN_TIMER_37", 0x94
"TI_WLAN_TIMER_38", 0x95
"TI_WLAN_TIMER_39", 0x96
"TI_WLAN_TIMER_40", 0x97
"TI_WLAN_TIMER_41", 0x98
"TI_WLAN_TIMER_42", 0x99
"TI_WLAN_TIMER_43", 0x9A
"TI_WLAN_TIMER_44", 0x9B
"TI_WLAN_AP_POLL_TIMER", 0x9C
"SUPP_TIMER_0", 0x9D
"SUPP_TIMER_1", 0x9E
"SUPP_TIMER_2", 0x9F
"SUPP_TIMER_3", 0xA0
"SUPP_TIMER_4", 0xA1
"SUPP_TIMER_5", 0xA2
"SUPP_TIMER_6", 0xA3
"SUPP_TIMER_7", 0xA4
"SUPP_TIMER_8", 0xA5
"SUPP_TIMER_9", 0xA6
"SUPP_TIMER_10", 0xA7
"SUPP_TIMER_11", 0xA8
"SUPP_TIMER_12", 0xA9
"SUPP_TIMER_13", 0xAA
"SUPP_TIMER_14", 0xAB
"ESCREEN_APP_TIMER_1", 0xAC
"ESCREEN_APP_TIMER_2", 0xAD
"ESCREEN_APP_TIMER_3", 0xAE
"ESCREEN_APP_TIMER_4", 0xAF
"ESCREEN_APP_TIMER_5", 0xB0
"ESCREEN_APP_TIMER_6", 0xB1
"ESCREEN_APP_TIMER_7", 0xB2
"PGEN_SEND_PACKET_TIMER", 0xB3
"PGEN_EXECUTION_TIMER", 0xB4
"ESCREEN_APP_TIMER_10", 0xB5
"ESCREEN_APP_TIMER_11", 0xB6
"ADCTRL_TIMER", 0xB7
"DTIMEXTEND_ARP_REFRESH", 0xB8
"WLAN_LLC_ARP_TIMEOUT", 0xB9
"WAF_WLAN_DEACTIVATE_GUARD_TIMER", 0xBA
"VPN_IKE_REPLY_TIMER", 0xBB
"VPN_SIM_RETRY_TIMER", 0xBC
"VPN_KEEPALIVE_TIMER", 0xBD
"VPN_IKE_LIFETIME_TIMER", 0xBE
"VPN_IPSEC_LIFETIME_TIMER", 0xBF
"SOCKET_RX_TIMER", 0xC0
"SOCKET_TX_TIMER", 0xC1
"SOCKET_LINGER_TIMER", 0xC2
"SOCKET_CLOSE_TIMER", 0xC3
"SOCKET_IP_TX_BE_TIMER", 0xC4
"UMTS_RRC_TIMER", 0xC5
"UMTS_RLC_TIMER", 0xC6
"UMTS_MAC_TIMER", 0xC7
"GAS_RRC_TIMER", 0xC8
"GAS_T3182", 0xC9
"GAS_T3164", 0xCA
"GAS_T3180", 0xCB
"GAS_T3190", 0xCC
"GAS_T3192", 0xCD
"GAS_T3166", 0xCE
"GAS_T3184", 0xCF
"TIMER_TU3901", 0xD0
"TIMER_TU3902", 0xD1
"TIMER_TU3903", 0xD2
"TIMER_TU3904", 0xD3
"TIMER_TU3905", 0xD4
"TIMER_TU3906", 0xD5
"TIMER_TU3907", 0xD6
"TIMER_TU3908", 0xD7
"TIMER_TU3910", 0xD8
"TIMER_TU3920", 0xD9
"TIMER_TU4001", 0xDA
"TIMER_TU4002", 0xDB
"TIMER_TU4003", 0xDC
"TIMER_GAN_FLOW_CONTROL", 0xDD
"TIMER_GAN_FLUSH_PACKET_BUFFER", 0xDE
"TIMER_GAN_KEEPALIVE_ACTIVE", 0xDF
"TIMER_GAN_DEREGISTRATION_GUARD", 0xE0
"RSSI_SCAN_TIMER", 0xE1
"SELECT_MODE_TIMEOUT", 0xE3
"T201_LL3_TIMER", 0xE4
"T201_LL5_TIMER", 0xE5
"T201_LL9_TIMER", 0xE6
"T201_LL11_TIMER", 0xE7
"TIMER_PLMN_SEARCH", 0xE8
"TIMER_FLA_LIST_DELETE", 0xE9
"TIMER_3210", 0xEA
"TIMER_3211", 0xEB
"TIMER_3212", 0xEC
"TIMER_3213", 0xED
"TIMER_3220", 0xEE
"TIMER_3230", 0xEF
"TIMER_3240", 0xF0
"TIMER_3302", 0xF1
"TIMER_3310", 0xF2
"TIMER_3311", 0xF3
"TIMER_3312", 0xF4
"TIMER_3314", 0xF5
"TIMER_3318", 0xF6
"TIMER_3320", 0xF7
"TIMER_3321", 0xF8
"TIMER_3330", 0xF9
"TIMER_GPRS_DETACH_COMPLETE", 0xFA
"TIMER_RAT_CHANGE", 0xFB
"TIMER_E911_CALL_BACK", 0xFC
"TIMER_MM_RECOVERY", 0xFD
"TIMER_MM_UI_DEBOUNCE", 0xFE
"TIMER_33XX_NSAPI_5", 0xFF
"TIMER_33XX_NSAPI_6", 0x100
"TIMER_33XX_NSAPI_7", 0x101
"TIMER_33XX_NSAPI_8", 0x102
"TIMER_33XX_NSAPI_9", 0x103
"TIMER_33XX_NSAPI_10", 0x104
"TIMER_33XX_NSAPI_11", 0x105
"TIMER_RAB_ESTABLISH", 0x106
"MO_TC1M_TIMER", 0x107
"MT_TC1M_TIMER", 0x108
"TR1M_TIMER", 0x109
"TR2M_TIMER", 0x10A
"TRAM_TIMER", 0x10B
"TIMER_DELAY_APPS_ACK", 0x10C
"CAMERA2_AF_COMPLETE_CHK", 0x10D
"CAMERA2_SIMULATOR_FRAME_CAPTURE_SIM", 0x10E
"KEYPAD_DEBOUNCE_TIMER", 0x10F
"TIMER_SAT_MO_CALL", 0x110
"TIMER_SAT_SEND_MO_SM", 0x111
"TIMER_SAT_RESPONSE", 0x112
"PPP_TIMEOUT_TIMER", 0x113
"AT_COPS_MODE_4_TIMER", 0x114
"AT_CKPD_KEYSTROKE_TIMER", 0x115
"AT_CKPD_KEYPAUSE_TIMER", 0x116
"AT_APP_CALLBACK_TIMER", 0x117
"SAT_PLAYTONE_TIMER", 0x118
"SAT_TIMER_MANAGEMENT_1", 0x119
"SAT_TIMER_MANAGEMENT_2", 0x11A
"SAT_TIMER_MANAGEMENT_3", 0x11B
"SAT_TIMER_MANAGEMENT_4", 0x11C
"SAT_TIMER_MANAGEMENT_5", 0x11D
"SAT_TIMER_MANAGEMENT_6", 0x11E
"SAT_TIMER_MANAGEMENT_7", 0x11F
"SAT_TIMER_MANAGEMENT_8", 0x120
"SAT_EVENTLIST_TIMER", 0x121
"TIMER_SIM_RESPONSE_GUARD", 0x122
"TIMER_CC0", 0x123
"TIMER_CC1", 0x124
"TIMER_CC2", 0x125
"TIMER_CC3", 0x126
"TIMER_CC4", 0x127
"TIMER_CC5", 0x128
"TIMER_CC6", 0x129
"TIMER_336", 0x12A
"TIMER_337", 0x12B
"TIMER_IN_CALL_SS", 0x12C
"TIMER_CC_AOC", 0x12D
"AUTO_ANSWER_DELAY", 0x12E
"BATTERY_MEASURE_TIMER", 0x12F
"AUDIO_SERVICES_TIMER", 0x130
"TIMER_HZ_CBSMS", 0x131
"TIMER_NAS_TRAFFIC_TEST", 0x132
"TIMER_INIT_DELAY", 0x133
"MO_SMS_RETRY_TIMER", 0x134
"DP_TEST_TIMER", 0x135
"SIB7_MONITORING_TIMER", 0x136
"WAF_3GPP_DEACTIVATE_GUARD_TIMER", 0x137
"TIMER_PHYLLO", 0x138
"TIMER_DSM", 0x139
"TIMER_LCS_VERIFY", 0x13A
"PATRIOT_OS_TIMER", 0x13B
"PPP_AT_RESPONSE_TIMER", 0x13C
"PPP_LCP_PING_TIMEOUT", 0x13D
"PPP_RECEIVE_TIMEOUT", 0x13E
"PPP_IP_REASSEMBLY_TIMEOUT_TIMER", 0x13F
"RRP_LINK_PROBE_TIMER", 0x140
"RRP_DELAYED_ACK_TIMER", 0x141
"RRP_RETRANSMIT_TIMER", 0x142
"TIMER_ENQ", 0x143
"TIMER_WACK", 0x144
"RALP_BATT_LEVEL_TIMER", 0x145
"RALP_SIGNAL_LEVEL_TIMER", 0x146
"COMM_TIMEOUT_TIMER", 0x147
"LOGSERVER_GENERAL_TIMER", 0x148
"RALP_ENG_SCREEN_FAST_TIMER", 0x149
"RALP_ENG_SCREEN_TRACE_TIMER", 0x14A
"RALP_COMM_RETRY_TIMER", 0x14B
"AIRPLANE_MODE_TIMER", 0x14C
"SMS_BOOTUP_TIMER", 0x14D
"SMS_DELETE_TIMER", 0x14E
"INTERCONNECT_CALL_TIMER", 0x14F
"IDEN_TX_ICON_TIMER", 0x150
"IDEN_RX_ICON_TIMER", 0x151
"TX_RX_ICON_TIMER", 0x152
"BATTERY_INFO_TIMEOUT_TIMER", 0x153
"RADIO_PROTOTYPING_TIMER_9", 0x154
"RADIO_PROTOTYPING_TIMER_10", 0x155
"RADIO_PROTOTYPING_TIMER_11", 0x156
"RADIO_PROTOTYPING_TIMER_12", 0x157
"RADIO_PROTOTYPING_TIMER_13", 0x158
"RADIO_PROTOTYPING_TIMER_14", 0x159
"RADIO_PROTOTYPING_TIMER_15", 0x15A
"RADIO_PROTOTYPING_TIMER_16", 0x15B
"RADIO_PROTOTYPING_TIMER_17", 0x15C
"RADIO_PROTOTYPING_TIMER_18", 0x15D
"RADIO_PROTOTYPING_TIMER_19", 0x15E
"RADIO_PROTOTYPING_TIMER_20", 0x15F
"RADIO_PROTOTYPING_TIMER_21", 0x160
"RADIO_PROTOTYPING_TIMER_22", 0x161
"RADIO_PROTOTYPING_TIMER_23", 0x162
"RADIO_PROTOTYPING_TIMER_24", 0x163
"RADIO_PROTOTYPING_TIMER_25", 0x164
"RADIO_PROTOTYPING_TIMER_26", 0x165
"RADIO_PROTOTYPING_TIMER_27", 0x166
"RADIO_PROTOTYPING_TIMER_28", 0x167
"RADIO_PROTOTYPING_TIMER_29", 0x168
"RADIO_PROTOTYPING_TIMER_30", 0x169
"RADIO_PROTOTYPING_TIMER_31", 0x16A
"RADIO_PROTOTYPING_TIMER_32", 0x16B
"RADIO_PROTOTYPING_TIMER_33", 0x16C
"RADIO_PROTOTYPING_TIMER_34", 0x16D
"RADIO_PROTOTYPING_TIMER_35", 0x16E
"RADIO_PROTOTYPING_TIMER_36", 0x16F
"RADIO_PROTOTYPING_TIMER_37", 0x170
"RADIO_PROTOTYPING_TIMER_38", 0x171
"RADIO_PROTOTYPING_TIMER_39", 0x172
"RADIO_PROTOTYPING_TIMER_40", 0x173
"RADIO_PROTOTYPING_TIMER_41", 0x174
"RADIO_PROTOTYPING_TIMER_42", 0x175
"RADIO_PROTOTYPING_TIMER_43", 0x176
"RADIO_PROTOTYPING_TIMER_44", 0x177
"RADIO_PROTOTYPING_TIMER_45", 0x178
"RADIO_PROTOTYPING_TIMER_46", 0x179
"RADIO_PROTOTYPING_TIMER_47", 0x17A
"RADIO_PROTOTYPING_TIMER_48", 0x17B
"RADIO_PROTOTYPING_TIMER_49", 0x17C
"RADIO_PROTOTYPING_TIMER_50", 0x17D
"OSA_TIMER_1", 0x17E
"OSA_TIMER_2", 0x17F
"OSA_TIMER_3", 0x180
"OSA_TIMER_4", 0x181
"OSA_TIMER_5", 0x182
"OSA_TIMER_6", 0x183
"OSA_TIMER_7", 0x184
"OSA_TIMER_8", 0x185
"OSA_TIMER_9", 0x186
"OSA_TIMER_10", 0x187
"OSA_TIMER_11", 0x188
"OSA_TIMER_12", 0x189
"OSA_TIMER_13", 0x18A
"OSA_TIMER_14", 0x18B
"OSA_TIMER_15", 0x18C
"OSA_TIMER_16", 0x18D
"OSA_TIMER_17", 0x18E
"OSA_TIMER_18", 0x18F
"OSA_TIMER_19", 0x190
"OSA_TIMER_20", 0x191
"OSA_TIMER_21", 0x192
"OSA_TIMER_22", 0x193
"OSA_TIMER_23", 0x194
"OSA_TIMER_24", 0x195
"OSA_TASK_SLEEP", 0x196
"TIMER_WB_CAL", 0x197
"BLUETOOTH_TIMER_OS", 0x198
"BLUETOOTH_TIMER_UART_RESET", 0x199
"BLUETOOTH_TIMER_A2DP_AUDIO_TICK", 0x19A
"GPS_SERIAL_TIMER", 0x19B
"GPS_HIBERNATE_TIMER", 0x19C
"GPS_WAKEUP_TIMER", 0x19D
"GPS_TEST_TIMER_1", 0x19E
"GPS_TEST_TIMER_2", 0x19F
"GPS_TEST_TIMER_3", 0x1A0
"GPS_PERIODIC_FIX_TIMER", 0x1A1
"GPS_AIDING_REQUEST_TIMER", 0x1A2
"GPS_CHANNEL_BLOCK_TIMER_1", 0x1A3
"GPS_CHANNEL_BLOCK_TIMER_2", 0x1A4
"GPS_CHANNEL_BLOCK_TIMER_3", 0x1A5
"GPS_FREQ_AIDING_TIMER", 0x1A6
"GPS_RADIO_PDU_KEEP_AWAKE_TIMER", 0x1A7
"GPS_ADC_NVRAM_SAVE_TIMER", 0x1A8
"SERIAL_TEST_TIMER", 0x1A9
"SMARTCARD_OPEN_TIMER", 0x1AA
"CAMERA_FLASH_TIMER", 0x1AB
"BQMIGHTY_STATUS_DEBOUNCE_TIMER", 0x1AC
"BQMIGHTY_USBPG_DEBOUNCE_TIMER", 0x1AD
"BQMIGHTY_ACPG_DEBOUNCE_TIMER", 0x1AE
"BQHUGE_USBPG_DEBOUNCE_TIMER", 0x1AF
"BQHUGE_ACPG_DEBOUNCE_TIMER", 0x1B0
"BQHUGE_UTC_TICK", 0x1B1
"FIRST_IOTASK_TIMER", 0x1B2
"IO_TASK_TIMER_2", 0x1B3
"IO_TASK_TIMER_3", 0x1B4
"IO_TASK_TIMER_4", 0x1B5
"IO_TASK_TIMER_5", 0x1B6
"IO_TASK_TIMER_6", 0x1B7
"IO_TASK_TIMER_7", 0x1B8
"IO_TASK_TIMER_8", 0x1B9
"IO_TASK_TIMER_9", 0x1BA
"IO_TASK_TIMER_10", 0x1BB
"IO_TASK_TIMER_11", 0x1BC
"IO_TASK_TIMER_12", 0x1BD
"IO_TASK_TIMER_13", 0x1BE
"IO_TASK_TIMER_14", 0x1BF
"IO_TASK_TIMER_15", 0x1C0
"IO_TASK_TIMER_16", 0x1C1
"IO_TASK_TIMER_17", 0x1C2
"IO_TASK_TIMER_18", 0x1C3
"IO_TASK_TIMER_19", 0x1C4
"IO_TASK_TIMER_20", 0x1C5
"IO_TASK_TIMER_21", 0x1C6
"IO_TASK_TIMER_22", 0x1C7
"IO_TASK_TIMER_23", 0x1C8
"IO_TASK_TIMER_24", 0x1C9
"IO_TASK_TIMER_25", 0x1CA
"IO_TASK_TIMER_26", 0x1CB
"IO_TASK_TIMER_27", 0x1CC
"IO_TASK_TIMER_28", 0x1CD
"IO_TASK_TIMER_29", 0x1CE
"IO_TASK_TIMER_30", 0x1CF
"IO_TASK_TIMER_31", 0x1D0
"IO_TASK_TIMER_32", 0x1D1
"IO_TASK_TIMER_33", 0x1D2
"IO_TASK_TIMER_34", 0x1D3
"IO_TASK_TIMER_35", 0x1D4
"IO_TASK_TIMER_36", 0x1D5
"IO_TASK_TIMER_37", 0x1D6
"IO_TASK_TIMER_38", 0x1D7
"IO_TASK_TIMER_39", 0x1D8
"IO_TASK_TIMER_40", 0x1D9
"IO_TASK_TIMER_41", 0x1DA
"IO_TASK_TIMER_42", 0x1DB
"IO_TASK_TIMER_43", 0x1DC
"IO_TASK_TIMER_44", 0x1DD
"IO_TASK_TIMER_45", 0x1DE
"IO_TASK_TIMER_46", 0x1DF
"IO_TASK_TIMER_47", 0x1E0
"IO_TASK_TIMER_48", 0x1E1
"IO_TASK_TIMER_49", 0x1E2
"LAST_IOTASK_TIMER", 0x1E3
"TASKSLEEP_TIMER", 0x1E4
"RIM_SEMAPHORE_TIMER", 0x1E5
"OVERTEMPERATURE_TIMER", 0x1E6
"DVFM_NTIMER", 0x1E7
"WATCHDOG_TIMER", 0x1E8
"DUMMY_TIMER", 0x1E9
"CAMERA2_STATUS_MONITOR", 0x1EA
"CAMERA2_DARKNESS_CHK", 0x1EB
"CAMERA2_ESD_CHK", 0x1EC
"CAMERA2_MV9319_ISP_STATUS_MONITOR", 0x1ED
"CAMERA2_MV9319_ISP_CLK_VERIFY", 0x1EE
"CAMERA2_MV9319_ISP_AF_COMPLETE_CHK", 0x1EF
"CAMERA2_MV9319_ISP_DARKNESS_CHK", 0x1F0
"CAMERA2_MV9319_ISP_ESD_CHK", 0x1F1
"RNG_MIX_TIMER", 0x1F2
"USER_DEFINED_TEST_TIMER", 0x1F6
"SYSPROF_NATIVE_IP_TIMER", 0x1F7
"DYNAMIC_TIMER_1", 0x1F8
"DYNAMIC_TIMER_2", 0x1F9
"DYNAMIC_TIMER_3", 0x1FA
"DYNAMIC_TIMER_4", 0x1FB
"DYNAMIC_TIMER_5", 0x1FC
"DYNAMIC_TIMER_6", 0x1FD
"DYNAMIC_TIMER_7", 0x1FE
"DYNAMIC_TIMER_8", 0x1FF
"DYNAMIC_TIMER_9", 0x200
"DYNAMIC_TIMER_10", 0x201
"DYNAMIC_TIMER_11", 0x202
"DYNAMIC_TIMER_12", 0x203
"DYNAMIC_TIMER_13", 0x204
"DYNAMIC_TIMER_14", 0x205
"DYNAMIC_TIMER_15", 0x206
"DYNAMIC_TIMER_16", 0x207
"DYNAMIC_TIMER_17", 0x208
"DYNAMIC_TIMER_18", 0x209
"DYNAMIC_TIMER_19", 0x20A
"DYNAMIC_TIMER_20", 0x20B
"DYNAMIC_TIMER_21", 0x20C
"DYNAMIC_TIMER_22", 0x20D
"DYNAMIC_TIMER_23", 0x20E
"DYNAMIC_TIMER_24", 0x20F
"DYNAMIC_TIMER_25", 0x210
"DYNAMIC_TIMER_26", 0x211
"DYNAMIC_TIMER_27", 0x212
"DYNAMIC_TIMER_28", 0x213
"DYNAMIC_TIMER_29", 0x214
"DYNAMIC_TIMER_30", 0x215
"DYNAMIC_TIMER_31", 0x216
"DYNAMIC_TIMER_32", 0x217
"DYNAMIC_TIMER_33", 0x218
"DYNAMIC_TIMER_34", 0x219
"DYNAMIC_TIMER_35", 0x21A
"DYNAMIC_TIMER_36", 0x21B
"DYNAMIC_TIMER_37", 0x21C
"DYNAMIC_TIMER_38", 0x21D
"DYNAMIC_TIMER_39", 0x21E
"DYNAMIC_TIMER_40", 0x21F
"DYNAMIC_TIMER_41", 0x220
"DYNAMIC_TIMER_42", 0x221
"DYNAMIC_TIMER_43", 0x222
"DYNAMIC_TIMER_44", 0x223
"DYNAMIC_TIMER_45", 0x224
"DYNAMIC_TIMER_46", 0x225
"DYNAMIC_TIMER_47", 0x226
"DYNAMIC_TIMER_48", 0x227
"TIMER_L1CTL", 0x228
"SERMUX_TIMEOUT_TIMER", 0x229
"BUGMON_TIMER", 0x22A
"I2C_TIMEOUT_TIMER", 0x22B
"RIM_OMX_TIMER_0", 0x22C
"FREQ_CHANGE_TIMER", 0x22D
"GPS_EE_REQUEST_TIMER", 0x22E
"MN_DELAYED_MESSAGE_TIMER", 0x22F
"NEW_SEMAPHORE_TIMER", 0x230
"FIRST_OUTPUTSYS_TASK_TIMER", 0x231
"OUTPUTSYS_TASK_TIMER_2", 0x232
"OUTPUTSYS_TASK_TIMER_3", 0x233
"OUTPUTSYS_TASK_TIMER_4", 0x234
"OUTPUTSYS_TASK_TIMER_5", 0x235
"OUTPUTSYS_TASK_TIMER_6", 0x236
"OUTPUTSYS_TASK_TIMER_7", 0x237
"OUTPUTSYS_TASK_TIMER_8", 0x238
"OUTPUTSYS_TASK_TIMER_9", 0x239
"OUTPUTSYS_TASK_TIMER_10", 0x23A
"OUTPUTSYS_TASK_TIMER_11", 0x23B
"LAST_OUTPUTSYS_TASK_TIMER", 0x23C
"IPP_OSAPI_MTX_WAIT_TIMER", 0x23D
"IPP_OSAPI_DMA_WAIT_TIMER", 0x23E
"IPP_OSAPI_DEBLOCK_WAIT_TIMER", 0x23F
"IPP_OSAPI_MC_WAIT_TIMER", 0x240
"ICMP_ERROR_TOKEN_BUCKET_TIMER", 0x241
"TIMER_CC_TONE", 0x242
"SIMCARD_RECOVERY_BACKOFF_TIMER", 0x243
"SIMCARD_FORCE_RETRY_TIMER", 0x244
"TIMER_GAN_CSR_HANDOVER_RETRY", 0x245
"TIMER_GAN_WAIT_FOR_USER", 0x246
"ORPHEUS_CHANNEL_SCAN_DELAY_TIMER", 0x247
"IPC_SIGNAL_RATE_TIMER", 0x248
"LATTE_STATIC_TIMER", 0x24A
"TIMER_GETMESSAGE_TIMEOUT", 0x24B
"GPS_LOCATION_AIDING_REQUEST_TIMER", 0x24C
"NUMBER_OF_NTIMERS", 0x24D
END ENUM "TimerName"

BEGIN ENUM "VersionType"
"NO_VERSION_TYPE", 0x0
"OS_API_VERSION_TYPE", 0x1
"BLOCKFS_VERSION_TYPE", 0x2
"FAT_VERSION_TYPE", 0x3
"STP_PROTOCOL_VERSION_TYPE", 0x4
"USB_DRIVER_VERSION_TYPE", 0x5
"WLAN_VERSION_TYPE", 0x6
"BLOCKMAP_VERSION_TYPE", 0x7
"BUGDISP_KEY_VERSION_TYPE", 0x8
"STP_KEY_VERSION_TYPE", 0x9
"NVSIG_KEY_VERSION_TYPE", 0xA
"MAX_VERSION_TYPE", 0xB
END ENUM "VersionType"

BEGIN ENUM "CommonSTPCommandStatusBMSK"
"WP_VERIFY_STATUS_BMSK", 0x1
"JTAG_VERIFY_STATUS_BMSK", 0x2
END ENUM "CommonSTPCommandStatusBMSK"

BEGIN ENUM "USB_FEATURE"
"USB_BLACKBERRY", 0x0
"USB_VIRTUAL_SERIAL_PORT", 0x1
"USB_MASS_STORAGE", 0x2
END ENUM "USB_FEATURE"

BEGIN ENUM "ProfileBlock_e"
"OSPROF_NVRAM_EMPTY_CODEBLOCK", 0x0
"FLASH_WRITE_PROFILE", 0x1
"FLASH_ERASE_PROFILE", 0x2
"FLASH_READ_PROFILE", 0x3
"GNHP_BLK_MALLOC", 0x4
"GNHP_BLK_REALLOC", 0x5
"GNHP_BLK_FREE", 0x6
"GNHP_BLK_ACQUIREOWNERSHIP", 0x7
"GNHP_BLK_RELINQUISHOWNERSHIP", 0x8
"GNHP_BLK_POINTERFROMHANDLE", 0x9
"NAND_WRITE_PROFILE", 0xA
"NAND_ERASE_PROFILE", 0xB
"NAND_READ_PROFILE", 0xC
"SDCARD_WRITE_SPEED_PROFILE", 0xD
"SDCARD_READ_SPEED_PROFILE", 0xE
"OSPROF_ALL_CODEBLOCKS", 0xF
END ENUM "ProfileBlock_e"

BEGIN ENUM "USBChannelState"
"USB_DEAD", 0x0
"USB_ESTABLISH", 0x1
"USB_ESTABLISH2", 0x2
"USB_AUTHENTICATE", 0x3
"USB_AUTHENTICATE_NO_UI", 0x4
"USB_OPEN", 0x5
"USB_TERMINATE", 0x6
END ENUM "USBChannelState"

BEGIN ENUM "LcdMaxTrafficPatterns"
"LCD_MAX_TRAFFIC_OFF", 0x0
"LCD_MAX_TRAFFIC_STATUS", 0x1
"LCD_MAX_TRAFFIC_CHECKERBOARD", 0x2
END ENUM "LcdMaxTrafficPatterns"

BEGIN ENUM "BlockAlignment_e"
"BLOCK_ALIGN_DEFAULT", 0x0
"BLOCK_ALIGN_4", 0x4
"BLOCK_ALIGN_8", 0x8
"BLOCK_ALIGN_16", 0x10
"BLOCK_ALIGN_32", 0x20
"BLOCK_ALIGN_64", 0x40
"BLOCK_ALIGN_128", 0x80
"BLOCK_ALIGN_256", 0x100
END ENUM "BlockAlignment_e"

BEGIN ENUM "SDMMCPartitionType"
"SDMMC_USER_PARTITION", 0x0
"MMC_BOOT_PARTITION0", 0x1
"MMC_BOOT_PARTITION1", 0x2
"NUM_MMC_BOOT_PARTITIONS", 0x3
END ENUM "SDMMCPartitionType"

BEGIN ENUM "FS_TYPE"
"FS_TYPE_PATRIOT", 0x0
"FS_TYPE_SDCARD", 0x1
"FS_TYPE_BUILT_IN", 0x2
"FS_TYPE_INTERNAL_FLASH", 0x3
"FS_TYPE_BUILT_IN_SECONDARY", 0x4
"FS_TYPE_RAMDISK", 0x5
"NUM_FS_TYPES", 0x6
END ENUM "FS_TYPE"

BEGIN ENUM "DEVICE_SOFTWARE_CAPABILITY"
"SW_CAP_POSIX_FS", 0x0
"SW_CAP_STREAMING", 0x1
"SW_CAP_AUDIO_STREAMING", 0x2
"SW_CAP_BLOCK_ERASE_ASYNC", 0x3
"SW_CAP_NO_KEY_TONE", 0x4
"SW_CAP_MASTER_VOLUME_API", 0x5
"SW_CAP_MIDI", 0x6
"SW_CAP_VIDEO_STREAMING", 0x7
"SW_CAP_MEDIA_PLAYER", 0x8
"SW_CAP_USB_MASS_STORAGE", 0x9
"SW_CAP_PERFMON", 0xA
"SW_CAP_VAD", 0xB
"SW_CAP_RECORDING", 0xC
"SW_CAP_RTSP", 0xD
"SW_CAP_MULTIBUTTON_HEADSET", 0xE
"SW_CAP_NAND_BLOCK_FS", 0xF
"SW_CAP_DISPLAY_ROTATION", 0x10
"SW_CAP_MEID", 0x11
"SW_CAP_OPEN_VG", 0x12
"SW_CAP_DRM", 0x13
"SW_CAP_USB_MTP", 0x14
"SW_CAP_PTX", 0x15
"SW_CAP_TTS", 0x16
"SW_CAP_STARTUP_SCREEN", 0x17
"SW_CAP_CAMERA_RESUME_ON_CAPTURE", 0x18
"SW_CAP_OPENGLES", 0x19
"SW_CAP_WORKERTASK", 0x1A
"SW_CAP_ASSD", 0x1B
"SW_CAP_MUTEX", 0x1C
"SW_CAP_CMPTT_SW", 0x1D
"SW_CAP_RTN", 0x1E
"SW_CAP_SDCARD_RAMDUMP", 0x1F
"SW_CAP_NUM_ENTRIES", 0x20
END ENUM "DEVICE_SOFTWARE_CAPABILITY"

BEGIN ENUM "PowerSavingModeType"
"PARTIAL_DISPLAY_MODE", 0x0
"PARTIAL_COLOUR_MODE", 0x1
"LCD_SLEEP_MODE", 0x2
END ENUM "PowerSavingModeType"

BEGIN ENUM "BLOCK_REASON"
"BLOCK_REASON_NONE", 0x0
"BLOCK_REASON_PAGE_FAULT", 0x1
"BLOCK_REASON_INST_BOUNCE", 0x2
"BLOCK_REASON_BREAKPOINT", 0x3
END ENUM "BLOCK_REASON"

BEGIN ENUM "ThemeableImageId"
"HOURGLASS_IMAGE_ID", 0x0
"TX_ICON_IMAGE_ID", 0x1
"RX_ICON_IMAGE_ID", 0x2
"TXRX_ICON_IMAGE_ID", 0x3
"NUM_ICON_IMAGE_ID", 0x4
"ALT_ICON_IMAGE_ID", 0x5
"CAP_ICON_IMAGE_ID", 0x6
"TX_RACH_ICON_IMAGE_ID", 0x7
"CUSTOM_ICON_IMAGE_ID", 0x8
"NUM_THEMEABLE_IMAGES", 0x9
"ALL_IMAGES_ID", 0x80
"DEFAULT_IMAGE_ID", 0x81
END ENUM "ThemeableImageId"

BEGIN ENUM "MemoryTestStatus"
"MEMORYTEST_SUCCESS", 0x0
"RAMCONFIGURE_FAIL", 0x1
"RAMTEST_JVMSTATUS_SET", 0x2
"RAMTEST_RAM_IS_BAD", 0x3
"FLASHTEST_FAIL", 0x4
"FLASHTEST_ID_NOT_READY", 0x5
"FLASHTEST_UNAVAILABLE_ID", 0x6
"MEMORYTEST_ILLEGAL_PARAM", 0x7
"FLASHCONFIGURE_FAIL", 0x8
"SDCARDTEST_FAIL_TO_OPEN", 0x9
"SDCARDTEST_WRITE_FAIL", 0xA
"SDCARDTEST_READ_FAIL", 0xB
"SDCARDTEST_VERIFY_FAIL", 0xC
"SDCARDTEST_ERASE_FAIL", 0xD
"MEMORYTEST_INSUFFICIENT_MEM", 0xE
"MEMORYTEST_BAD_WIDTH", 0xF
"FLASHTEST_SPANSION_READ_FAIL", 0x10
"FLASHTEST_SPANSION_READ_PASS", 0x11
"FLASHTEST_SPANSION_RUNNING", 0x12
"FLASHTEST_SPANSION_STOPPED", 0x13
"SDCARDTEST_FORMAT_FAIL", 0x14
"SDCARDTEST_ALREADY_OPENED", 0x15
"SDCARDTEST_CONNECTION_FAIL", 0x16
END ENUM "MemoryTestStatus"

BEGIN ENUM "PadUseRdh"
"USE_RDH_DEFAULT", 0x0
"USE_RDH_ENABLE", 0x1
"USE_RDH_DISABLE", 0x2
END ENUM "PadUseRdh"

BEGIN ENUM "GenericHeapName_e"
"HEAP_NAME_NO_NAME", 0x0
"HEAP_NAME_SYSTEM_HEAP", 0x1
"HEAP_NAME_KERNEL_HEAP", 0x2
"HEAP_NAME_DATAQUEUE_HEAP", 0x3
"HEAP_NAME_SYSTEM_MC_HEAP", 0x4
"HEAP_NAME_GROUP_WAF_BUFFER_START", 0x100
"HEAP_NAME_GROUP_WAF_BUFFER_END", 0x1FF
END ENUM "GenericHeapName_e"

BEGIN ENUM "IconType"
"KEYSTAT", 0x0
"RADIOSTAT", 0x1
"NUM_ICON_TYPES", 0x2
END ENUM "IconType"

BEGIN ENUM "OnDemandLdrStatus"
"ON_DEMAND_READ_ERROR", 0xFFFFFFFC
"ON_DEMAND_NOT_ENOUGH_MEM", 0xFFFFFFFD
"ON_DEMAND_NOT_FOUND", 0xFFFFFFFE
"ON_DEMAND_COMPRESSION_ERROR", 0xFFFFFFFF
"ON_DEMAND_OK", 0x0
END ENUM "OnDemandLdrStatus"

BEGIN ENUM "SupportedFeatureList"
"CAL_NVRAM_ITEM_EMPTY", 0x0
"BRANDING_FILE_CHUNK_ACCESS", 0x1
"EXT_CAL_TEST_STATUS", 0x2
"EXT_AUDIO_CAL_TABLES", 0x3
"NUM_SUPPORTED_FEATURES", 0x4
END ENUM "SupportedFeatureList"

BEGIN ENUM "ProfileReturnCode_e"
"OSPROF_SUCCESS", 0x0
"OSPROF_ERROR_NAME_TOO_LONG", 0x1
"OSPROF_ERROR_EMPTY_NAME", 0x2
"OSPROF_ERROR_ALREADY_EXIST", 0x3
"OSPROF_ERROR_EXCEEDED_LIMIT", 0x4
"OSPROF_ERROR_ALREADY_ENABLED", 0x5
"OSPROF_ERROR_CODEBLOCK_NOT_FOUND", 0x6
"OSPROF_ERROR_PROFILING_NOT_INIT", 0x7
"OSPROF_ERROR_ALLOCATE_MEMORY", 0x8
"OSPROF_ERROR_EMPTY", 0x9
"OSPROF_ERROR_CODEBLOCK_RESET", 0xA
"OSPROF_ERROR_MEMORY_DEALLOCATE", 0xB
"OSPROF_ERROR_NOT_ENABLED", 0xC
"OSPROF_ERROR_CODEBLOCK_INVALID", 0xD
END ENUM "ProfileReturnCode_e"

BEGIN ENUM "EP_DIR"
"EP_OUT", 0x0
"EP_IN", 0x1
"NUM_DIR", 0x2
END ENUM "EP_DIR"

BEGIN ENUM "CustomInfoID"
"RADIO_FEATURES", 0x0
"NETWORK_NAME_OVERRIDE", 0x1
END ENUM "CustomInfoID"

BEGIN ENUM "PadLatchState"
"PAD_LATCH_FALLING_EDGE", 0x0
"PAD_LATCH_RISING_EDGE", 0x1
"PAD_LATCH_NONE", 0x2
END ENUM "PadLatchState"

BEGIN ENUM "JVM_STATE"
"JVM_STATE_BOOTING", 0x0
"JVM_STATE_JVMERROR", 0x1
"JVM_STATE_DOING_FAST_RESET", 0x2
"JVM_STATE_DOING_FULL_RESET", 0x3
"JVM_STATE_NUM_ENTRIES", 0x4
END ENUM "JVM_STATE"

BEGIN ENUM "_FILE_OPERATION_TYPE"
"FILE_OPERATION_GET_FS_INFO", 0x0
"FILE_OPERATION_OPEN", 0x1
"FILE_OPERATION_CLOSE", 0x2
"FILE_OPERATION_WRITE", 0x3
"FILE_OPERATION_READ", 0x4
"FILE_OPERATION_RENAME", 0x5
"FILE_OPERATION_DELETE", 0x6
"FILE_OPERATION_FILE_FIND_FIRST", 0x7
"FILE_OPERATION_FILE_FIND_NEXT", 0x8
"FILE_OPERATION_FILE_SEEK", 0x9
"FILE_OPERATION_FILE_LOCK", 0xA
"FILE_OPERATION_MK_DIR", 0xB
"FILE_OPERATION_RM_DIR", 0xC
"FILE_OPERATION_CHECK_EOF", 0xD
"FILE_OPERATION_SET_ATTRIB", 0xE
"FILE_OPERATION_COMMIT", 0xF
END ENUM "_FILE_OPERATION_TYPE"

BEGIN ENUM "DelayTypes"
"NO_DELAY", 0x5
"BUFFER", 0x6
"BUFFER_1CELL", 0x7
"BUFFER_2CELL", 0x0
"BUFFER_3CELL", 0x1
"BUFFER_4CELL", 0x2
"BUFFER_4CELL_1PROG", 0x3
"BUFFER_4CELL_2PROG", 0x4
END ENUM "DelayTypes"

BEGIN ENUM "RegId"
"NANDFLASH_FP", 0x0
"NUM_IDS", 0x1
END ENUM "RegId"

BEGIN ENUM "PmProfileRatio"
"PM_LCD_RATIO", 0x0
"PM_L1_RATIO", 0x1
"PM_L2_RATIO", 0x2
"PM_POTENTIAL_L2_RATIO", 0x3
"PM_AUDIO_RATIO", 0x4
"PM_GPS_RATIO", 0x5
"PM_WIFI_RATIO", 0x6
"PM_DSP_L2_RATIO", 0x7
"PM_FREQ_APPS_1", 0x8
"PM_FREQ_APPS_2", 0x9
"PM_CLK13M_REQ_RATIO", 0xA
"PM_WIFI_ACTIVE_RATIO", 0xB
"PM_DSP_L1_RATIO", 0xC
"PM_FREQ_DSP_1", 0xD
"PM_FREQ_DSP_2", 0xE
"PM_NUM_RATIOS", 0xF
END ENUM "PmProfileRatio"

BEGIN ENUM "STPGenericNvRamCommand"
"READ_DATA", 0x0
"WRITE_DATA", 0x1
"GET_DATA_SIZE", 0x2
END ENUM "STPGenericNvRamCommand"

BEGIN ENUM "RimFlashTrchAdcRange"
"FLASH_LED_ADC_UNDER_3200", 0x0
"FLASH_LED_ADC_3200_TO_3350", 0x1
"FLASH_LED_ADC_3350_TO_3500", 0x2
"FLASH_LED_ADC_3500_TO_3650", 0x3
"FLASH_LED_ADC_3650_TO_3800", 0x4
"FLASH_LED_ADC_3800_TO_3950", 0x5
"FLASH_LED_ADC_3950_TO_4100", 0x6
"FLASH_LED_ADC_OVER_4100", 0x7
END ENUM "RimFlashTrchAdcRange"

BEGIN ENUM "TimerType"
"NTIMERS_TIMER", 0x0
"JVM_TIMESLICE_TIMER", 0x1
"EARLY_WATCHDOG_TIMER", 0x2
"SLOWCLOCKING_WAKEUP_TIMER", 0x3
"NUM_TIMERS", 0x4
END ENUM "TimerType"

BEGIN ENUM "KernelType"
"KERNELTYPE_SEMAPHORE", 0x0
"KERNELTYPE_MUTEX", 0x1
"KERNELTYPE_TLS", 0x2
"NUM_KERNEL_TYPES", 0x3
END ENUM "KernelType"

BEGIN ENUM "SerialMode"
"STP_MODE", 0x0
"ECHO_MODE", 0x1
END ENUM "SerialMode"

BEGIN ENUM "ResetType"
"RESET_TYPE_UNKNOWN", 0x0
"RESET_TYPE_SOFT", 0x1
"RESET_TYPE_HARD", 0x2
END ENUM "ResetType"

BEGIN ENUM "NvRequestResult"
"nvSigReqSuccess", 0x0
"nvSigReqFailed", 0x1
"nvSigReqNvTooBig", 0x2
"nvSigReqNvNotExist", 0x3
"nvSigReqUnknown", 0xFFFF
END ENUM "NvRequestResult"

BEGIN ENUM "PadSleepSel"
"SLEEP_SEL_DEFAULT", 0x0
"SLEEP_SEL_APPS", 0x1
"SLEEP_SEL_COMMS", 0x2
END ENUM "PadSleepSel"

BEGIN ENUM "MetricsType"
"BOOTROM_METRICS", 0x0
"OS_METRICS", 0x1
"OS_KERNEL_METRICS", 0x2
"DSPOS_METRICS", 0x3
"DSPOS_KERNEL_METRICS", 0x4
"APP_METRICS", 0x5
END ENUM "MetricsType"

BEGIN ENUM "CoreFrequence"
"CORE_CLK_NONE", 0x0
"CORE_CLK_34MHZ", 0x206CC80
"CORE_CLK_52MHZ", 0x3197500
"CORE_CLK_60MHZ", 0x3938700
"CORE_CLK_69MHZ", 0x41CDB40
"CORE_CLK_104MHZ", 0x632EA00
"CORE_CLK_156MHZ", 0x94C5F00
"CORE_CLK_208MHZ", 0xC65D400
"CORE_CLK_250MHZ", 0xEE6B280
"CORE_CLK_312MHZ", 0x1298BE00
"CORE_CLK_385_5MHZ", 0x16FA4360
"CORE_CLK_399MHZ", 0x17C841C0
"CORE_CLK_416MHZ", 0x18CBA800
"CORE_CLK_514MHZ", 0x1EA30480
"CORE_CLK_532MHZ", 0x1FB5AD00
"CORE_CLK_624MHZ", 0x25317C00
END ENUM "CoreFrequence"

BEGIN ENUM "NvStatus"
"NVRAM_OK", 0x0
"NVRAM_BAD", 0x1
"NVRAM_WRITE_FAILED", 0x2
"NVRAM_READ_FAILED", 0x3
"NVRAM_REC_NOT_FOUND", 0x4
"NVRAM_DATA_CORRUPT", 0x5
"NVRAM_FULL", 0x6
"NVRAM_NOT_PRESENT", 0x7
"NVSTATUS_LAST", 0x8
"NVRAM_DEFAULT_CAL", 0x9
END ENUM "NvStatus"

BEGIN ENUM "NvramPersistentBitFlag"
"NVRAM_PERSISTENT_BITFLAGS_EDW_WIPE_MEMORY", 0x0
"NVRAM_PERSISTENT_BITFLAGS_REFURBISHED", 0x1
"NVRAM_BITFLAGS_FORCE_STP_NO_RTAS_MFI", 0x2
"NVRAM_BITFLAGS_FORCE_STP_NO_RTAS_MFI_USED", 0x3
END ENUM "NvramPersistentBitFlag"

BEGIN ENUM "BlockAllocScheme_e"
"ALLOC_SCHEME_DEFAULT", 0x0
"ALLOC_SCHEME_MULTI_SIZE_BUCKETS", 0x1
"ALLOC_SCHEME_HYBRID_BUDDY_BLOCK", 0x2
END ENUM "BlockAllocScheme_e"

BEGIN ENUM "CalTestType"
"BOARD_LEVEL_CAL", 0x0
"FINAL_TEST", 0x1
"FUNCTIONAL_TEST", 0x2
"DEVICE_CONFIG", 0x3
"IDEN_CRYSTAL_SCAN", 0x4
END ENUM "CalTestType"

BEGIN ENUM "PeripheralClock"
"CLOCK_USB", 0x0
"CLOCK_I2C", 0x1
"CLOCK_LCD", 0x2
"CLOCK_USIM0", 0x3
"CLOCK_USIM1", 0x4
"CLOCK_CAMERA", 0x5
"CLOCK_MMC0", 0x6
"CLOCK_MMC1", 0x7
"CLOCK_KEYPAD", 0x8
"CLOCK_UART1", 0x9
"CLOCK_UART2", 0xA
"CLOCK_UART3", 0xB
"CLOCK_SSP1", 0xC
"CLOCK_SSP2", 0xD
"CLOCK_SSP3", 0xE
"CLOCK_SSP4", 0xF
"CLOCK_MSL", 0x10
"CLOCK_ROLLER", 0x11
"CLOCK_FAKE", 0x12
"CLOCK_GPS", 0x13
"CLOCK_GRAPHICS", 0x14
"CLOCK_ANTIOCH", 0x15
"CLOCK_CADDO", 0x16
"CLOCK_NAND", 0x17
"CLOCK_ABC", 0x18
"CLOCK_VBROM", 0x19
"CLOCK_TVOUT", 0x1A
"CLOCK_MVED", 0x1B
"CLOCK_MMC2", 0x1C
"NUM_PERIPHERALS", 0x1D
END ENUM "PeripheralClock"

BEGIN ENUM "PSR_Mode"
"USER_MODE", 0x10
"FIQ_MODE", 0x11
"IRQ_MODE", 0x12
"SVC_MODE", 0x13
"ABORT_MODE", 0x17
"UNDEF_MODE", 0x1B
"SYSTEM_MODE", 0x1F
END ENUM "PSR_Mode"

BEGIN ENUM "groupid"
"GROUP_SYSTEM", 0xDEE
"GROUP_OS_INTERNAL", 0xFE4
"GROUP_OS_API", 0xF88
"GROUP_HW_IO", 0x88F
"GROUP_SERIAL", 0xFFF
"GROUP_DEBUGGER", 0xFAF
"GROUP_MUSIC", 0xA7D
"GROUP_AUDIOHW", 0x6F
"GROUP_DSP", 0x90
"GROUP_IPC", 0x3CC
"GROUP_APP_INTERFACE", 0xF65
"GROUP_STREAMING", 0x1AB
"GROUP_FLASH", 0x584
"GROUP_USB", 0x80F
"GROUP_POWER", 0xFA2
"GROUP_LCDBKLGT", 0x2FE
"GROUP_VIDEO", 0x9A
"GROUP_OMX", 0x9F
"GROUP_MEDIA", 0xA62
"GROUP_MFG", 0xC28
"GROUP_VAD", 0x7D
"GROUP_GPS", 0xFB
"GROUP_CAMERA", 0x4FC
"GROUP_BLUETOOTH", 0xEE0
"GROUP_TASKS", 0x9EF
"GROUP_FPS", 0xABF
"GROUP_SMARTCARD", 0xF77
"GROUP_HEAP", 0x39F
"GROUP_GRAPHICS", 0x8F1
"GROUP_QUINCY", 0xA2F
"GROUP_INPUT", 0xF74
END ENUM "groupid"

BEGIN ENUM "groupmappings"
"GROUP_OS_INTERNAL_MAP", 0x1
"GROUP_OS_API_MAP", 0x1
"GROUP_SYSTEM_MAP", 0x1
"GROUP_SERIAL_MAP", 0x1
"GROUP_HW_IO_MAP", 0x1
"GROUP_MUSIC_MAP", 0x3
"GROUP_GPS_MAP", 0x1
"GROUP_BLUETOOTH_MAP", 0x1
"GROUP_APP_INTERFACE_MAP", 0x1
"GROUP_DEBUGGER_MAP", 0x1
"GROUP_MFG_MAP", 0x1
"GROUP_USB_MAP", 0x1
"GROUP_FLASH_MAP", 0x1
"GROUP_LCDBKLGT_MAP", 0x1
"GROUP_POWER_MAP", 0x1
"GROUP_FPS_MAP", 0x1
"GROUP_HEAP_MAP", 0x1
"GROUP_SMARTCARD_MAP", 0x1
"SUPERGROUP_MULTIMEDIA_MAP", 0x1
"GROUP_QUINCY_MAP", 0x1
"GROUP_INPUT_MAP", 0x1
"GROUP_VIDEO_MAP", 0x3
"GROUP_MEDIA_MAP", 0x3
"GROUP_CAMERA_MAP", 0x3
"GROUP_VAD_MAP", 0x3
"GROUP_STREAMING_MAP", 0x3
"GROUP_TASKS_MAP", 0x2
END ENUM "groupmappings"

BEGIN ENUM "fileid"
"FILE_CATFAIL", 0x1
"FILE_CATFAIL_UI", 0x2
"FILE_PROC_UTC", 0x30
"FILE_RADIODEBUGTASK", 0x31
"FILE_INIT", 0x32
"FILE_DVFM", 0x33
"FILE_COMMS_GPIO", 0x34
"FILE_DEBUG", 0x35
"FILE_IPC", 0x36
"FILE_THREAD", 0x37
"FILE_CLOCKS_IPC", 0x38
"FILE_PROC_INTCTRL", 0x39
"FILE_COMMON_STUBS", 0x3A
"FILE_TAVOR_DDRCTRL", 0x3B
"FILE_FLAGS", 0x3C
"FILE_ENTRYPOINT", 0x3D
"FILE_CRITICAL", 0x3E
"FILE_ARGONLV_SPBA", 0x3F
"FILE_ARM7_HANDLER", 0x40
"FILE_BF_HANDLER", 0x41
"FILE_PROC_TIMER", 0x42
"FILE_OSINITTASK", 0x43
"FILE_ABC", 0x44
"FILE_RTC", 0x45
"FILE_AUDIODEBUGTASK", 0x46
"FILE_TAVOR_GB_TIMER", 0x47
"FILE_JVMTIMESLICE", 0x48
"FILE_KEYPAD", 0x49
"FILE_LDO", 0x4A
"FILE_TAVORPV2_COMM_TIMERS", 0x4B
"FILE_KERNELHEAP", 0x4C
"FILE_ALERT", 0x4D
"FILE_SEMAPHORE", 0x4E
"FILE_WATCHDOGTASK", 0x4F
"FILE_IOTASK", 0x50
"FILE_MUTEX", 0x51
"FILE_POWER", 0x52
"FILE_HWME", 0x53
"FILE_PROC_CLOCKS", 0x54
"FILE_SRV_THREAD", 0x55
"FILE_DATAQUEUE", 0x56
"FILE_UNIT_TEST", 0x57
"FILE_UTC", 0x58
"FILE_CALTASK", 0x59
"FILE_APPTASK", 0x5A
"FILE_SMARTCARD", 0x5B
"FILE_PROC_SERIAL_TEST", 0x5C
"FILE_PROC_SERIAL", 0x5D
"FILE_PROFILE", 0x5E
"FILE_PROC_CBSERIAL", 0x5F
"FILE_DSP_FREQCHANGE", 0x60
"FILE_RADIO_FREQCHANGE", 0x61
"FILE_SLEEPCYCLE", 0x62
"FILE_FREQCHANGE", 0x63
"FILE_BUGDISPXCMDS", 0x64
"FILE_FREQCHANGE_COMMON", 0x65
"FILE_NOBATT_ADC", 0x66
"FILE_LED", 0x67
"FILE_HNB0_INTERPROCESSOR", 0x68
"FILE_MAX8856", 0x69
"FILE_IDLETASK", 0x6A
"FILE_PROC_SLOWCLOCK_ARM", 0x6B
"FILE_PROC_SLOWCLOCK", 0x6C
"FILE_BQTINY_SWITCHER", 0x6D
"FILE_BQTINY", 0x6E
"FILE_APP", 0x6F
"FILE_PROC_SYSPLL", 0x71
"FILE_DEVICEINFO", 0x72
"FILE_AUDIO_AUX", 0x73
"FILE_AUDIOTASK", 0x74
"FILE_TEST_COMMS_PERIPH", 0x75
"FILE_PROC_MISC", 0x76
"FILE_GSPSERIAL", 0x77
"FILE_VOCODERTHREAD", 0x78
"FILE_PROC_I2C", 0x79
"FILE_MIXERDSP", 0x7A
"FILE_HNB0_IRAM", 0x7B
"FILE_PROC_PLL", 0x7C
"FILE_LIGHTSENSOR_OS", 0x7D
"FILE_PM7540", 0x7E
"FILE_ARM9_MISC", 0x7F
"FILE_COREMISC_ARM7", 0x80
"FILE_COREMISC_BF", 0x81
"FILE_HUGE_INT", 0x82
"FILE_HUGE_PMIC", 0x83
"FILE_A2DPTHREAD", 0x84
"FILE_MIGHTY_PMIC", 0x85
"FILE_PMIC_TASK", 0x86
"FILE_BLUETOOTH", 0x87
"FILE_BLUETOOTHTHREAD", 0x88
"FILE_PROC_BTSERIAL", 0x89
"FILE_CLOCKS", 0x8A
"FILE_ADCSCHEDTASK", 0x8B
"FILE_PMUTIL", 0x8C
"FILE_TAVOR_PWRCNSMP", 0x8D
"FILE_PMIC", 0x8E
"FILE_TPS62356", 0x8F
"FILE_PERFMON", 0x90
"FILE_PROC_DEBUG", 0x91
"FILE_HNB0_PERFMON", 0x92
"FILE_PROC_KEYPAD", 0x93
"FILE_HARBELL_PERFMON", 0x94
"FILE_DIRECTKEY", 0x95
"FILE_DEADLOCK", 0x96
"FILE_ARGONLV_PERFMON", 0x97
"FILE_HNB0_SSP", 0x98
"FILE_LARGEMSG", 0x99
"FILE_HUGE_CHRG", 0x9A
"FILE_MIGHTY_CHRG", 0x9B
"FILE_TLS", 0x9C
"FILE_SRV_MESSAGE", 0x9D
"FILE_MIGHTY_INT", 0x9E
"FILE_NOBATT_INT", 0x9F
"FILE_PROC_RTC", 0xA0
"FILE_TAVOR_MSL", 0xA1
"FILE_PMJET_PMIC", 0xA2
"FILE_PMJET_CHRG", 0xA3
"FILE_BFMEMINIT", 0xA4
"FILE_SLOWCLOCKING_MSA", 0xA5
"FILE_IPCPROFILE", 0xA6
"FILE_CATFAIL_IPC", 0xA7
"FILE_GRAPHICS_TASK", 0xAA
"FILE_SCHEDULER_TASK", 0xAB
"FILE_COREMISC_HIFI2", 0xAD
"FILE_WM1830_HIFI2_INTCTRL", 0xAE
"FILE_CAMERA_TASK", 0xAF
"FILE_TRACEBUF_BF", 0xB0
"FILE_DSPDEBUG", 0xB2
"FILE_HNB0_MSA_INTCTRL", 0xB4
"FILE_SAC_CTRL", 0xB6
"FILE_SAC_DSP", 0xB8
"FILE_AUDIO_OS", 0xB9
"FILE_SAC", 0xBA
"FILE_VOICETEST", 0xBE
"FILE_LOWBATTERY", 0xC3
"FILE_PMINIT", 0xC4
"FILE_CRPTOBAT_OS", 0xC5
"FILE_IPC_SIG", 0xC6
"FILE_IPC_DATA", 0xC7
"FILE_IPC_COMMON", 0xC8
"FILE_IPC_TEST", 0xC9
"FILE_IPC_COPY", 0xCA
"FILE_CC_SAC", 0xCC
"FILE_DSPAUDIOTHREAD", 0xCE
"FILE_DTMF_TTY_DSP", 0xCF
"FILE_NOBATT_MIGHTY", 0xD0
"FILE_NOBATT_HUGE", 0xD1
"FILE_TAVOR_TEMPSENSE", 0xD2
"FILE_MIXER_CTRL", 0xD4
"FILE_GENERIC_DEBUG", 0xD6
"FILE_ENG_AVP", 0xD7
"FILE_KERNEL_PROF", 0xD8
"FILE_KERNEL_PROF2", 0xD9
"FILE_VOCODER_I", 0xDA
"FILE_VOCODER", 0xDB
"FILE_VIDEOTASK", 0xDC
"FILE_RENDERTASK", 0xDE
"FILE_EVENTFLAG_SERVICES", 0xE0
"FILE_EVENTFLAGS_NAME_SERVER_THREAD", 0xE1
"FILE_VRTHREAD", 0xE5
"FILE_VADTHREAD", 0xE6
"FILE_PROC_GPSSERIAL", 0xE7
"FILE_STARCORE_PERFMON", 0xE8
"FILE_BF_PERFMON", 0xE9
"FILE_MIXERCTRLTASK", 0xEA
"FILE_USBTASK", 0xEB
"FILE_HIFI2_HANDLER", 0xEC
"FILE_ARGONLV_MU", 0xED
"FILE_STARCORE_HANDLER", 0xEF
"FILE_ARGONLV_STARCORE_INTCTRL", 0xF0
"FILE_STARCORE_MISC", 0xF2
"FILE_ARGONLV_EPIT", 0xF4
"FILE_HNB0_BTSSP_DATA", 0xF6
"FILE_HNB0_BTSSP_CTRL", 0xF8
"FILE_DSP_SBC_PROC", 0xFE
"FILE_STARCORE_TRACEBUF", 0xFF
"FILE_APIFAIL", 0x3
"FILE_BLOCKS", 0x200
"MODULE_SIGNAL_RIM", 0x202
"MODULE_BIG_SHOW", 0x203
"MODULE_EXT", 0xFFF
"FILE_FLASHCLONING", 0x4
"FILE_BATMON", 0x5
"FILE_LCDRENDER", 0x6
"FILE_PERMON", 0x7
"FILE_BATTEMP", 0x8
"FILE_USBREQ", 0x9
"FILE_USBMUX", 0xA
"FILE_RLE", 0xB
"FILE_OS_METRICS", 0xC
"FILE_MCT", 0xD
"FILE_BRANDING", 0xE
"FILE_OS_INFO", 0xF
"FILE_FLASH", 0x10
"FILE_CHALLENGE", 0x11
"FILE_CRYPTKEY", 0x12
"FILE_ENCRYPTED", 0x13
"FILE_CRYPTKEY_REPEAT", 0x14
"FILE_rimusb_msm", 0x15
"FILE_HEAP", 0x16
"FILE_OSSTORE", 0x17
"FILE_ENCODER_IPP", 0x18
"FILE_DEBUGPRINTF", 0x19
"FILE_PASSWORD", 0x1A
"FILE_PMPROFILE", 0x1B
"FILE_APPSTORE", 0x1C
"FILE_NVRAM", 0x1D
"FILE_SAHARA_ARGONLV", 0x1E
"FILE_usb_rim_msm_dev", 0x1F
"FILE_LCD_7KMDP2", 0x20
"FILE_MSM6550_MDP_LCDIF", 0x21
"FILE_DbgUsb_msm", 0x22
"FILE_LED_BQHUGE", 0x23
"FILE_MEDIARECORDER", 0x24
"FILE_OVERLAY", 0x25
"FILE_NOBATTERY", 0x26
"FILE_CAM_API", 0x27
"FILE_CAM_SVP_PARSER", 0x28
"FILE_IRTINYTP", 0x29
"FILE_IRIAS", 0x2A
"FILE_IRLMPSC", 0x2B
"FILE_IRLMPCC", 0x2C
"FILE_IRLAP", 0x2D
"FILE_IRFRAMER", 0x2E
"FILE_USBDESC", 0x2F
"FILE_BTAPI", 0x500
"FILE_BTOSSTUB", 0x501
"FILE_BTDDBSTUB", 0x502
"FILE_BTUARTSTUB", 0x503
"FILE_BTSPPSTUB", 0x504
"FILE_SPEECH_LOG", 0x505
"FILE_SDCARD_LOG", 0x506
"FILE_USBSER", 0x507
"FILE_LCDRADIOAPI", 0x508
"FILE_H264", 0x509
"FILE_MEDIAWMACODEC", 0x50A
"FILE_USBSER_ABSTRACT", 0x50B
"FILE_ENG_DATA", 0x50C
"FILE_BTCALSTUB", 0x50D
"FILE_LCDTEST", 0x50E
"FILE_RAMIMAGE_NANDFLASH", 0x50F
"FILE_CAM_UTILITY", 0x510
"FILE_TIMEDSEMAPHORES", 0x511
"FILE_FATTRANSLATE", 0x512
"FILE_BLOCK_DEVICE", 0x513
"FILE_LCDFASTRAM", 0x514
"FILE_PM_SM", 0x515
"FILE_BUGDISP_X_CMDS", 0x516
"FILE_BATID", 0x517
"FILE_MSM6K_LCDIF", 0x518
"FILE_CACHE", 0x519
"FILE_USBKEY", 0x51A
"FILE_SW_MIXER", 0x51B
"FILE_TRACKBALL", 0x51C
"FILE_BUFFERPOOL", 0x51D
"FILE_MSWAV", 0x51E
"FILE_STREAMING", 0x51F
"FILE_MELODY_STREAM", 0x520
"FILE_MP3", 0x521
"FILE_MP3_PARSE", 0x522
"FILE_MP3_DECODE", 0x523
"FILE_MP3_HUFFMAN", 0x524
"FILE_AUDIOGRP", 0x525
"FILE_RIMUSB", 0x526
"FILE_USBDRV_HNB0", 0x527
"FILE_MEDIARTSP", 0x528
"FILE_INTERACTIVETEST", 0x529
"FILE_USBCD", 0x52A
"FILE_USBINT_MSM6500", 0x52B
"FILE_LCD_STUBOS", 0x52C
"FILE_LCD_STUBS", 0x52D
"FILE_BKLT2_PMJET", 0x52E
"FILE_HNB0_CAMIF", 0x52F
"FILE_FS_POSIX", 0x530
"FILE_GPS_RXN", 0x531
"FILE_LED_COMMON", 0x532
"FILE_TRICOLOUR_LED", 0x533
"FILE_API_VERSION", 0x534
"FILE_LIGHTSENSOR", 0x535
"FILE_CAM_SENSOR", 0x536
"FILE_DBSERJTG", 0x537
"FILE_DBSTREAM", 0x538
"FILE_SHMEMHOST", 0x539
"FILE_LCDSAPHIRE_SONY", 0x53A
"FILE_SPI_PRINTN", 0x53B
"FILE_SWEXHANDLER", 0x53C
"FILE_LCDSAPHIRE_SEC", 0x53D
"FILE_CRPTOBAT_SLIP", 0x53E
"FILE_CRPTOBAT_SM", 0x53F
"FILE_USBMS", 0x540
"FILE_USBMSSCSI", 0x541
"FILE_ASFCODEC", 0x542
"FILE_ARM7_CACHE", 0x543
"FILE_ARM9_CACHE", 0x544
"FILE_XSCALE_CACHE", 0x545
"FILE_LED_BQMIGHTY", 0x546
"FILE_LED_MAX6946", 0x547
"FILE_HNB0_LCDIF", 0x548
"FILE_USBDRV_ARGONLV", 0x549
"FILE_ITPOLICY", 0x54A
"FILE_BATCHRG", 0x54B
"FILE_PASSWD_OLD", 0x54C
"FILE_HIS", 0x54D
"FILE_SWPARTLIST", 0x54E
"FILE_LED_PMJET", 0x54F
"FILE_ENG_LIGHTSENSOR", 0x551
"FILE_TAVOR_LCDCTL", 0x552
"FILE_HCISNIFFER", 0x553
"FILE_DMA", 0x554
"FILE_TS_SYNAP", 0x555
"FILE_CALSCREEN", 0x556
"FILE_OTA_UPDATE", 0x557
"FILE_BTPOWER", 0x558
"FILE_AVP_NVRAM", 0x559
"FILE_RNG", 0x55A
"FILE_SDSOCKET", 0x55B
"FILE_OSPROFILE", 0x55C
"FILE_USBSER_INTER", 0x55D
"FILE_SBC", 0x55E
"FILE_CAMPREFLASH", 0x55F
"FILE_ENG_AUDIO", 0x560
"FILE_BKLT_NESSUS", 0x561
"FILE_STPEVENTS", 0x562
"FILE_HNB0_BACKLIGHT", 0x563
"FILE_MSM6250_BACKLIGHT", 0x564
"FILE_RASTER", 0x565
"FILE_MSM6500_BACKLIGHT", 0x566
"FILE_SVP_STRINGS", 0x567
"FILE_ENG_SVP", 0x568
"FILE_AUDIOSAL", 0x569
"FILE_CRPTOBAT_INFO", 0x56B
"FILE_CAM_9655", 0x56C
"FILE_VIDEOPLAYER", 0x56D
"FILE_BLOCKFS", 0x56F
"FILE_AUDIOCODEC", 0x570
"FILE_IPP_MEM_MGR", 0x571
"FILE_MPEG4", 0x572
"FILE_AUDIO_IPP", 0x573
"FILE_LCD_VP", 0x575
"FILE_LCD_VPI", 0x576
"FILE_AUDIO_FREESCALE", 0x577
"FILE_SVP_MGR", 0x578
"FILE_RNGTASK", 0x579
"FILE_AVICODEC", 0x57A
"FILE_CRITICAL_MSM", 0x57B
"FILE_THREADSERVICES_MSM", 0x57C
"FILE_ONTIME", 0x57D
"FILE_FUNLIGHT_API", 0x57E
"FILE_TAVOR_GPIO", 0x57F
"FILE_HNB0_GPIO", 0x580
"FILE_HERC_GPIO", 0x581
"FILE_MSM6250_GPIO", 0x582
"FILE_MSM6500_GPIO", 0x583
"FILE_AUDIO_VISUALON", 0x584
"FILE_BSN", 0x585
"FILE_WMV", 0x586
"FILE_SVP_CAM_DETECT", 0x587
"FILE_HNB0_FUNLIGHT", 0x588
"FILE_SDCARD_CACHE", 0x589
"FILE_BKLT_API", 0x58A
"FILE_BKLT_STATE", 0x58B
"FILE_BKLT_PROFILE", 0x58C
"FILE_CAM_VP", 0x58D
"FILE_CAM_FLASH", 0x58E
"FILE_UNICODE", 0x58F
"FILE_MP4CODEC", 0x590
"FILE_VAD_MEMORY", 0x591
"FILE_VAD_OS", 0x592
"FILE_VAD_PLATFORM", 0x593
"FILE_VAD_FS", 0x594
"FILE_VAD_GRAPHIC", 0x595
"FILE_VAD_PTT", 0x596
"FILE_VAD_PB", 0x597
"FILE_VAD_AUDIO", 0x598
"FILE_VAD", 0x599
"FILE_VAD_DEBUG", 0x59A
"FILE_VAD_STUBS", 0x59B
"FILE_VAD_PARAM", 0x59C
"FILE_GPS_DEBUG", 0x59D
"FILE_GPS_AI3", 0x59E
"FILE_GPS_SIRF_FRAMER", 0x5A0
"FILE_GPS_SIRF", 0x5A1
"FILE_MEDIACODEC", 0x5A3
"FILE_WAVCODEC", 0x5A4
"FILE_MEDIAVIDEOCODEC", 0x5A5
"FILE_MEDIAMP3CODEC", 0x5A6
"FILE_RAMDISK", 0x5A7
"FILE_MEDIAAMRCODEC", 0x5A8
"FILE_MEDIAAACCODEC", 0x5A9
"FILE_MEDIAUTIL", 0x5AA
"FILE_VIDEOCODEC", 0x5AB
"FILE_GPS_HW_DEBUG", 0x5AC
"FILE_TRANSPORT_TCP", 0x5AD
"FILE_TRANSPORT_DNS", 0x5AE
"FILE_TRANSPORT_VPN", 0x5AF
"FILE_TRANSPORT_UDP", 0x5B0
"FILE_RAMIMAGE_MAIN", 0x5B1
"FILE_RAMIMAGE_MISC", 0x5B2
"FILE_FATSTRING", 0x5B3
"FILE_RAMIMAGE_FLASH", 0x5B4
"FILE_RAMIMAGE_SECURITY", 0x5B5
"FILE_RAMIMAGE_DEVICE", 0x5B6
"FILE_SVP_CAM_VPI", 0x5B7
"FILE_QUINCY", 0x5B8
"FILE_BUGDISP_UTIL", 0x5B9
"FILE_SYSTEMHEAP", 0x5BA
"FILE_BF_MEMALLOC", 0x5BB
"FILE_ENG_LCD", 0x5BC
"FILE_AUDIOBLINK", 0x5BD
"FILE_SVP_LCD_DETECT", 0x5BE
"FILE_MEDIAMPEG", 0x5BF
"FILE_GPS_API", 0x5C0
"FILE_BATDOOR", 0x5C1
"FILE_LOG_VERB", 0x5C2
"FILE_LCDAPI", 0x5C3
"FILE_LCDBUFFERS", 0x5C4
"FILE_LCDPROFILE", 0x5C5
"FILE_LCDUTILITY", 0x5C6
"FILE_LCDTHEMES", 0x5C7
"FILE_CODEPROFILE", 0x5C8
"FILE_ARGONLV_GPIO", 0x5C9
"FILE_ENG_LOG_VERB", 0x5CA
"FILE_KEY", 0x5CB
"FILE_KEYPAD_API", 0x5CC
"FILE_DMA_API", 0x5CD
"FILE_HNB0_DMA", 0x5CE
"FILE_EVENTLOG", 0x5CF
"FILE_CALEXTERN", 0x5D0
"FILE_MSM6550_GPIO", 0x5D1
"FILE_SYSPROF_OPTS", 0x5D2
"FILE_SYSPROF_ENG", 0x5D3
"FILE_DMAPROFILE", 0x5D4
"FILE_MULTIPLE_OS", 0x5D5
"FILE_MEDIARAWCODEC", 0x5D6
"FILE_MEDIAPARSER", 0x5D7
"FILE_HSL", 0x5D8
"FILE_TB_GPIO", 0x5D9
"FILE_ARGONLV_IPU", 0x5DA
"FILE_ARGONLV_DMA", 0x5DB
"FILE_RENDER", 0x5DC
"FILE_ENG_GPS", 0x5DD
"FILE_HOLSTER", 0x5DE
"FILE_GPS_QUINCY", 0x5DF
"FILE_GPS_API_TEST", 0x5E0
"FILE_MSM6550_GPIO_ELTRON4", 0x5E1
"FILE_GPS_INTERNAL_API", 0x5E2
"FILE_GPS_COMMON", 0x5E3
"FILE_ENG_LIGHT", 0x5E4
"FILE_MSP430LOADER", 0x5E5
"FILE_NANDFLASH", 0x5E6
"FILE_GPS_SIRF_EE", 0x5E7
"FILE_MELODY_MSM", 0x5E8
"FILE_BUGDISP_CMDS", 0x5E9
"FILE_ENG_LOGGING", 0x5EA
"FILE_ARGONLV_SDMA", 0x5EB
"FILE_BLOCKMAP_QC", 0x5EC
"FILE_ARGONLV_BDMA", 0x5ED
"FILE_VADTASK_MSM", 0x5EE
"FILE_VRTASK_MSM", 0x5EF
"FILE_VAD_AUDIO_MSM", 0x5F0
"FILE_VAD_AUDIO_COMMON", 0x5F1
"FILE_MEMPOOLS", 0x5F2
"FILE_TAVOR_COMM_DMA", 0x5F3
"FILE_SDBUGDISP_LOG", 0x5F4
"FILE_RAMIMAGE_CDUMP", 0x5F5
"FILE_VIDEORECORDER", 0x5F6
"FILE_RIMMCODEC", 0x5F7
"FILE_FATRW", 0x5F8
"FILE_SDCARD", 0x5F9
"FILE_FATINTERNAL", 0x5FB
"FILE_STPCOMMON", 0x5FD
"FILE_ENG_MEDIA", 0x5FF
"FILE_ROM_SUPPORT", 0xA00
"FILE_ARGONLV_AUDMUX", 0xA01
"FILE_ARGONLV_BBP", 0xA02
"FILE_ARGONLV_SSP", 0xA03
"FILE_ROM_DETECT", 0xA04
"FILE_SDIO", 0xA05
"FILE_STARCORE_MMU", 0xA06
"FILE_VFP", 0xA07
"FILE_MSM7600_ONENANDFLASH", 0xA08
"FILE_VAD_PLAY", 0xA09
"FILE_L210_CACHE", 0xA0A
"FILE_ARGONLV_SDCARD", 0xA0B
"FILE_HNB0_SDCARD", 0xA0C
"FILE_MSM6500_SDCARD", 0xA0D
"FILE_USBMUX_BR_RI", 0xA0E
"FILE_HNB0_MISC_HW", 0xA0F
"FILE_MSM6500_MISC_HW", 0xA10
"FILE_GPS_MSG_GEN", 0xA11
"FILE_MSM6550_CAMIF", 0xA12
"FILE_fs_nvram_freemap", 0xA13
"FILE_fs_nvram_compat", 0xA14
"FILE_ARM_L1_CACHE", 0xA15
"FILE_ARM_L2_CACHE", 0xA16
"FILE_MSA_L1_CACHE", 0xA17
"FILE_SC_L1_CACHE", 0xA18
"FILE_MSA_MMU", 0xA19
"FILE_AUDIO_LOGGING", 0xA1A
"FILE_GPS_AIDING", 0xA1B
"FILE_sensor", 0xA1C
"FILE_ARM_MMU", 0xA1D
"FILE_FAT", 0xA1E
"FILE_ENG_CAMERA", 0xA20
"FILE_TAVOR_SDCARD", 0xA21
"FILE_hallsensor_hw", 0xA22
"FILE_ENG_SDMMC", 0xA23
"FILE_NANDFLASH_HW", 0xA24
"FILE_NANDBLOCKFS", 0xA25
"FILE_NVRAM_NAND", 0xA26
"FILE_NVRAM_NAND_OLD", 0xA27
"FILE_NVRAM_API", 0xA28
"FILE_NANDFLASHCACHE", 0xA29
"FILE_ARGONLV_CAMIF", 0xA2A
"FILE_GPS_MFRG", 0xA2B
"FILE_TAVOR_CAMIF", 0xA2C
"FILE_GPS_TCXO", 0xA2D
"FILE_QUINCY_COUNTERS", 0xA2E
"FILE_ROM_PIDPIC", 0xA2F
"FILE_USBDRV_ANTIOCH", 0xA30
"FILE_QUINCY_ESCREEN", 0xA31
"FILE_CYANHNDMA", 0xA32
"FILE_CYANHNINTR", 0xA33
"FILE_CYANHNEP", 0xA34
"FILE_CYANHNSTOR", 0xA35
"FILE_CYANHNUSB", 0xA36
"FILE_CYANHNLL", 0xA37
"FILE_CYANHNMISC", 0xA38
"FILE_USBDRV_RIMUDC", 0xA39
"FILE_USBPROFILE", 0xA3A
"FILE_CYANHAL_RIM", 0xA3B
"FILE_CYANHALBLKALLOC", 0xA3C
"FILE_LPBUGDISP", 0xA3D
"FILE_RINGBUFFER", 0xA3E
"FILE_XSCALE_L2_CACHE", 0xA3F
"FILE_BTBENCH_LIB", 0xA40
"FILE_BTBYPASS", 0xA41
"FILE_BQHUGE_BACKLIGHT", 0xA42
"FILE_TAVOR_GRAPHICS", 0xA43
"FILE_WIFI_PROFILE", 0xA44
"FILE_FPS_HAL", 0xA45
"FILE_EGL", 0xA46
"FILE_RIM_OVERLAYS", 0xA47
"FILE_sensor_debounce", 0xA48
"FILE_REMOTE_BUFFERS", 0xA49
"FILE_STARCORE_EONCE", 0xA4A
"FILE_ENG_BATTERY", 0xA4B
"FILE_VGOAL", 0xA4C
"FILE_BKLT2_APIOS", 0xA4D
"FILE_BKLT2_APIJVM", 0xA4E
"FILE_BKLT2_SM", 0xA4F
"FILE_FPS_ENVIRO", 0xA50
"FILE_FPS_MAIN", 0xA51
"FILE_FPS_API", 0xA52
"FILE_FPS_TASK", 0xA53
"FILE_ARM_VM", 0xA54
"FILE_FATVERIFY", 0xA55
"FILE_BKLT2_PROFILE", 0xA56
"FILE_BKLT2_COMMON", 0xA57
"FILE_TAVOR_SECURE_BOOT", 0xA58
"FILE_MSM7600_GPIO", 0xA59
"FILE_GPS_RADIO_UTIL", 0xA5A
"FILE_LCD_CBABC", 0xA5B
"FILE_TB_OPTICAL", 0xA5C
"FILE_BKLT2_NVRAM", 0xA5D
"FILE_BKLT2_BRIGHTNESS", 0xA5E
"FILE_BKLT2_FADE", 0xA5F
"FILE_EGL_NATIVE", 0xA60
"FILE_SC_MAIN", 0xA61
"FILE_SC_HW", 0xA62
"FILE_SC_LTC4556", 0xA63
"FILE_LS_SCHEMA_2", 0xA64
"FILE_ARGONLV_SECURE_BOOT", 0xA65
"FILE_USB_MTP", 0xA66
"FILE_EGL_EXTENSIONS", 0xA67
"FILE_LS2_SM", 0xA68
"FILE_LS2_HISTORY", 0xA69
"FILE_NANDFLASHTESTS", 0xA6A
"FILE_GENERIC_HEAP", 0xA6B
"FILE_MULTI_SIZE_BUCKETS", 0xA6C
"FILE_HYBRID_BUDDY_BLOCK", 0xA6D
"FILE_SHARED_MEM_LOCK", 0xA6E
"FILE_SHMEM_PRINTN", 0xA6F
"FILE_LS2_SAMPLING", 0xA70
"FILE_LS2_API", 0xA71
"FILE_ACCELEROMETER", 0xA72
"FILE_ACCEL_HW_ST", 0xA73
"FILE_LS2_NESSUS", 0xA74
"FILE_ARGONLV_GRAPHICS", 0xA75
"FILE_SVP_LS_CAL_PARSER", 0xA76
"FILE_SVP_LS_BEHAV_PARSER", 0xA77
"FILE_GENERIC_HEAP_DEBUG", 0xA78
"FILE_USBDRV_MSM7600", 0xA79
"FILE_VGAMANITH", 0xA7A
"FILE_FLASHTASK", 0xA7B
"FILE_ARGONLV_PF", 0xA7C
"FILE_ENCODER_VO", 0xA7D
"FILE_CAMERA_FE", 0xA7E
"FILE_CAMERA_BE", 0xA7F
"FILE_GRAPHICS_MEMPOOL", 0xA80
"FILE_NVFLATFILE", 0xA81
"FILE_EGL_MRVL", 0xA82
"FILE_EGL_AMANITH", 0xA83
"FILE_SYSPROF_API", 0xA84
"FILE_EGL_UTILITY", 0xA85
"FILE_EGL_QC", 0xA86
"FILE_ARGONLV_SSI", 0xA87
"FILE_AUDIO_SSP", 0xA88
"FILE_TB_ATOMIC", 0xA89
"FILE_MEDIAPLAYER", 0xA8A
"FILE_TTS", 0xA8C
"FILE_MSM7500_SBI", 0xA8D
"FILE_CAMERA_RT", 0xA8F
"FILE_ENG_UTIL", 0xA90
"FILE_QCOMM_GRAPHICS", 0xA91
"FILE_NVRAM_MULTI", 0xA92
"FILE_OTA_PATRIOT", 0xA93
"FILE_QUALCOM_VM", 0xA94
"FILE_USBDRV_TAVORPV", 0xA95
"FILE_BKLT2_MAX6946", 0xA96
"FILE_ADC", 0xA97
"FILE_LDRBLOCKS", 0xA98
"FILE_ARGONLV_SDMA_ONCE", 0xA99
"FILE_KD", 0xA9A
"FILE_MSM7600_KEYPAD", 0xA9B
"FILE_MSM7K_LCDIF", 0xA9C
"FILE_TAVOR_ISP_CAMIF", 0xA9D
"FILE_CAM_SVP4", 0xA9E
"FILE_TS_CYPRESS", 0xA9F
"FILE_SYSPROF_OS", 0xAA0
"FILE_BKLT2_MAX6948", 0xAA1
"FILE_IPP_OSAPI", 0xAA2
"FILE_GPS_TRACKER", 0xAA3
"FILE_GPS_NAV", 0xAA4
"FILE_GPS_PAL", 0xAA5
"FILE_GPS_SIRF_NAV", 0xAA6
"FILE_ALIGN", 0xAA7
"FILE_SYSPROF_NATIVE", 0xAA8
"FILE_GPS_SIRF_API", 0xAA9
"FILE_FASTJPEGDECODER", 0xAAA
"FILE_DECODEMCUPROG", 0xAAB
"FILE_JPEGDECODER", 0xAAC
"FILE_JPEGDATAREADER", 0xAAD
"FILE_DECODEMCU", 0xAAE
"FILE_SDTEST", 0xAAF
"FILE_WORKERTASK", 0xAB0
"FILE_EXIF", 0xAB1
"FILE_TOUCHSCREEN", 0xAB2
"FILE_ACCEL_GR", 0xAB4
"FILE_STUBS_CAMIF", 0xAB5
"FILE_SIMULATOR_CAMIF", 0xAB6
"FILE_FUEL_GAUGE", 0xAB7
"FILE_GPS_RXN_CALLS", 0xAB8
"FILE_GPS_SIRF_EXT_LOG", 0xAB9
"FILE_BLOCKMAP", 0xABA
"FILE_ARGONLV_SOC_CAMIF", 0xABC
"FILE_OUTPUTSYSTASK", 0xABD
"FILE_RIMCRYPT", 0xABE
"FILE_ONENANDFLASH", 0xABF
"FILE_REMOTECONTROL", 0xAC1
"FILE_IMAGEDECODER", 0xAC2
"FILE_KHR_THREAD_STORAGE", 0xAC3
"FILE_KD_MRVL", 0xAC4
"FILE_BKLT2_NVRAM_LEGACY", 0xAC5
"FILE_FLVCODEC", 0xAC6
"FILE_CAMERA_STP", 0xAC7
"FILE_CAM_VF", 0xAC8
"FILE_AACENCODER", 0xAC9
"FILE_STACKUTILS", 0xACD
"FILE_SYSPROF_BUGPROF", 0xACE
"FILE_SNDCODEC", 0xACF
"FILE_RESET", 0xAD1
"FILE_PROC_RESET", 0xAD2
"FILE_PRESERVE_API", 0xAD3
"FILE_UPDATE_MANAGER_QC", 0xAD4
"FILE_OMXCORE", 0xAD5
"FILE_OMXCOREBASE", 0xAD6
"FILE_OMXMEDIAREC", 0xAD7
"FILE_OMXRENDER", 0xAD8
"FILE_OMXCAMERAVF", 0xAD9
"FILE_OMXVIDEOENC", 0xADA
"FILE_OMXMP4MUX", 0xADB
"FILE_OMXENCODER_VO", 0xADC
"FILE_OMXENCODER_IPP", 0xADD
"FILE_OMXUTILS", 0xADE
"FILE_OMXRESERVED1", 0xADF
"FILE_OMXRESERVED2", 0xAE0
"FILE_CAPTIONS", 0xAE2
"FILE_ACCEL_HW", 0xAE3
"FILE_ACCEL_HW_AD", 0xAE4
"FILE_PROTECTEDTASK", 0xAE5
"FILE_MUX3GP", 0xAE6
"FILE_BKLT2_ESCREEN", 0xAE7
"FILE_ENG_INPUT", 0xAE8
"FILE_QUINCYLOG", 0xAE9
"FILE_CMLACRYPTO", 0xAEA
"FILE_TAVOR_SDCARD_NO_OS", 0xAEB
"FILE_SDCARD_NOINT", 0xAEC
"FILE_AUDIOSRC", 0xAED
"FILE_VCLICK_API", 0xAEE
"FILE_VCLICK_BL_HW", 0xAEF
"FILE_VCLICK_HW", 0xAF0
"FILE_STARTUPSCREEN", 0xAF1
"FILE_USERTASKOSAPI", 0xAF2
"FILE_VCLICK_ALGO", 0xAF3
"FILE_ASSD", 0xAF4
"FILE_CAM_MTEK_ISP_MV9319", 0xAF5
"FILE_AACMUX", 0xAF6
"FILE_IPP_JPEG", 0xAF7
"FILE_BIDDEBUG", 0xAF8
"FILE_BOUNDINGRECT", 0xAF9
"FILE_MMCFLASH", 0xAFA
"FILE_TB_AJBGEN2", 0xAFB
"FILE_MBBUGDISP", 0xAFC
"FILE_TAVOR_SOC_CAMIF", 0xAFD
"FILE_CAM_ST_ISP_987", 0xAFE
"FILE_VCLICK_COMMON", 0xAFF
"FILE_TS_SYNAP_T1021", 0xE00
"FILE_QUINCY_XML", 0xE01
"FILE_FLAC", 0xE02
"FILE_MEDIAFLACCODEC", 0xE03
"FILE_TASK_CALL", 0xE04
"FILE_CAM_STMICRO_6725", 0xE05
"FILE_RASTERVABC16", 0xE06
"FILE_MSM7600_SDCARD", 0xE07
"FILE_MSM7600_SDCARD_NESSUS", 0xE08
"FILE_LED_BKLT_LIB", 0xE09
"FILE_LED_SCHEMATIC", 0xE0A
"FILE_MAX6946", 0xE0B
"FILE_MAX6948", 0xE0C
"FILE_MAX694X", 0xE0D
"FILE_REGISTER_RW_I2C_MSM", 0xE0E
"FILE_REGISTER_SC", 0xE0F
"FILE_LED_MAX6948", 0xE10
"FILE_TS_TESTBENCH", 0xE11
"FILE_FONT_RENDERER", 0xE12
"FILE_OGGVORBIS", 0xE13
"FILE_MEDIAOGGCODEC", 0xE14
"FILE_EGL_AMANITH_SURFACE", 0xE15
"FILE_EGL_AMANITH_CONTEXT", 0xE16
"FILE_MEDIATASK", 0xE17
"FILE_IMAGE_CONVERSION", 0xE18
"FILE_WMDRM", 0xE1A
"FILE_WMHAL_CRITICAL", 0xE1B
"FILE_WMHAL_DATETIME", 0xE1C
"FILE_WMHAL_FILE_IO", 0xE1D
"FILE_WMHAL_MEMORY", 0xE1E
"FILE_WMHAL_RSA", 0xE1F
"FILE_WMHAL_MISC", 0xE20
"FILE_WMDRM_COMMON", 0xE21
"FILE_VCLICK_ALGO_TFRO", 0xE22
"FILE_VCLICK_ALGO_FSUM", 0xE23
"FILE_FATSTP", 0xE24
"FILE_EGL_AMQC", 0xE25
"FILE_EGL_AMQC_SURFACE", 0xE26
"FILE_EGL_AMQC_CONTEXT", 0xE27
"FILE_ENG_VCLICK", 0xE28
"FILE_VCLICK_ALGO_DSP", 0xE29
"FILE_GPS_SIRF_EEGENERATE", 0xE2A
"FILE_GPS_BROADCOM", 0xE30
"FILE_GPS_BROADCOM_HAL", 0xE31
"FILE_GPS_BROADCOM_STUBS", 0xE32
"FILE_GPS_CLIB", 0xE33
"FILE_GPS_EVENT_PROCESS", 0xE34
"FILE_GPS_EVENT_CBKS", 0xE35
"FILE_GPS_XML_PARSER", 0xE36
"FILE_GPS_HAL_INIT", 0xE37
"FILE_GPS_RUN", 0xE38
"FILE_M1P2_PARSE", 0xE39
"FILE_LS2_HW_ISL", 0xE3A
"FILE_TBHW_TOUCHSCREEN", 0xE3B
"FILE_MEDIAVORBISCODEC", 0xE3C
"FILE_VCLICK_DSP_LIB", 0xE3D
"FILE_AUDIOCODECMGR", 0xE3E
"FILE_MEMORYUTILITIES", 0xE3F
"FILE_MSM_SPI", 0xE40
"FILE_PROXSENSOR_API", 0xE41
"FILE_PROXSENSOR_SAMPLING", 0xE42
"FILE_PROXSENSOR_SM", 0xE43
"FILE_GRAPHICS_UTIL", 0xE44
"FILE_BKLT2_HAL", 0xE45
"FILE_MSM7K_SECURE_BOOT", 0xE46
"FILE_DSP_MAPPER", 0xE47
"FILE_SDMMC_TASK", 0xE48
"FILE_ARGON_SCC", 0xE49
"FILE_ARM_PAGE_POOLS", 0xE4A
"FILE_MMU_PERF", 0xE4B
"FILE_SERIALBUSTESTS", 0xE4C
"FILE_NTIMERS", 0xE4D
"FILE_TS_FACE_FILTER", 0xE4E
"FILE_DEVICE", 0xE4F
"FILE_LS2_COMMON", 0xE50
"FILE_LCD_SM", 0xE51
"FILE_AMSS35_SOC_CAMIF", 0xE53
"FILE_SAFE_STRING", 0xE54
"FILE_GPS_SIRF_LOC", 0xE55
"FILE_JPEGENCODER", 0xE56
"FILE_USBDRV_CHIPIDEAQC", 0xE57
"FILE_NTIMERS_ELTRON", 0xE58
"FILE_STP_NVRAM", 0xE59
"FILE_REFRESH_FP", 0xE5A
"FILE_CALMORESCREEN", 0xE5B
"FILE_USB_MSG", 0xE60
END ENUM "fileid"

BEGIN ENUM "Dc_Id_Type"
"M_FLASH_ID", 0x0
"M_PROCESSOR_ID", 0x1
"M_BSN", 0x2
"M_IMEI", 0x3
"M_BBPIN", 0x4
"M_OS_VERSION", 0x5
"M_HW_PLATFORM_ID", 0x6
"M_HW_FREQ_MAP", 0x7
"M_SIM_ICCID", 0x8
"M_SIM_IMSI", 0x9
"M_BSN_BARYON_RADIO", 0xA
"M_MSN_BARYON", 0xB
"M_PATRIOT_BINARY_VER", 0xC
"M_SIM_ID_BARYON", 0xD
"M_HW_BOARD_REV", 0xE
"M_IMEI_BARYON_GW", 0xF
"M_HW_STRING", 0x10
"M_BOOTROM_ID", 0x11
"M_BLUETOOTH_MAC", 0x12
"M_WLAN_MAC", 0x13
"M_RADIOCODE_LINKED_ID", 0x14
"M_OS_METRICS_VERSION", 0x15
END ENUM "Dc_Id_Type"

BEGIN ENUM "EntryPoint"
"RIMPOSTMESSAGE", 0x0
"RIMGETMESSAGE", 0x1
"RIMTASKYIELD", 0x2
"RIMSCANMESSAGEQUEUE", 0x3
"RIMDISPLAYAPPMESSAGEQUEUES", 0x4
"RIMGETVMSTACKINFO", 0x5
"RIMPEEKSPECIFICMESSAGE", 0x6
"RIMWAITFORSPECIFICMESSAGE", 0x7
"RIMENTERCRITICALSECTION", 0x8
"RIMLEAVECRITICALSECTION", 0x9
"RIMCHECKCRITICALSECTION", 0xA
"RIMLOCKCOUNTINGSEM", 0xB
"RIMUNLOCKCOUNTINGSEM", 0xC
"RIMTASKSTOP", 0xD
"RIMTASKRESTART", 0xE
"RIMLOCKSEMAPHORE", 0xF
"RIMUNLOCKSEMAPHORE", 0x10
"RIMINITSEMAPHORE", 0x11
"RIMTASKBLOCK", 0x12
"RIMTASKUNBLOCK", 0x13
"RIMFLAGSET", 0x14
"RIMFLAGWAIT", 0x15
"RIMFASTFLAGSET", 0x16
"RIMFASTFLAGWAIT", 0x17
"RIMSCANMESSAGESPECIFIC", 0x18
"OSDISABLEINTERRUPTS", 0x19
"OSENABLEINTERRUPTS", 0x1A
"RIMUSERTASKSYSCALL", 0x1B
"RIMSWITCHTOUSERMODE", 0x1C
"RIMSWITCHTOKERNELMODE", 0x1D
"OSMUTEXLOCK", 0x1E
"OSMUTEXTRYLOCK", 0x1F
"OSMUTEXUNLOCK", 0x20
"OSMUTEXCREATE", 0x21
"OSMUTEXDELETE", 0x22
"OSMUTEXGETOWNER", 0x23
"OSSEMAPHORELOCK", 0x24
"OSSEMAPHOREUNLOCK", 0x25
"OSSEMAPHORECREATE", 0x26
"OSSEMAPHOREDELETE", 0x27
"OSSEMAPHOREGETCOUNT", 0x28
"OSSEMAPHOREGETFIRSTWAITER", 0x29
"OSPOSTMESSAGEWITHFLAGS", 0x2A
"OSDEQUEUELARGEMESSAGE", 0x2B
"OSLOGTRACE", 0x2C
END ENUM "EntryPoint"

BEGIN ENUM "EVENT"
"I2C_OPERATION_EVENT", 0x4D01
"I2C_RESULT_EVENT", 0x4D02
"PMIC_INTERRUPT", 0x6E01
"PMIC_CHECK_USB", 0x6E02
"PMIC_CHARGER_STATUS", 0x6E03
"PMIC_INT_REDIRECT", 0x6E04
"PMIC_FAKE_REMOVAL", 0x6E05
"COMM_RX_EDGE", 0x508
"COMM_NOTIFY_TASK", 0x509
"COMM_CONTROL_INT", 0x50A
"DEBUG_SERIAL_RX_EDGE", 0x528
"DEBUG_SERIAL_NOTIFY_TASK", 0x529
"DEBUG_SERIAL_RX_ERROR", 0x520
"DEBUG_SERIAL_RX_AVAILABLE", 0x521
"DEBUG_SERIAL_TX_EMPTY", 0x522
"DEBUG_SERIAL_PATTERN_NOTIFY", 0x523
"CAL_COMMAND_TO_RADIOCODE", 0xA1FF
"CAL_RESPONSE_FROM_RADIOCODE", 0xA1FE
"CAL_REGISTER_STP_HANDLER", 0xA1FD
"CAL_UNREGISTER_STP_HANDLER", 0xA1FC
"GENERIC_HEAP_FREE_MEMORY_LOW_WATERMARK", 0x160
"GENERIC_HEAP_FREE_MEMORY_HIGH_WATERMARK", 0x161
"DSP_BUGDISP_EVENT", 0x7D01
"DSP_BUGDISP_PS_EVENT", 0x7D02
"DSP_CATFAIL", 0x7D03
"DSP_HSL_CONFIG", 0x7D04
"DSP_HSL_FILTER", 0x7D05
"DSP_HSL_TESTMSG", 0x7D06
"DSP_IPC_DATA_TEST", 0x7D07
"DSP_DEBUG_BOMB", 0x7D08
"CODE_PROFILE_NVRETRIEVE", 0x7D09
"CODE_PROFILE_NVUPDATE", 0x7D0A
"COMMS_BUGDISP_SYNC_REQUEST", 0x7D0B
"I_USB_MSG_RECEIVED", 0x7C02
"I_USB_PARTIAL_MSG_RECEIVED", 0x7C04
"I_USB_MSG_SENT", 0x7C08
"I_USB_SETUP_PACKET_RECEIVED", 0x7C10
"I_USB_CABLE_CONNECTED", 0x7C81
"I_USB_DISCONNECTED", 0x7C82
"I_USB_CLOSE_CHANNELS", 0x7C83
"I_USB_WRITE_DONE", 0x7C84
"I_USB_READ_READY", 0x7C85
"I_USB_HOST_PWR_WARN", 0x7C86
"I_USB_SOFT_RECONNECT", 0x7C87
"I_USB_CDHANDLER", 0x7C88
"I_USB_START_PENDING_WRITE", 0x7C89
"I_USB_SWITCH_ENUM_MODE", 0x7C8A
"I_USB_MS_IO_COMPLETE_MSG", 0x7CA0
"I_USB_MS_IO_FAIL_MSG", 0x7CA1
"I_USB_MS_RESET", 0x7CA2
"I_USB_HP_MUX_REGISTER_CHANNEL", 0x7CB0
"I_USB_HP_MUX_DEREGISTER_CHANNEL", 0x7CB1
"I_USB_HP_MUX_OPEN_CHANNEL", 0x7CB2
"I_USB_HP_MUX_SEND_PACKET", 0x7CB3
"I_USB_HP_MUX_ADD_RECV_BUFF", 0x7CB4
"USB_EXEC_ANTIOCH_LOOPBACK_TEST", 0x7CF9
"I_USB_ACK_SET_CONFIG", 0x7CFA
"I_USB_RESUME_FROM_SUSPEND", 0x7CFB
"I_USB_SUSPENDED", 0x7CFC
"I_USB_RESUME_MSG", 0x7CFD
"I_USB_CHECK_INVALID_STATE", 0x7CFF
"I_IOTASK_START_TIMER", 0x7401
"I_IOTASK_START_PERIODIC_TIMER", 0x7402
"I_IOTASK_CALL_FUNCTION", 0x7403
"I_IOTASK_RADIO_ICON", 0x7404
"I_USB_RESET_STATE", 0x7C00
"I_USB_CONFIGURED", 0x7C01
"I_USB_CABLE_IN", 0x7C20
"I_USB_PORT_SUSPEND", 0x7C80
"I_USB_REENUMERATE", 0x7CA3
"I_USB_BUGDISP_INTERNAL_WAKEUP", 0x7CC0
"USB_BUGDISP_INTERNAL_WAKEUP", 0xE00
"MESSAGE_RECEIVED", 0x601
"MESSAGE_SENT", 0x602
"MESSAGE_NOT_SENT", 0x603
"MESSAGE_STATUS", 0x608
"PDP_STATUS_CHANGE", 0x609
"MESSAGE_DELIVERY_STATUS", 0x60A
"PDP_ACT_FAILED", 0x60B
"PDP_ADDRESS_CHANGE", 0x610
"DATA_SERVICE_ERR", 0x671
"SM_PARAMS_UPDATE_CONFIRMED", 0x688
"SM_PARAMS_UPDATE_FAILED", 0x689
"SM_ROUTE_UPDATE_CONFIRMED", 0x68A
"SM_ROUTE_UPDATE_FAILED", 0x68B
"SM_MES_STATUS", 0x68C
"CB_MES_STATUS", 0x650
"CB_GET_MESSAGE_CONFIRMED", 0x651
"CB_GET_MESSAGE_FAILED", 0x652
"CB_CBMI_READ_CONFIRMED", 0x653
"CB_CBMI_READ_FAILED", 0x654
"CB_CBMI_WRITE_CONFIRMED", 0x655
"CB_CBMI_WRITE_FAILED", 0x656
"CB_LP_READ_CONFIRMED", 0x657
"CB_LP_READ_FAILED", 0x658
"CB_LP_WRITE_CONFIRMED", 0x659
"CB_LP_WRITE_FAILED", 0x65A
"CB_SETUP_CONFIRMED", 0x65B
"CB_SETUP_FAILED", 0x65C
"CB_CELL_CHANGE_IND", 0x65D
"RADIO_MAG_KEY", 0x660
"ESCREEN_MSG_REFRESH", 0xF101
"ESCREEN_MSG_MODE_STATUS", 0xF102
"ESCREEN_MSG_LOGWORTHY", 0xF110
"ESCREEN_MSG_LOGWORTHY_DELAYED", 0xF111
"FILE_OPERATION_FAILED", 0x1300
"FILE_OPERATION_COMPLETE", 0x1301
"FILE_OPERATION_FORMAT_COMPLETE", 0x1302
"FILE_OPERATION_REPAIR_COMPLETE", 0x1303
"FILE_OPERATION_FREE_MEMORY_LOW_WATERMARK", 0x1304
"FILE_OPERATION_FREE_MEMORY_HIGH_WATERMARK", 0x1305
"FILE_OPERATION_DELETE_TREE_COMPELTE", 0x1306
"FILE_OPERATION_MOUNT_COMPLETE", 0x1307
"BATTERY_LOW", 0x102
"POWER_OFF", 0x103
"POWER_UP", 0x104
"POWER_OFF_REQUEST", 0x105
"BATTERY_GOOD", 0x107
"MEMORY_LOW", 0x108
"BATTERY_UPDATE", 0x109
"BUGDISP_INIT", 0x10A
"CAL_UPDATE", 0x120
"CRADLE_MISMATCH", 0x121
"CRADLE_MISMATCH_CLEAR", 0x122
"ENOUGH_CURRENT_AVAILABLE", 0x130
"BATTERY_IN", 0x131
"BATTERY_OUT", 0x132
"BATTERY_DOOR_OPENED", 0x133
"BATTERY_DOOR_CLOSED", 0x134
"BATTERY_LOG", 0x135
"BACKLIGHT_UPDATE", 0x140
"FAILED_MAX_PWD_ATTEMPTS", 0x150
"WORKER_TASK_EXECUTE", 0x165
"WORKER_TASK_DONE", 0x166
"RTC_ALARM_EXPIRED", 0x300
"RTC_CLOCK_UPDATE", 0x301
"RTC_CLOCK_SET_FAILED", 0x302
"RTC_ALARM_SET_OK", 0x303
"RTC_ALARM_SET_FAILED", 0x304
"NETWORK_TIME_UPDATE", 0x305
"USB_CHANNEL_OPEN_REQ", 0xE01
"USB_CHANNEL_OPENED", 0xE02
"USBMS_MEDIUM_CHANGE", 0xE03
"USB_CONNECTION_STATUS", 0xE04
"USB_CHANNEL_CLOSED", 0xE08
"USB_PACKET_SENT", 0xE10
"USB_PACKET_NOT_SENT", 0xE20
"USB_PACKET_RECEIVED", 0xE40
"USB_REDIRECTED_PASSWORD_CHALLENGE", 0xE80
"RESTART_TIMER", 0xABCD1234
"EXPIRE_TIMERS_NOW", 0x1234ABCD
"OVERFLOW_RANGE", 0x7FFFFFFF
END ENUM "EVENT"

BEGIN ENUM "SmLdoRtcStatus"
"SmLdoRtcStatus_off", 0x0
"SmLdoRtcStatus_on", 0x1
END ENUM "SmLdoRtcStatus"

BEGIN ENUM "DspBootFailure"
"DSP_BOOT_UNTOUCHED", 0x0
"DSP_BOOT_FREQ_CHANGE", 0x1
"ARM9_BOOT_SUCCESS", 0x2
"ARM9_RTC_CAL", 0x10
"DSP_BOOT_SUCCESS", 0x12345678
"DSP_BOOT_INVALID_ADDR_FAILURE", 0xFFFFFF1F
"DSP_BOOT_MEM_INIT_FAILURE", 0xFFFFFF1E
"DSP_BOOT_TIMEOUT", 0xFFFFFF1D
"DSP_BOOT_NOT_STARTED", 0xFFFFFF1C
END ENUM "DspBootFailure"

BEGIN ENUM "FastFlagState"
"FLAG_UNDEF", 0x0
"FLAG_NONE", 0x1
"FLAG_READY", 0x2
"FLAG_WAITING", 0x3
END ENUM "FastFlagState"

BEGIN ENUM "BlockState"
"BLOCK_NONE", 0x0
"BLOCK_RECEIVE", 0x1
"BLOCK_STOP", 0x2
"BLOCK_SEMAPHORE", 0x4
"BLOCK_COUNT_SEM", 0x8
"BLOCK_NONEXIST", 0x10
"BLOCK_PAGE_FAULT", 0x20
"BLOCK_INST_BOUNCE", 0x40
"BLOCK_FLAG", 0x80
"BLOCK_BREAKPOINT", 0x100
"BLOCK_SCHEDULER", 0x200
END ENUM "BlockState"

BEGIN ENUM "supergroupid"
"SUPERGROUP_OS", 0x1
"SUPERGROUP_WLAN", 0x2
"SUPERGROUP_MULTIMEDIA", 0x3
"SUPERGROUP_WLANCHIPSET", 0x4
"SUPERGROUP_MWAF", 0x5
"SUPERGROUP_GPRS", 0x6
"SUPERGROUP_UMTS", 0x7
END ENUM "supergroupid"

BEGIN ENUM "IOTYPE"
"IOTYPE_GPIO", 0x0
"IOTYPE_EGPIO", 0x1
"IOTYPE_GP", 0x2
END ENUM "IOTYPE"

BEGIN ENUM "BqHugeChargerStatus"
"BQHUGE_CHG_STAT_PRE", 0x0
"BQHUGE_CHG_STAT_DONE", 0x1
"BQHUGE_CHG_STAT_FAST", 0x2
"BQHUGE_CHG_STAT_OTHER", 0x3
END ENUM "BqHugeChargerStatus"

BEGIN ENUM "VendorIdType"
"NEXTEL_VENDOR_ID", 0x67
"TELUS_VENDOR_ID", 0x7E
"KTP_KOREA_VENDOR_ID", 0xDA
"VODAFONE_PO_VENDOR_ID", 0x99
"VODAFONE_GR_VENDOR_ID", 0xBC
"ASB_VENDOR_ID", 0xF1
"CMCC_VENDOR_ID", 0x127
"INVALID_VENDOR_ID", 0xFFFF
END ENUM "VendorIdType"

BEGIN ENUM "HW_VERSION_CLASS"
"HW_VERSION_CLASS__BOARD", 0x1
"HW_VERSION_CLASS__CPU", 0x2
"HW_VERSION_CLASS__SW_COMPAT", 0x3
"HW_VERSION_CLASS__POP", 0x4
"HW_VERSION_CLASS__CHARGER", 0x7
"HW_VERSION_CLASS__AUDIOCHIP", 0x8
"HW_VERSION_CLASS__CAMERA", 0x9
"HW_VERSION_CLASS__BAT_DOOR", 0xA
"HW_VERSION_CLASS__POP_SECURITY", 0xB
"HW_VERSION_CLASS__GPS", 0xC
"HW_VERSION_CLASS__ROM", 0xD
"HW_VERSION_CLASS__LCD", 0x11
"HW_VERSION_CLASS__PLASTICS", 0x12
"HW_VERSION_CLASS__SMARTCARD", 0x14
"HW_VERSION_CLASS__TRACKBALL", 0x15
"HW_VERSION_CLASS__TOUCHDOME", 0x16
"HW_VERSION_CLASS__CDMA", 0x17
"HW_VERSION_CLASS__VCLICK", 0x18
"HW_VERSION_CLASS__DTR_HACK", 0x31
"HW_VERSION_CLASS__RFTX_LEVEL", 0x32
"HW_VERSION_CLASS__BL_DRIVER", 0x33
"HW_VERSION_CLASS__BT_TEST", 0x34
"HW_VERSION_CLASS__PC4", 0x35
"HW_VERSION_CLASS__FLASH", 0x36
"HW_VERSION_CLASS__HAC", 0x37
"HW_VERSION_CLASS__WLAN", 0x38
"HW_VERSION_CLASS__DOCOMO", 0x39
"HW_VERSION_CLASS__EEDGE", 0x3A
"HW_VERSION_CLASS__WCDMA_BAND", 0x3B
"HW_VERSION_CLASS__WLAN_WTE", 0x3C
"HW_VERSION_CLASS__GPS_ANTENNA", 0x3D
END ENUM "HW_VERSION_CLASS"

BEGIN ENUM "HwvCpuType"
"HW_CPU_MSM5100", 0x80
"HW_CPU_MSM6500", 0x81
"HW_CPU_MSM6250", 0x82
"HW_CPU_MSM6500_90nm", 0x83
"HW_CPU_MSM6550", 0x84
"HW_CPU_MSM6551", 0x85
"HW_CPU_MSM7200", 0x88
"HW_CPU_MSM7500", 0x89
"HW_CPU_MSM7500a", 0x8A
"HW_CPU_MSM7601", 0x8B
"HW_CPU_MSM7600_32RAM", 0x8C
"HW_CPU_MSM7600_64RAM", 0x8D
"HW_CPU_MSM7600_64RAM_FAB", 0x8E
"HW_CPU_MSM7600_64RAM_TURBO", 0x8F
"HW_CPU_MSM7600_32RAM_TURBO", 0x90
"HW_CPU_MSM7200_64RAM_TURBO", 0x91
"HW_CPU_MSM7500_32RAM_TURBO", 0x92
"HW_CPU_MSM7200_32RAM_TURBO", 0x93
"HW_CPU_HERMONB0", 0xC0
"HW_CPU_HERMONB0_MCP", 0xC1
"HW_CPU_HERMONB1_MCP", 0xC2
"HW_CPU_HERMONB2_MCP", 0xC3
"HW_CPU_HERMONB3_MCP", 0xC4
"HW_CPU_HERMONB3", 0xC5
"HW_CPU_HERMONB3_DIS_EDGE_ONLY", 0xC6
"HW_CPU_HERMONEL_A0", 0xC7
"HW_CPU_HERMONB3_SLOW", 0xC8
"HW_CPU_HERMONEL_A1", 0xC9
"HW_CPU_HERMONELT_Z0", 0xCA
"HW_CPU_HERMONELT_A0", 0xCB
"HW_CPU_HERMONELT_A1", 0xCC
"HW_CPU_HERMONELT_A5", 0xCD
"HW_CPU_HERMONELT_A6", 0xCE
"HW_CPU_TAVOR_Z0", 0xE0
"HW_CPU_TAVOR_A0", 0xE1
"HW_CPU_TAVOR_B0", 0xE2
"HW_CPU_TAVOR_B0B", 0xE3
"HW_CPU_TAVOR_B1D", 0xE4
"HW_CPU_TAVOR_B1DM90", 0xE5
"HW_CPU_TAVOR_B2FM90", 0xE6
"HW_CPU_TAVOR_B2H", 0xE7
"HW_CPU_TAVOR_B2F_SECURE", 0xE8
"HW_CPU_TAVOR_B2F_PROD", 0xE9
"HW_CPU_TAVOR_B2H_JTAG_ENABLED", 0xEA
"HW_CPU_TAVOR_B2J", 0xEB
"HW_CPU_TAVORPV_A1F", 0xD0
"HW_CPU_TAVORPV_B0H", 0xD1
"HW_CPU_TAVORPV_B0H_POP", 0xD2
"HW_CPU_TAVORPV_C0J", 0xD3
"HW_CPU_TAVORPV_C1J", 0xD4
"HW_CPU_TAVORPV_C1L", 0xD5
"HW_CPU_TAVORPV_C1L_PROD", 0xD6
"HW_CPU_TAVORPV2_Z0", 0x20
"HW_CPU_TAVORPV2_Z1", 0x21
"HW_CPU_TAVORPV2_A0", 0x22
"HW_CPU_ARGON_LV", 0x30
"HW_CPU_ARGON_LV_TSMC", 0x31
"HW_CPU_ARGON_LV_INT_BOOT", 0x32
END ENUM "HwvCpuType"

BEGIN ENUM "HW_GPS_CLASS"
"HW_GPS_DEFAULT", 0x0
"HW_GPS_NONE", 0x1
"HW_GPS_SIRF_LTIF", 0x2
"HW_GPS_SIRF_LTIR", 0x3
"HW_GPS_SIRF_3TW", 0x4
"HW_GPS_UNUSED", 0x5
"HW_GPS_BCM4750", 0x10
"HW_GPS_TI_NL5500", 0x20
END ENUM "HW_GPS_CLASS"

BEGIN ENUM "DEVICE"
"DEVICE_EVENTFLAGS", 0x47
"DEVICE_PROXSENSOR", 0x48
"DEVICE_I_TASK_CALL", 0x49
"DEVICE_DATAQUEUE", 0x4A
"DEVICE_I_ASSD", 0x4B
"DEVICE_I_OUTPUTSYS_TASK", 0x4C
"DEVICE_I_I2C", 0x4D
"DEVICE_I_WTE", 0x4E
"DEVICE_I_BLOCKDEVICE", 0x4F
"DEVICE_I_POWER", 0x50
"DEVICE_I_NAND_FLASH", 0x51
"DEVICE_I_FILE", 0x52
"DEVICE_I_GENERIC_HEAP", 0x53
"DEVICE_LIGHTSENSOR2", 0x54
"DEVICE_IDEN", 0x55
"DEVICE_I_TOUCHSCREEN", 0x56
"DEVICE_BACKLIGHT2", 0x57
"DEVICE_I_INET", 0x58
"DEVICE_I_SOCKET", 0x59
"DEVICE_I_CACHE", 0x5A
"DEVICE_I_WM", 0x60
"DEVICE_I_INFO_INIT", 0x61
"DEVICE_I_BLUETOOTH_INFO", 0x62
"DEVICE_I_SDCARD_LOG", 0x63
"XSCALE_RF_IF_PAD_MUX", 0x64
"DEVICE_I_LDO", 0x65
"DEVICE_I_BT_DUN", 0x66
"DEVICE_BTSER", 0x67
"DEVICE_SSP", 0x68
"DEVICE_I_VAD", 0x69
"DEVICE_IPC_PROFILE", 0x6A
"DEVICE_I_WIFI_VOICE", 0x6B
"DEVICE_I_MELODY", 0x6C
"DEVICE_I_SDIO", 0x6D
"DEVICE_I_PMIC", 0x6E
"DEVICE_I_VOICETEST", 0x6F
"DEVICE_CB_SERIAL", 0x70
"DEVICE_SERMUX", 0x71
"DEVICE_LIGHTSENSOR", 0x72
"DEVICE_I_AUDIO", 0x73
"DEVICE_I_IOTASK", 0x74
"DEVICE_SDL", 0x75
"DEVICE_USBSER", 0x76
"DEVICE_PAT_SERIAL", 0x78
"DEVICE_BLUETOOTH_SERIAL", 0x79
"DEVICE_SERIAL_DEBUG", 0x7A
"DEVICE_DSP", 0x7B
"DEVICE_I_USB", 0x7C
"DEVICE_I_SIM", 0x7D
"DEVICE_I_WLAN", 0x7E
"DEVICE_I_ADC", 0x7F
"DEVICE_NONE", 0x0
"DEVICE_SYSTEM", 0x1
"DEVICE_KEYPAD", 0x2
"DEVICE_RTC", 0x3
"DEVICE_TIMER", 0x4
"DEVICE_SERIAL", 0x5
"DEVICE_RADIO", 0x6
"DEVICE_HOLSTER", 0x7
"DEVICE_HEADSET", 0x8
"DEVICE_SIM", 0x9
"DEVICE_ALERT", 0xA
"DEVICE_PERIPHERAL", 0xB
"DEVICE_IRDA", 0xC
"DEVICE_STREAMING", 0xD
"DEVICE_USB", 0xE
"DEVICE_EXPANSION", 0xF
"DEVICE_SMARTCARD", 0x10
"DEVICE_RTP_RTCP", 0x11
"DEVICE_WLAN", 0x12
"DEVICE_FILE", 0x13
"DEVICE_CURSOR", 0x14
"DEVICE_AUDIO", 0x15
"DEVICE_SIMULATOR", 0x16
"DEVICE_GPS", 0x17
"DEVICE_MELODY", 0x18
"DEVICE_BLUETOOTH", 0x19
"DEVICE_STYLUS", 0x1A
"DEVICE_TRACKBALL", 0x1B
"DEVICE_VIDEO", 0x1D
"DEVICE_BBCLIENT", 0x1E
"DEVICE_VAD", 0x1F
"DEVICE_MEDIA", 0x20
"DEVICE_TCP", 0x21
"DEVICE_INET", 0x22
"DEVICE_VPN", 0x23
"DEVICE_CAMERA", 0x24
"DEVICE_RTSP", 0x25
"DEVICE_DISPLAY", 0x26
"DEVICE_SOCKET", 0x27
"DEVICE_WAF_3GPP", 0x28
"DEVICE_WAF_WLAN", 0x29
"DEVICE_WAF_CDMA", 0x30
"DEVICE_WAF", 0x31
"DEVICE_WAF_VPN", 0x32
"DEVICE_SENSOR", 0x33
"DEVICE_FPS", 0x34
"DEVICE_TOUCHSCREEN", 0x35
"DEVICE_ACCELEROMETER", 0x36
"DEVICE_WAF_IDEN", 0x37
"DEVICE_FXP", 0x38
"DEVICE_DRM", 0x39
"DEVICE_SYSPROF", 0x3A
"DEVICE_FLASH", 0x3B
"DEVICE_PTX", 0x3C
"DEVICE_TTS", 0x3D
"DEVICE_IMAGE", 0x3E
"DEVICE_ASSD", 0x3F
"DEVICE_SW_CMPTT", 0x40
"DEVICE_USER", 0x80
END ENUM "DEVICE"

BEGIN ENUM "MEMPOOLTAG"
"MEMPOOLTAG_NONE", 0x0
"MEMPOOLTAG_GPS_START", 0x1000
"MEMPOOLTAG_GPS_END", 0x1FFF
"MEMPOOLTAG_MAX", 0xFFFFFF
END ENUM "MEMPOOLTAG"

BEGIN ENUM "SYSTEM_HEAP_TAG"
END ENUM "SYSTEM_HEAP_TAG"

BEGIN ENUM "TASK_CALL_EVENT"
"I_TASK_START_TIMER", 0x1
"I_TASK_START_PERIODIC_TIMER", 0x2
END ENUM "TASK_CALL_EVENT"

BEGIN ENUM "USB_SETUP2"
"USB_BATTERY_STATUS", 0xA0
"USB_POWER_STATUS", 0xA1
"USB_HIGH_POWER", 0xA2
"USB_SET_CHARGER", 0xA3
"USB_PERIPHERAL_PRESENT", 0xA4
"USB_GET_RIM_STATUS", 0xA5
"USB_HOST_BATTERY_STATUS", 0xA6
"USB_HIGH_POWER2", 0xA7
"USB_GET_BB_INTERFACE_DESC", 0xA8
"USB_SET_DEV_MODE", 0xA9
"USB_GET_MS_DESCRIPTOR", 0xAA
"USB_HOST_VERSIONS", 0xAB
"USB_HOST_CAPABILITIES", 0xAC
END ENUM "USB_SETUP2"

BEGIN ENUM "USB_POWER"
"INVALID_STATE", 0xC
"USB_CHARGE_POWER", 0x1
"USB_BOOT_POWER", 0x2
"USB_NO_POWER", 0x4
"USB_SUSPEND_POWER", 0x8
"USB_ADAPTER_POWER", 0x10
"USB_CLEAR_SUSPEND_POWER", 0xF7
"USB_SUSPEND_FROM_CHARGE", 0x9
END ENUM "USB_POWER"

BEGIN ENUM "USB_MODES"
"USB_MODE_BBONLY", 0x0
"USB_MODE_BBMS", 0x1
"USB_MODE_MSONLY", 0x2
"USB_MODE_BBSI", 0x3
"USB_MODE_BBMSMTP", 0x4
"USB_MODE_MTPONLY", 0x5
"USB_MODE_BBMTP", 0x6
"USB_MODE_BBMSANDMTP", 0x7
"USB_MODE_NDISTEST", 0x8
"USB_MODE_INVALID", 0xFFFF
END ENUM "USB_MODES"

BEGIN ENUM "USB_SPEEDS"
"USB_SPEED_DEFAULT", 0x0
"USB_SPEED_FULL", 0x1
"USB_SPEED_HIGH", 0x2
"USB_SPEED_NONE", 0xFF
"USB_NUM_SPEEDS", 0x3
END ENUM "USB_SPEEDS"

BEGIN ENUM "CAL_BACKLIGHT_TYPES"
"CAL_LCD_BACKLIGHT", 0x0
"CAL_KB_BACKLIGHT", 0x1
"CAL_LCD_KB_BACKLIGHT", 0x2
END ENUM "CAL_BACKLIGHT_TYPES"

BEGIN ENUM "SVP_STP_OPERATION"
"SVP_STP_OP_WRITE", 0x0
"SVP_STP_OP_READ", 0x1
"SVP_STP_OP_DELETE", 0x2
"SVP_STP_OP_REWORK", 0x3
"SVP_STP_OP_LIST", 0x4
END ENUM "SVP_STP_OPERATION"

BEGIN ENUM "SVP_STP_LOCATION"
"SVP_STP_LOCATION_OS", 0x0
"SVP_STP_LOCATION_NVRAM", 0x1
END ENUM "SVP_STP_LOCATION"

BEGIN ENUM "BR_PERSIST_FLAG"
"BR_PERSIST_FLAG_NONE", 0x0
"BR_PERSIST_FLAG_PMIC_RESET", 0x1
"BR_PERSIST_MEMORY_CORRUPTED", 0x2
END ENUM "BR_PERSIST_FLAG"

BEGIN ENUM "ChipType"
"UNKNOWN_CHIP", 0x0
"HERCULES_CHIP", 0x1
"GREENWATER_CHIP", 0x2
"MONACO_CHIP", 0x3
"HERMES_CHIP", 0x4
"MSM6500_CHIP", 0x5
"HERMONB0_CHIP", 0x6
"HERMONB1_CHIP", 0x7
"HERMONB2_CHIP", 0x8
"HERMONB3_CHIP", 0x9
"MSM6550_CHIP", 0xA
"MSM6250_CHIP", 0xB
"HERMONEL_CHIP", 0xC
"HERMONELT_CHIP", 0xD
"TAVORA0_CHIP", 0xE
"TAVORB0_CHIP", 0xF
"TAVORB1_CHIP", 0x10
"ARGONLV_CHIP", 0x11
"TAVORB2_CHIP", 0x12
"MSM7600_CHIP", 0x13
"TAVORPV_A1_CHIP", 0x14
"TAVORPV_B0_CHIP", 0x15
"TAVORPV_C0_CHIP", 0x16
"TAVORPV2_Z1_CHIP", 0x17
"TAVORPV2_A0_CHIP", 0x18
"MSM7200_CHIP", 0x19
"MSM7500_CHIP", 0x1A
"UNKNOWN_CHIP_REV", 0x1B
"TAVORMG1_A0_CHIP", 0x1C
END ENUM "ChipType"

BEGIN ENUM "HSL_USER"
"HSL_USER_EVENTLOG", 0x1
"HSL_USER_DEBUG_TEST", 0x2
"HSL_USER_THIRD_PARTY", 0x4
END ENUM "HSL_USER"

BEGIN ENUM "HSL_MASK"
"HSL_MASK_SW0", 0x0
"HSL_MASK_SW1", 0x1
"HSL_MASK_SW2", 0x2
"HSL_MASK_SW3", 0x3
"HSL_MASK_TCU", 0x4
END ENUM "HSL_MASK"

BEGIN ENUM "LCD_TEST_CMD"
"LCD_TEST_SLEEP_IN", 0x1
"LCD_TEST_SLEEP_OUT", 0x2
"LCD_TEST_DISP_ON", 0x3
"LCD_TEST_DISP_OFF", 0x4
"LCD_TEST_HW_INIT", 0x5
"LCD_TEST_WRITE_READ", 0x6
"LCD_TEST_FULL_UPDATE", 0x7
"LCD_TEST_SET_BACKLIGHT_BRIGHTNESS", 0x8
"LCD_TEST_SHOW_REGS", 0x9
"LCD_TEST_REG_READ", 0x10
"LCD_TEST_STANDBY_REG_READ", 0x11
"LCD_TEST_STANDBY_WRITE_READ", 0x12
"LCD_TEST_TOGGLE_TX_FLAG", 0x13
"LCD_TEST_TOGGLE_RXTX_FLAG", 0x14
"LCD_TEST_TOGGLE_RX_FLAG", 0x15
"LCD_TEST_TOGGLE_NUM_FLAG", 0x16
"LCD_TEST_TOGGLE_HOURGLASS", 0x17
"LCD_TEST_TOGGLE_ALT_FLAG", 0x18
"LCD_TEST_TOGGLE_CAPS_FLAG", 0x19
"LCD_TEST_CHANGE_RX_IMAGE", 0x20
"LCD_TEST_CHANGE_RXTX_IMAGE", 0x21
"LCD_TEST_CHANGE_NUM_IMAGE", 0x22
"LCD_TEST_CHANGE_ALT_IMAGE", 0x23
"LCD_TEST_CHANGE_CAPS_IMAGE", 0x24
"LCD_TEST_CHANGE_HOURGLASS", 0x25
"LCD_TEST_CHANGE_TX_IMAGE", 0x26
"LCD_TEST_FILL_NVRAM", 0x27
"LCD_TEST_WIPE_NVRAM", 0x28
"LCD_TEST_TOGGLE_TX_RACH_FLAG", 0x29
"LCD_TEST_CHANGE_TX_RACH_IMAGE", 0x2A
"LCD_TEST_GET_DATE_CODE", 0x30
"LCD_TEST_SPECIAL_BMP1", 0x31
"LCD_TEST_SPECIAL_BMP2", 0x32
"LCD_TEST_REG_WRITE_READ", 0x33
"LCD_TEST_REG_WRITE", 0x34
"LCD_TEST_RAND_PIXEL", 0x35
"LCD_TEST_REG_WRITE_TIMING", 0x36
"LCD_TEST_REG_READ_TIMING", 0x37
"LCD_TEST_WRITE_TIMING", 0x38
"LCD_TEST_READ_TIMING", 0x39
"LCD_TEST_ROUTINE_1", 0x3A
"LCD_TEST_ROUTINE_2", 0x3B
"LCD_TEST_ROUTINE_3", 0x3C
"LCD_TEST_ROUTINE_4", 0x3D
"LCD_TEST_ROUTINE_5", 0x3E
"LCD_TEST_ROUTINE_6", 0x3F
"LCD_TEST_WRITE_THEN_READ_1BY1", 0x42
"LCD_TEST_DRAW_CHECKERBOARD", 0x43
"LCD_TEST_SLEEP_WRITE_READ", 0x44
"LCD_TEST_WRITE_VRAM_PIXEL", 0x45
"LCD_TEST_INTERFACE_STRESS_TEST", 0x46
"LCD_TEST_INTERACTIVE_TEST", 0x47
"LCD_TEST_LOCKED_SCREEN_TEST", 0x48
"LCD_TEST_SPAM_REG_WRITE", 0x50
END ENUM "LCD_TEST_CMD"

BEGIN ENUM "PmNotificationBits"
"PM_NOTIFIED_CHARGER_ENABLED", 0x1
"PM_NOTIFIED_BATTERY_GOOD", 0x2
"PM_NOTIFIED_IS_IN_CHARGER", 0x4
"PM_NOTIFIED_VREF_COARSE_ADJUST", 0x8
"PM_NOTIFIED_EXTERNAL_POWER", 0x10
"PM_NOTIFIED_BATTERY_LOW", 0x20
"PM_NOTIFIED_IGNORE_PERIPHERAL_USAGE", 0x40
"PM_NOTIFIED_UMTS_LIMIT", 0x80
"PM_NOTIFIED_SLUMP_DETECTED", 0x100
"PM_NOTIFIED_LED_CHARGE_INDICATOR", 0x200
"PM_NOTIFIED_NO_CAMERA_FLASH", 0x400
"PM_NOTIFIED_CHARGER_FAULT", 0x1000
"PM_NOTIFIED_DVFM_LIMIT", 0x2000
"PM_NOTIFIED_RADIO_TOO_HOT", 0x4000
"PM_NOTIFIED_NCV_SUPPORTED", 0x8000
END ENUM "PmNotificationBits"

BEGIN ENUM "PmChargerBits"
"PM_CHARGER_TAKE_NCV_SAMPLES", 0x1
"PM_CHARGER_100MA_TOGGLE", 0x2
"PM_CHARGER_TERMINATION_TOGGLE", 0x4
"PM_CHARGER_AC_DROP", 0x8
"PM_CHARGER_BAD_BATTERY", 0x10
"PM_CHARGER_TEMPERATURE_ERROR", 0x20
"PM_CHARGER_LOW_BATTERY", 0x40
"PM_CHARGER_LOCK_RATE", 0x80
"PM_CHARGER_CALTASK_OVERRIDE", 0x100
"PM_CHARGER_CONTACTS_PRESENT", 0x200
"PM_CHARGER_TEMPERATURE_NO_AC", 0x400
"PM_CHARGER_LOW_BATTERY_CHARGING", 0x800
"PM_CHARGER_ADAPTER_TOGGLE", 0x1000
END ENUM "PmChargerBits"

BEGIN ENUM "PmChargeRate"
"PM_CHARGE_UNSET", 0xFFFFFFFF
"PM_CHARGE_OFF", 0x0
"PM_CHARGE_100mA", 0x64
"PM_CHARGE_450mA", 0x1C0
"PM_CHARGE_500mA", 0x1F4
"PM_CHARGE_900mA", 0x381
"PM_CHARGE_1350mA", 0x542
"PM_CHARGE_1800mA", 0x703
END ENUM "PmChargeRate"

BEGIN ENUM "RESET_SOFT_OVR"
"RESET_SOFT_OVR_NONE", 0x0
"RESET_SOFT_OVR_USER_DISABLED", 0x1
"RESET_SOFT_OVR_DISABLED_PERMANENT", 0x2
"RESET_SOFT_OVR_NO_REBOOT_COMPLETE", 0x4
"RESET_SOFT_OVR_SHORT_UPTIME", 0x8
"RESET_SOFT_OVR_OLD_BR_VERSION", 0x10
"RESET_SOFT_OVR_HW_UNSUPPORTED", 0x20
"RESET_SOFT_OVR_SECURE_AND_BRANDED", 0x40
"RESET_SOFT_OVR_BATTERY", 0x80
"RESET_SOFT_OVR_ALL", 0xFFFFFFFF
END ENUM "RESET_SOFT_OVR"

BEGIN ENUM "SDT_ERROR"
"RESERVED_ERROR", 0x1
"SMMR_TIMEOUT_ERROR", 0x2
"GPB_RETRY_ERROR", 0x3
"GPB_ILLEGAL_ACCESS_SIZE_ERROR", 0x4
"ILLEGAL_ADDRESS_ERROR", 0x5
"BUS_ERROR", 0x6
"GPB_OUT_OF_RANGE_ERROR", 0x7
END ENUM "SDT_ERROR"

BEGIN ENUM "BOOL"
"TRUE", 0x1
"FALSE", 0x0
END ENUM "BOOL"

BEGIN ENUM "RESET_REASON"
"REBOOT_UNKNOWN", 0xFFFFFFFF
"REBOOT_POWER_LOSS", 0x0
"REBOOT_INITIATED", 0x1
END ENUM "RESET_REASON"

BEGIN ENUM "log_events"
"JAVA_EVENT_1", 0xC000
"JAVA_EVENT_2", 0xC001
"JAVA_EVENT_3", 0xC002
"JAVA_EVENT_4", 0xC003
"JAVA_EVENT_5", 0xC004
"JAVA_EVENT_6", 0xC005
"JAVA_EVENT_7", 0xC006
"JAVA_EVENT_8", 0xC007
"JAVA_EVENT_9", 0xC008
"JAVA_EVENT_10", 0xC009
"JAVA_EVENT_11", 0xC00A
"JAVA_EVENT_12", 0xC00B
"JAVA_EVENT_13", 0xC00C
"JAVA_EVENT_14", 0xC00D
"JAVA_EVENT_15", 0xC00E
"JAVA_EVENT_16", 0xC00F
"JAVA_EVENT_LAST", 0xCFFF
END ENUM "log_events"

BEGIN ENUM "LogSelection"
"ENGDATA_BUGDISP_CORE_MASK", 0xF0000
"ENGDATA_BUGDISP_CORE_OSAPPS", 0x0
"ENGDATA_BUGDISP_CORE_DSP", 0x10000
"ENGDATA_BUGDISP_CORE_RADIO", 0x20000
END ENUM "LogSelection"

BEGIN ENUM "NETWORK_TYPE"
"NET_MOBITEX", 0x1
"NET_DATATAC", 0x2
"NET_GPRS", 0x3
"NET_CDMA", 0x4
"NET_IDEN", 0x5
"NET_802_11", 0x6
"NET_UMTS", 0x7
"NET_NONE", 0x8
"NET_DONGLE", 0x9
END ENUM "NETWORK_TYPE"

BEGIN ENUM "FORM_FACTOR"
"FORM_HANDHELD", 0x1
"FORM_PAGER", 0x2
"FORM_OEM", 0x3
"FORM_TACH2", 0x4
"FORM_QUARK", 0x5
"FORM_GRAVITON", 0x6
"FORM_PHONE", 0x7
"FORM_TESTBOARD", 0x8
"FORM_CHARM", 0x9
"FORM_BBCLIENT", 0xA
"FORM_ELECTRON", 0xB
"FORM_PERIPHERAL", 0xC
"FORM_POSITRON", 0xD
"FORM_GAMMARAY", 0xE
"FORM_MAMABEAR", 0xF
"FORM_VBB_WM", 0x10
"FORM_KICKSTART", 0x11
"FORM_METEOR", 0x12
"FORM_VBB_SYM", 0x13
"FORM_STORM", 0x14
"FORM_JAVELIN", 0x15
"FORM_MAGNUM", 0x16
"FORM_NAUTILUS", 0x17
"FORM_TALLADEGA", 0x18
END ENUM "FORM_FACTOR"

BEGIN ENUM "MANUFACTURER_ID"
"MANUFACTURER_ID_RIM", 0x0
"MANUFACTURER_ID_SIEMENS", 0x1
"MANUFACTURER_ID_MOTOROLA", 0x2
END ENUM "MANUFACTURER_ID"

BEGIN ENUM "HW_SECURITY"
"HW_SECURITY_UNKNOWN", 0x0
"HW_SECURITY_SECURE", 0x1
"HW_SECURITY_JTAG", 0x2
"HW_SECURITY_OTHER", 0x3
END ENUM "HW_SECURITY"

BEGIN ENUM "SUPPRESSION_STATUS"
"SUPPRESSION_ACTIVE", 0x0
"SUPPRESSION_INACTIVE", 0x1
"SUPPRESSION_NOT_SUPPORTED", 0x2
END ENUM "SUPPRESSION_STATUS"

BEGIN ENUM "LCD_TYPE"
"COLUMNWISE_MONOCHROME_LCD", 0x1
"ROWWISE_4BIT_GREYSCALE", 0x2
"ROWWISE_16BIT_COLOUR", 0x3
"ROWWISE_16BIT_COLOUR_WITH_W100", 0x4
"COLUMNWISE_2BIT_GREYSCALE_LCD", 0x5
"DYNAMIC_LCD", 0x6
"ROWWISE_3BIT_GREYSCALE", 0x7
"SEVEN_SEGMENT", 0x8
END ENUM "LCD_TYPE"

BEGIN ENUM "CONN_STAT_ENUM"
"USB_CABLE_CONNECTED", 0x1
"USB_ENUMERATED", 0x2
"USB_CABLE_DISCONNECTED", 0x4
"USB_NOTENUMERATED", 0x8
"USB_MS_INTERFACE_ENUMERATED", 0x10
"USB_MTP_INTERFACE_ENUMERATED", 0x20
END ENUM "CONN_STAT_ENUM"

BEGIN ENUM "USB_BDISP_DEBUG_EVENTS"
"USB_BD_DEBUG_NONE", 0x0
"USB_BD_DEBUG_RESET", 0x1
"USB_BD_DEBUG_RESUME", 0x2
"USB_BD_DEBUG_SUSPEND", 0x3
"USB_BD_DEBUG_CONFIG", 0x4
"USB_BD_DEBUG_START_SEND", 0x6
"USB_BD_DEBUG_END_SEND", 0x7
"USB_BD_DEBUG_CANCEL_SEND", 0x8
END ENUM "USB_BDISP_DEBUG_EVENTS"

BEGIN ENUM "USB_SETUP"
"USB_GET_STATUS", 0x0
"USB_CLEAR_FEATURE", 0x1
"USB_SET_FEATURE", 0x3
"USB_SET_ADDRESS", 0x5
"USB_GET_DESCRIPTOR", 0x6
"USB_SET_DESCRIPTOR", 0x7
"USB_GET_CONFIGURATION", 0x8
"USB_SET_CONFIGURATION", 0x9
"USB_GET_INTERFACE", 0xA
"USB_SET_INTERFACE", 0xB
"USB_SYNCH_FRAME", 0xC
"USB_END_OF_PACKET", 0x10
"USB_BULK_TRANSFER", 0x80
"USB_MS_RESET", 0xFF
"USB_MS_GET_MAX_LUN", 0xFE
END ENUM "USB_SETUP"

BEGIN ENUMSET "Event"
"EVENT"
"TimerName"
END ENUMSET

BEGIN ENUMSET "Task"
"TaskID"
END ENUMSET

BEGIN FILE "FILE_ENTRYPOINT", "", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\entrypoints\\entrypoint.c"
175, WARNN, "CheckThreadStack: %(TaskID) is corrupted!"
176, PRINT2N, "CheckThreadStack: Stack starts at 0x%x and ends at 0x%x"
179, BIG_SHOW_MEMORY, "CheckStack: Stack content {...}"
183, SHOW_MEMORY, "STACK_TOP :"
185, SHOW_MEMORY, "STACK_TOP :"
200, ASSERTF, "Stack overflow SVC"
201, SHOW_MEMORY, "STACK_BOTTOM :"
208, ASSERTF, "Stack overflow SVC"
209, SHOW_MEMORY, "STACK_BOTTOM :"
217, ASSERTF, "Stack overflow FIQ"
231, WARNN, "CurrentDisablerLinkRegister %p"
235, WARNN, "FastCoreIntDisableLinkRegister %p"
240, WARN2N, "Interrupts disabled for %(EntryPoint) lr = %p"
242, ASSERTF, "Interrupt disable failure"
302, WARNN, "Mem corrupt - On leave kernel, currentTask = %(TaskID)"
328, ASSERTFN, "Stack overflow task %(TaskID) on leaving"
337, ASSERTFN, "Stack overflow task %(TaskID) on entering"
457, WARN2N, "Memory Corrupt - kernel entry %(EntryPoint), currentTask = %(TaskID)"
657, ASSERTFN, "Bad SWI %d"
803, WARNN, "System call %u is not implemented"
830, WARN2N, "Memory Corrupt - kernel entry %(EntryPoint), currentTask = %(TaskID)"
832, WARN3N, "PARAM_1 = 0x%x, PARAM_2 = 0x%x, PARAM_3 = 0x%x"
853, WARN2N, "Mem corrupt - On leave kernel entry %(EntryPoint), currentTask = %(TaskID)"
855, WARN3N, "PARAM_1 = 0x%x, PARAM_2 = 0x%x, PARAM_3 = 0x%x"
885, PRINT2N, "RimPostMessage(%(TaskID)) CurrentTaskIndex=%d"
930, PRINT2N, "OsPostUniqueMessage(%(TaskID)) CurrentTaskIndex=%d"
970, WARNN, "Bad mode of entry to RimGetMessage by 0x%x"
986, PRINTN, "RimGetMessage => %(TaskID)"
1015, WARN, "Bad mode of entry for RimPeekSpecificMessage"
1042, WARN, "Bad mode of entry for RimPeekMessage"
1067, WARN, "Bad mode of entry for RimTaskYield"
1183, WARN, "Bad mode of entry for RimWaitForSpecificMessage"
1226, WARNN, "Bad mode of entry for RimLockCountingSemaphore( 0x%08x )"
1298, WARNN, "Bad mode of entry for RimSemaphoreLock( 0x%08x )"
1359, WARNN, "Bad mode of entry to RimSemaphoreCreate by %p"
1385, WARN2N, "Bad mode of entry for RimSemaphoreDelete( 0x%08x ) by %p"
1537, WARNN, "Invalid unblock reason %(BLOCK_REASON)"
1583, WARNN, "Invalid block reason %(BLOCK_REASON)"
1649, WARN, "Bad mode of entry for RimTaskStop"
1711, WARNN, "Bad mode of entry for RimLockSemaphore( 0x%08x )"
1738, WARNN, "Bad mode of entry for RimUnlockSemaphore( 0x%08x )"
1778, WARNN, "Bad mode of entry for RimMutexLock( 0x%08x )"
1807, WARNN, "Bad mode of entry for RimMutexLock( 0x%08x )"
1835, WARNN, "Bad mode of entry for RimMutexUnlock( 0x%08x )"
1863, WARNN, "Bad mode of entry to RimMutexCreate by %p"
1889, WARN2N, "Bad mode of entry for RimMutexDelete( 0x%08x ) by %p"
2033, WARN2N, "Bad mode of entry for RimFlagWait( 0x%08x, 0x%08x )"
2143, WARN2N, "Bad mode of entry for RimFastFlagWait( 0x%08x, 0x%08x )"
2187, WARNN, "OsDisableInterrupts bad nesting: count is %d but interrupts are enabled"
2228, WARN, "OsEnableInterrupts bad nesting: count is already 0"
2232, WARN, "OsEnableInterrupts bad nesting: interrupts are already enabled"
2282, WARN, "KernelPostMessageWithFlags cannot be used during a catfail"
2288, WARN, "KernelPostMessageWithFlags cannot be used in interrupt mode"
2294, WARN, "KernelPostMessageWithFlags cannot be used with interrupts disabled"
2335, WARN, "KernelDequeueLargeMessage cannot be used during a catfail"
2341, WARN, "kernelDequeueLargeMessage cannot be used in interrupt mode"
2347, WARN, "KernelDequeueLargeMessage cannot be used with interrupts disabled"
2371, PRINT, "Kernel side syscall called!"
2378, PRINT, "switching to user mode"
2385, PRINT, "switching to kernel mode"
END FILE "FILE_ENTRYPOINT", "", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\entrypoints\\entrypoint.c"

BEGIN FILE "FILE_INIT", "GROUP_SYSTEM", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\init\\init.c"
327, PRINTN, "FIQ Stack Had %d free"
346, ASSERTC, "SVC Stack Bounds Incorrect!"
348, ASSERTC, "FIQ Stack Bounds Incorrect!"
349, ASSERTC, "ABT Stack Bounds Incorrect!"
350, ASSERTC, "IRQ Stack Bounds Incorrect!"
351, ASSERTC, "UND Stack Bounds Incorrect!"
355, PRINTN, "SVC Stack Size %d"
357, PRINTN, "FIQ Stack Size %d"
358, PRINTN, "ABT Stack Size %d"
359, PRINTN, "IRQ Stack Size %d"
360, PRINTN, "UND Stack Size %d"
434, PRINTN, " SVC has %d free "
447, PRINTN, " FIQ has %d free "
453, PRINTN, " ABT has %d free  "
459, PRINTN, " IRQ has %d free "
465, PRINTN, " UND has %d free "
495, WARN2N, "Mismatched Chip Type: %(ChipType), HWV File: %(HwvCpuType)"
END FILE "FILE_INIT", "GROUP_SYSTEM", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\init\\init.c"

BEGIN FILE "FILE_MBBUGDISP", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\debug\\MbBugdisp.c"
75, PRINTN, "Adding multi-buffer bugdisp buffer %d"
78, WARN, "Invalid buffer index, request ignored"
82, WARNN, "Already configured to use buffer at %p for this index, request ignored"
END FILE "FILE_MBBUGDISP", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\debug\\MbBugdisp.c"

BEGIN FILE "FILE_TASK_CALL", "GROUP_TASKS", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\utils\\task_call.c"
164, WARNN, "Task call count overflow: %d"
217, WARNN, "Task call count overflow: %d"
329, WARNN, "Task %(TaskID) is remote.  Remote task calls not supported"
393, WARNN, "Cannot register tcb: 0x%x.  Task registry full"
422, WARNN, "Tcb 0x%x not registered for calls"
480, PRINT2N, "Task timer %d assigned to %(fileid)"
482, PRINT2N, "Task timer %d assigned to %(DEVICE)"
518, PRINT, "TaskTimerCallback ignored during catfail"
578, WARNN, "Task %(TaskID) is remote.  Remote task calls not supported"
588, ASSERTC, "TaskCallLater invalid timer"
END FILE "FILE_TASK_CALL", "GROUP_TASKS", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\utils\\task_call.c"

BEGIN FILE "FILE_SRV_MESSAGE", "GROUP_OS_API", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\services\\srv_message.c"
59, WARNN, "OsPostLargeMessage: NULL argument passed (msg=0x%x)"
65, WARN, "OsPostLargeMessage requires a data pointer, use RimPostMessage for messages that fit into the structure data."
70, PRINT5N, "OsPostLargeMessage: ToTask=0x%x Device=%u Event=%u DataPtr=0x%08x Length=%u"
80, WARNN, "Cannot send large message to core %u, which does not support shared heaps"
86, PRINT, "OsPostLargeMessage: Sending remotely"
90, PRINT, "OsPostLargeMessage: Sending localy"
95, WARN2N, "Attempting to send a large message from core %d to core %d with an invalid heap handle"
107, WARNN, "OsPostLargeMessage: Block allocation failed with code %(GenericHeapErr_e)"
111, PRINT2N, "OsPostLargeMessage: Heap=0x%x Block=0x%x"
132, WARN, "OsPostLargeMessage: RimPostMessage() failed"
136, PRINT3N, "OsPostLargeMessage: Posted block handle 0x%x with size %u (result=%(OsError_t))"
154, WARNN, "OsFreeLargeMessage: NULL argument passed (msg=0x%x)"
163, WARNN, "DequeueLargeMessage failed with error %(Error_t)"
172, WARN, "OsFreeLargeMessage: Kernel message differs from user copy"
173, WARN3N, "Kernel: Device=0x%x Event=0x%x SubMsg=0x%x"
175, WARN3N, "User: Device=0x%x Event=0x%x SubMsg=0x%x"
182, WARNN, "OsFreeLargeMessage: Failed to free block handle 0x%x"
187, PRINTN, "OsFreeLargeMessage: Freed block handle 0x%x"
216, WARN3N, "handleGetLargeMessage: Detected a non-freed large message (Device=0x%x Event=0x%x SubMsg=0x%x)"
224, WARN3N, "handleGetLargeMessage: Failed to acquire ownership for a large message heap block (Device=0x%x Event=0x%x SubMsg=0x%x"
250, WARN, "OsGetMessageWithTimeout received a NULL pointer"
263, WARN, "OsGetMessageWithTimeout failed to create a timer"
272, WARN, "OsGetMessageWithTimeout failed to start timer"
END FILE "FILE_SRV_MESSAGE", "GROUP_OS_API", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\services\\srv_message.c"

BEGIN FILE "FILE_SRV_THREAD", "GROUP_OS_API", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\services\\srv_thread.c"
36, WARNN, "RimSleep called from LR=%p"
46, PRINTN, "Acquired task sleep timer %d"
60, PRINT2N, "Got Message: Device %i, Event %i"
END FILE "FILE_SRV_THREAD", "GROUP_OS_API", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\services\\srv_thread.c"

BEGIN FILE "FILE_LDRBLOCKS", "GROUP_SYSTEM", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\memory\\ldrblocks.c"
204, PRINT3N, "loadLdrDataFromFlash: totalLen=%d, srcID=%d, nextLdrInFlash=%d"
206, PRINT3N, "loadLdrDataFromFlash: curFlashPage=%d bytesRemainingInLdr=%d, bufferOffset=%d"
208, PRINT2N, "loadLdrDataFromFlash: pageBuffer=0x%X,byteRemaniningInBuffer=%d "
217, WARN, "Error reading next page"
250, WARN, "Error reading next page"
261, WARN3N, "Broken ldr chain for srcID 0x%X. Next srcID = 0x%X and next byteCount = 0x%X"
290, WARNN, "Error in LDR block, still have 0x%X bytes left although the totalLen is zero"
297, PRINT2N, "loadLdrDataFromFlash: returning 0x%X bytes at 0x%X"
298, PRINT4N, "(1)=0x%X, (2)=0x%X, (3)=0x%X, (4)=0x%X"
299, PRINT4N, "(5)=0x%X, (6)=0x%X, (7)=0x%X, (8)=0x%X"
345, WARN, "MCT_INSTALLER_NAND not found"
354, WARN, "MCT_OS_NAND not found"
373, PRINT2N, "First word is 0x%X, maxlength is 0x%X"
379, PRINTN, "Checking 0x%X"
383, PRINT3N, "Addr=0x%X, byteCount=0x%X, flag=0x%X"
395, WARN, "Please increase MAX_ON_DEMAND_LDR_BLOCKS"
455, WARNN, "Can not find OnDemadLDRBlock id 0x%X"
466, WARN, "Error reading flash page"
475, WARN, "Error reading flash page"
483, WARN, "Error reading flash page"
498, WARNN, "Error getting LZMA properties for OnDemandLDRBlk 0x%X"
507, WARN, "Compressed LDR sections not supported in this build"
567, WARNN, "Can not find OnDemadLDRBlock id 0x%X"
577, WARN2N, "Not enough memory provided for flash buffer, provided size = %d, need %d"
591, WARN2N, "Not enough memory provided for flash buffer, provided size = %d, need %d"
604, WARNN, "Not enough memory to allocate page buffer for OnDemandLDRBlk 0x%X"
616, WARN, "Error reading first flash page"
634, WARN, "Error reading first flash page"
646, PRINT3N, "Loaded compressed OnDemandLDR block address=0x%X, byteCount=0x%X, flag=0x%X"
648, PRINT3N, "Loaded OnDemandLDR block address=0x%X, byteCount=0x%X, flag=0x%X"
659, WARN, "Compressed LDR sections not supported in this build"
672, WARN2N, "Not enough memory provided for dst buffer, provided size = %d, need %d"
681, WARNN, "Not enough memory to allocate output buffer for OnDemandLDRBlk 0x%X"
687, WARNN, "Error getting LZMA properties for OnDemandLDRBlk 0x%X"
697, PRINTN, "Found a compressed section for 0x%X"
698, PRINT2N, "totalLen = 0x%X, uncompressedLen = 0x%X"
699, PRINTN, "probsLen = 0x%X"
703, WARN2N, "Not enough memory provided for Probs buffer, provided size = %d, need %d"
715, WARNN, "Not enough memory to allocate probsLen for OnDemandLDRBlk 0x%X"
725, WARNN, "Error decompressing for OnDemandLDRBlk 0x%X"
745, WARN2N, "Not enough memory provided for dst buffer, provided size = %d, need %d"
754, WARNN, "Not enough memory to allocate output buffer for OnDemandLDRBlk 0x%X"
761, WARNN, "Error reading data for OnDemandLDRBlk 0x%X"
END FILE "FILE_LDRBLOCKS", "GROUP_SYSTEM", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\memory\\ldrblocks.c"

BEGIN FILE "FILE_ARM7_HANDLER", "", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\entrypoints\\arm7_handler.c"
64, WARNN, "Jump to Zero detected; last call from %p"
88, WARNN, "Re-entrance to mode %(PSR_Mode): SP/LR at time of exception lost"
148, WARN2N, "Undefined Thumb instruction %08X at %p"
159, PRINT3N, "Bounced VFP CP# %d instruction %08X from %p"
180, PRINT2N, "Thread %(TaskID) blocked, next task %(TaskID)"
195, WARNN, "Thread %(TaskID) uses FPU when it's disabled"
201, WARN4N, "Undefined CP# %d instruction %08X at %p unhandled with %(VFP_RET)"
213, WARN3N, "Undefined CP# %d instruction %08X at %p"
218, WARN2N, "Undefined ARM instruction %08X at %p"
329, WARNN, "TLB miss fault at %p"
333, WARNN, "Alignment fault at %p"
336, WARNN, "Instruction Cache Maintenance Operation fault at %p"
340, WARNN, "External abort (first level) on translation fault at %p"
344, WARNN, "External abort (second level) on translation fault at %p"
348, WARNN, "Translation fault (section) at %p"
351, WARNN, "Translation fault (page) at %p"
355, WARNN, "Precise External Abort fault at %p"
358, WARNN, "Domain fault (section) at %p"
361, WARNN, "Domain fault (page) at %p"
364, WARNN, "Permission fault (section) at %p"
367, WARNN, "Permission fault (page) at %p"
370, WARN, "Lock abort fault"
373, WARN, "Imprecise External Data Abort fault"
376, WARN, "Data Cache Parity Error Exception fault"
379, WARN, "Coprocessor Data Abort fault"
383, WARNN, "Data Breakpoint abort (fsr 0x%08X). Debug exception when read/write to address"
385, WARNN, "0x%08X in breakpoint 1"
388, WARNN, "0x%08X in breakpoint 2"
393, WARN2N, "Unknown abort, fsr is 0x%08X, far is %p"
459, WARN, "Instruction Cache Parity Error Exception"
462, WARN, "External Instruction Error Exception"
486, WARN, "Instruction MMU Exception"
498, WARNN, "Instruction Breakpoint abort (fsr 0x%08X). Debug exception when jump to address"
500, WARNN, "0x%08X in breakpoint 1"
502, WARNN, "0x%08X in breakpoint 2"
506, WARNN, "Unknown Prefetch Exception, fsr is 0x%08X"
562, WARN, "Mem corrupt on interrupt"
END FILE "FILE_ARM7_HANDLER", "", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\entrypoints\\arm7_handler.c"

BEGIN FILE "FILE_COREMISC_ARM7", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\arm7_misc.c"
28, PRINT3N, "R0=0x%08X     R1=0x%08X     R2=0x%08X"
31, PRINT3N, "R3=0x%08X     R4=0x%08X     R5=0x%08X"
34, PRINT3N, "R6=0x%08X     R7=0x%08X     R8=0x%08X"
37, PRINT3N, "R9=0x%08X     R10=0x%08X    R11=0x%08X"
40, PRINT3N, "R12=0x%08X    SP=0x%08X     LR=%p"
43, PRINT2N, "PC=%p     SR=0x%08X"
45, PRINT4N, "D0= 0x%08X %08X  D1= 0x%08X %08X"
49, PRINT4N, "D2= 0x%08X %08X  D3= 0x%08X %08X"
53, PRINT4N, "D4= 0x%08X %08X  D5= 0x%08X %08X"
57, PRINT4N, "D6= 0x%08X %08X  D7= 0x%08X %08X"
61, PRINT4N, "D8= 0x%08X %08X  D9= 0x%08X %08X"
65, PRINT4N, "D10=0x%08X %08X  D11=0x%08X %08X"
69, PRINT4N, "D12=0x%08X %08X  D13=0x%08X %08X"
73, PRINT4N, "D14=0x%08X %08X  D15=0x%08X %08X"
77, PRINT2N, "FPSCR= 0x%08X FPEXC=  0x%08X"
78, PRINT2N, "FPINST=0x%08X FPINST2=0x%08X"
100, WARNN, "IsMemoryCorrupt: usbmsSem.initState=0x%x"
END FILE "FILE_COREMISC_ARM7", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\arm7_misc.c"

BEGIN FILE "FILE_PROC_INTCTRL", "GROUP_HW_IO", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\mmp2_intctrl.c"
199, WARNN, "Last IRQ num: %08x"
214, WARN2N, "Spurious DMA IRQ: %08x (%08x)"
237, WARN2N, "Spurious INT4 IRQ: %08x (%08x)"
260, WARN2N, "Spurious INT5 IRQ: %08x (%08x)"
283, WARN2N, "Spurious INT17 IRQ: %08x (%08x)"
306, WARN2N, "Spurious INT35 IRQ: %08x (%08x)"
329, WARN2N, "Spurious INT51 IRQ: %08x (%08x)"
409, WARNN, "Spurious IRQ: %08x"
410, WARN2N, "  FIQ0 Status: %08x %08x"
413, WARN2N, "  IRQ0 Status: %08x %08x"
416, WARN2N, "  IRQ1 Status: %08x %08x"
419, WARN2N, "  IRQ2 Status: %08x %08x"
706, WARN, "No ISR profiling"
END FILE "FILE_PROC_INTCTRL", "GROUP_HW_IO", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\mmp2_intctrl.c"

BEGIN FILE "FILE_TAVOR_GPIO", "GROUP_HW_IO", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\gpio\\tavor_gpio.c"
305, WARN, "MFPR_REG32: invalid BSO, No register. This is BAD."
729, WARN, "MFPR_REG32: invalid BSO, No register. This is BAD."
827, WARN, "GPIO int - no interrupt"
898, WARN2N, "Invalid: PadSet( %d, %d )"
967, WARN2N, "Invalid: PadClear( %d, %d )"
1041, WARN2N, "Invalid: PadRead( %d, %d )"
1071, WARN2N, "Invalid: PadSetMode( %d, %d )"
1121, WARN2N, "Invalid: PadInterruptConfigure( %d, %d )"
1136, WARN2N, "Invalid Line: PadRegisterIntHandler( %d, 0x%x )"
1184, WARNN, "level high interrupts not supported %d"
1188, WARNN, "level low interrupts not supported %d"
1203, WARNN, "Invalid: PadInterruptEnable( %d )"
1223, WARNN, "Invalid: PadInterruptDisable( %d )"
1254, WARNN, "Invalid: PadInterruptClear( %d )"
1453, PRINT, "TavorFlashConfigPadDrive Starting..."
1613, PRINT, "TavorFlashConfigPadDrive Complete."
1621, PRINT, "NO USB, Therefore Do Nothing."
1636, PRINT, "TavorUSBConfigPadDrive Starting..."
1661, PRINT, "TavorUSBConfigPadDrive Complete."
1755, ASSERT, "Can't configure line as both output and GPIRQ!"
1777, WARN, "Interrupt Debounce Not Available"
1796, WARNN, "Invalid PadConfigure line %d"
2619, PRINTN, "setting MCLK drive strength %(PadDriveStrengthSlewRate)"
END FILE "FILE_TAVOR_GPIO", "GROUP_HW_IO", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\gpio\\tavor_gpio.c"

BEGIN FILE "FILE_PROC_RTC", "", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\tavor_rtc.c"
105, PRINTN, "Already using accurate 32kHz clock from TXTAL_IN 0x%x"
110, PRINT, "Waiting for TXTAL_IN to be stable"
115, PRINT, "Waiting for switch TXTAL_IN to be complete"
118, PRINT, "Switch complete!"
END FILE "FILE_PROC_RTC", "", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\tavor_rtc.c"

BEGIN FILE "FILE_PROC_MISC", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\tavor_misc.c"
74, ASSERTFN, "IPC Error: %d"
233, WARN, "Not enabling watchdog for jtag build"
235, PRINT, "Enabling tavor watchdog"
323, WARNN, "DSPInit is failing, skipping LDRBlockAddr=%X"
340, PRINTN, "InternalDspInit: LDR Blocks @ 0x%08x"
355, PRINT, "IPC sender registered"
401, PRINT2N, "Core %d brought up after %d retries"
403, WARN2N, "Core %d failed to initialize with flag %(DspBootFailure)"
414, WARN, "Comms Watchdog!"
434, WARN, "Comms subsystem already started"
466, PRINTN, "Core %d is alive."
476, PRINTN, "All cores alive after %d retries"
480, WARN, "Some cores didn't start, retrying..."
494, WARN3N, "Core %d has a shared memory size inconsistency (%d != %d)"
512, PRINT, "Memory init complete, waiting for arm9 rtc calibration"
530, PRINT, "Started Comms subsystem"
564, WARN, "Timed out waiting for ARM9 to ack shutdown signal"
579, PRINT, "Stopped Comms subsystem"
581, WARN, "Comms subsystem already stopped"
END FILE "FILE_PROC_MISC", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\tavor_misc.c"

BEGIN FILE "FILE_PROC_RESET", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\reset\\tavor_reset.c"
77, PRINT, "Reset from user initiated soft reset or hard reset"
82, PRINT, "Reset from unexpected reset (reported as watchdog reset)"
85, PRINT, "Reset from short power lost"
89, PRINT, "Reset from unexpected reset (could be short power lost or watchdog)"
93, PRINT, "Boot from scratch"
110, PRINT, "ResetHwInit: hardware reset cause"
113, PRINT, "GPIO Reset"
116, PRINT, "Low Power Mode Reset"
119, PRINT, "WDT Reset"
122, PRINT, "Power-On Reset"
148, PRINTN, "ResetHwGetOverrides: Checking bootrom, metrics version 0x%08X"
178, PRINT, "ResetHwGetOverrides: Rev4+ hard reset OK"
181, PRINT, "ResetHwGetOverrides: Rev3 or earlier, only soft reset"
200, PRINT, "ResetHwSoft: Asserting FAST_RST_N line"
205, PRINT, "ResetHwSoft: Asserting GPIO software reset"
237, PRINT, "ResetHwHard: asserting FORCE_RST_N reset line"
245, PRINT, "ResetHwHard: asserting FORCE_RST reset line"
251, PRINT, "ResetHwHard: forcing a watchdog reset"
256, PRINT, "ResetHwHard: forcing a watchdog reset"
284, PRINTN, "PersistentData.version = %08X"
286, PRINTN, "PersistentData.flags = %08X"
END FILE "FILE_PROC_RESET", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\reset\\tavor_reset.c"

BEGIN FILE "FILE_RTC", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\rtc.c"
167, WARN, "RimTicksToRtc overflow!"
187, WARN, "RimGetTicks: Deprecated API called!"
248, PRINT, "Checking RTC consistency"
261, WARN3N, "  %u - %u = %u"
265, WARN2N, "Progressed abnormally %u/%u ticks"
268, PRINTN, "Progressed normally for %u ticks"
412, PRINT2N, "FREQ : nRTC=%d DIFF=%d Hz"
413, PRINT3N, "DELTA: RTC=0x%08X FRC=0x%08X%08X"
END FILE "FILE_RTC", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\rtc.c"

BEGIN FILE "FILE_PROC_TIMER", "", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\tavor_timer.c"
134, PRINTN, "FindEarliest rtc=%08x"
139, PRINT3N, "  %d: %d %08x"
152, PRINT2N, "  returns %08x (delta = %08x)"
180, PRINT2N, "at %08x, match register set to %08x"
193, WARNN, "Unknown timer interrupt fired, STAT=0x%08x"
199, PRINTN, "timerInterruptHandler(), STAT=0x08%x"
211, WARNN, "Unknown timer interrupt fired, OSSR=0x%08X"
215, PRINTN, "timerInterruptHandler(), ossr = 0x%x"
225, PRINTN, "testing for matches at rtc=%08x"
236, PRINT, "RTC"
245, PRINT, "WATCHDOG"
252, PRINT, "TIMESLICE"
260, PRINT, "NTIMERS"
269, PRINT, "DVFM"
278, PRINT, "WAKEUP"
303, PRINT3N, "SetHWTimer( %d, %08x ) @ %08x"
338, WARNN, "Attempt to start unimplemented timer %d"
373, PRINT2N, "StopHWTimer(%d) @ %08x"
403, WARNN, "Attempt to stop unimplemented timer %d"
427, WARNN, "RegisterTimerExpiry called for timer %d"
436, PRINT, "Enabling Tavor HW timers"
END FILE "FILE_PROC_TIMER", "", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\tavor_timer.c"

BEGIN FILE "FILE_TIMEDSEMAPHORES", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\critical\\timedsemaphores.c"
141, ASSERTC, "AddNodeToList:  list is null pointer."
142, ASSERTC, "AddNodeToList:  tsem is null pointer."
149, PRINT3N, "AddNodeToList:  [0x%8.8x] sem 0x%08x to expire @ 0x%x added to ACTIVE list"
151, PRINT2N, "AddNodeToList:  [0x%8.8x] sem 0x%08x added to IDLE list"
192, PRINT3N, "AddNodeToActiveListByExpiry: [0x%8.8x] sem 0x%08x to expire @ 0x%x added to ACTIVE list"
218, ASSERTC, "RemoveNodeFromList:  list is NULL pointer."
225, PRINT3N, "RemoveNodeFromList: [0x%8.8x] sem 0x%08x removed from ACTIVE list @ 0x%x"
227, PRINT2N, "RemoveNodeFromList: [0x%8.8x] node POPPED from IDLE list @ 0x%x "
244, WARN, "RemoveNodeFromList:  Semaphore not found."
286, WARN, "AllocateSemaphoreTimer:  Failed to allocate memory."
291, PRINT2N, "AllocateSemaphoreTimer: [0x%8.8x] sem 0x%08x timed header allocated."
317, PRINT2N, "TimedSemaphoreStartTimer:  Starting timer for delta 0x%x [@0x%x]"
326, ASSERTF, "TimedSemaphoreStartTimer:  Failed to start Semaphore timer"
382, WARN, "Failure to properly initialize SemaphoreTimer list"
387, PRINT, "TimedSemaphoresInit: TimedSemaphore init completed"
413, ASSERTC, "ExpireTimedSemaphores:  Called by incorrect task!"
433, PRINTN, "EXPIRY: CURRENT TIME = 0x%x"
448, WARN3N, "ExpireTimedSemaphore: [0x%8.8x] sem 0x%08x expired! [@0x%x]"
461, WARNN, "ExpireTimedSemaphore: [0x%x] timeout of ALREADY signalled semaphore"
471, PRINT3N, "ExpireTimedSemaphore:  [0x%8.8x] unlocking 0x%08x [@0x%x]"
477, WARNN, "ExpireTimedSemaphore: [0x%x] null pointer to Semaphore"
489, PRINT3N, "ExpireTimedSemaphore: [0x%8.8x] restarting timer for 0x%x [@0x%x]"
498, PRINT3N, "ExpireTimedSemaphore: [0x%8.8x] restarting timer for 0x%x [@0x%x] (wrapping)"
506, WARN, "ExpireTimedSemaphore:       No semaphores active."
546, ASSERTC, "LockTimedSemaphore:  sem is NULL pointer."
549, ASSERTC, "RimLockCountingSemaphoreWithTimeout:  Called by TIMER task!"
553, WARN, "RimLockCountingSemaphoreWithTimeout: Attempt to use TimedSemaphore prior to Init."
573, PRINT2N, "LockTimedSemaphore:  sem 0x%08x locking (exp 0x%x)"
590, WARN, "RimLockCountingSemaphoreWithTimeout: failure to allocate from static list"
600, PRINTN, "RimLockCountingSemaphoreWithTimeout: CURRENT TIME = 0x%8.8x"
615, PRINTN, "RimLockCountingSemaphoreWithTimeout: START THE TIMER(wrapped) 0x%x"
618, PRINTN, "RimLockCountingSemaphoreWithTimeout: START THE TIMER 0x%x"
639, PRINTN, "RimLockCountingSemaphoreWithTimeout: RESTART THE TIMER(wrapped) 0x%x"
642, PRINTN, "RimLockCountingSemaphoreWithTimeout: RESTART THE TIMER 0x%x"
649, WARN, "RimLockCountingSemaphoreWithTimeout: failed to dynamically find a SemaphoreTimer"
666, PRINT3N, "RimLockTimedSemaphore:  [0x%8.8x] sem 0x%08x locking [@0x%x]."
674, PRINT3N, "LockTimedSemaphore:  [0x%8.8x] sem 0x%08x locked [@0x%x]."
689, PRINT, "RimLockCountingSemaphoreWithTimeout: NOT in the ACTIVE list"
739, PRINT3N, "LockTimedSemaphore: [0x%8.8x] return %d [@0x%x]."
766, PRINTN, "DEBUG: setting timeout (exp 0x%x)"
783, WARN, "TsemDebugTimers: failure to allocate from static list"
793, PRINTN, "TsemDebugTimers: CURRENT TIME = 0x%8.8x"
808, PRINTN, "TsemDebugTimers: START THE TIMER(wrapped) 0x%x"
811, PRINTN, "TsemDebugTimers: START THE TIMER 0x%x"
832, PRINTN, "RimLockCountingSemaphoreWithTimeout: RESTART THE TIMER(wrapped) 0x%x"
835, PRINTN, "RimLockCountingSemaphoreWithTimeout: RESTART THE TIMER 0x%x"
842, WARN, "TsemDebugTimers: failed to dynamically find a SemaphoreTimer"
END FILE "FILE_TIMEDSEMAPHORES", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\critical\\timedsemaphores.c"

BEGIN FILE "FILE_FREQCHANGE_COMMON", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\freqchange.c"
180, PRINTN, "Sending volt change request of %d mV"
188, PRINT2N, "Sending msg request to change core #%d voltage to %d"
235, PRINT2N, "sending message request to change core #%d voltage to %d"
248, WARNN, "Unhandled frequency change cmd: %d"
END FILE "FILE_FREQCHANGE_COMMON", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\freqchange.c"

BEGIN FILE "FILE_FREQCHANGE", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\tavor_freqchange.c"
194, WARN2N, "performing queued frequency change @ %u (block index=%(___FrequencyChangeBlocker))"
214, PRINTN, "Disabling DVFM in due to %(FrequencyChangeMaxer)"
223, PRINTN, "Re-enabling DVFM due to %(FrequencyChangeMaxer)"
240, PRINTN, "Waited for frequency kick %[%.1f/32.768]ms in FrequencyChangeWaitMax"
335, WARNN, "updateCoreFreqPmTicks: Invalid core %u"
350, PRINT2N, "UpdatingCore %d Frequency to %d"
367, PRINT2N, "Receiving request %(_DDR_FREQUENCY_REQUEST) from Radio, queuedFrequency=%(_CoreFrequence) "
389, WARN, "DDR minimum frequency request is not supported"
466, WARNN, "GetTotalCoreStateTicks: Invalid sleepLevel %u"
530, PRINT2N, "Frequency is already %(_CoreFrequence) (queued=%[%u/1000000]), no change necessary"
538, WARN, "Unsupported frequency"
552, WARN3N, "queued frequency change to %(_CoreFrequence) @ %u (blockMask=0x%X)"
569, PRINT, "Intermediate frequency change successful (exited single PLL mode)"
595, PRINT2N, "profile mark 0: %[%.2f/#*1000000] us"
625, PRINT2N, "App core frequency change done from %(_CoreFrequence) to %(_CoreFrequence)"
642, PRINT2N, "profile mark 1: %[%.2f/#*1000000] us"
654, PRINT2N, "profile mark 2: %[%.2f/#*1000000] us"
672, PRINT2N, "profile mark 3: %[%.2f/#*1000000] us"
686, PRINT2N, "profile mark 4: %[%.2f/#*1000000] us"
695, PRINTN, "DDR is %X, not changing for Z1"
698, PRINT2N, "DDR was %X now is %X"
717, PRINT2N, "profile mark 5: %[%.2f/#*1000000] us"
738, PRINT2N, "profile mark 6: %[%.2f/#*1000000] us"
751, PRINT2N, "profile mark 7: %[%.2f/#*1000000] us"
773, WARN, "Timeout waiting for GB PLL off"
782, PRINT2N, "profile mark 8: %[%.2f/#*1000000] us"
801, PRINT2N, "profile mark 9: %[%.2f/#*1000000] us"
808, PRINT2N, "Frequency change took %[%.2f/#*1000000] us"
834, PRINT2N, "Frequency Changed by Comms to: DSP=%(_CoreFrequence), Radio=%(_CoreFrequence)"
918, PRINTN, "TavorPV ACCR register value: 0x%08x"
END FILE "FILE_FREQCHANGE", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\tavor_freqchange.c"

BEGIN FILE "FILE_USBREQ", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\usbreq.c"
164, ASSERTF, "UsbNoPortCatfailNoArgs()"
169, ASSERTF, "UsbNoPortStallPipe()"
174, ASSERTF, "UsbNoPortUnStallPipe()"
179, ASSERTF, "UsbNoPortSetForceStall()"
183, ASSERTF, "UsbNoPortControlSend()"
188, ASSERTF, "UsbNoPortDumpRegisters()"
192, ASSERTF, "UsbDrvDummyChanArg()"
197, ASSERTF, "UsbDrvInitChannel()"
203, ASSERTF, "UsbDrvSetupOutPipe()"
209, ASSERTF, "UsbDrvSetupInPipe()"
215, ASSERTF, "UsbDrvDummyBYTEArgBYTERet()"
222, ASSERTF, "SetPeripheralState()"
384, ASSERT, "Invalid BSN, device won't provide a serial number"
387, PRINT, "Calculating/Caching device GUID"
425, ASSERT, "Invalid BSN, device won't provide a serial number"
429, PRINT, "Calculating/Caching device GUID"
445, ASSERT, "Invalid BSN, device won't provide a serial number"
448, PRINTN, "Read BSN is (%x)"
451, PRINT, "Calculating/Caching device GUID"
517, PRINTN, "UsbSetChargerRate(0x%02x): requested rate = NONE Specified!"
519, PRINT2N, "UsbSetChargerRate(0x%02x): requested rate = %(USB_POWER)"
521, PRINT3N, "UsbSetChargerRate(0x%02x): requested rate = %(USB_POWER), %(USB_POWER) "
524, PRINT4N, "UsbSetChargerRate(0x%02x): requested rate = %(USB_POWER), %(USB_POWER), %(USB_POWER)  "
527, WARN, "UsbSetChargerRate(): unexpected number of concurrent states"
528, PRINT4N, "UsbSetChargerRate(0x%02x): requested rate = %(USB_POWER), %(USB_POWER), %(USB_POWER)  "
536, WARN, "   No cable, forcing charger off"
552, PRINT, "   Unable to turn off charger in unsafe connection state"
584, PRINT, "   usbState -> I_USB_RESET_STATE"
586, PRINTN, "   usbState -> %(EVENT)"
588, PRINT2N, "   usbState -> %(EVENT), %(EVENT)"
590, PRINT3N, "   usbState -> %(EVENT), %(EVENT), %(EVENT)"
593, PRINT4N, "   usbState -> %(EVENT), %(EVENT), %(EVENT), %(EVENT)"
597, WARN, "usbStateDump: unexpected number of concurrent states"
598, PRINT4N, "   usbState -> %(EVENT), %(EVENT), %(EVENT), %(EVENT)"
678, WARN, "setState SET I_USB_CONFIGURED: I_USB_SETUP_PACKET_RECEIVED must be set prior"
682, WARN, "setState SET I_USB_CONFIGURED: I_USB_CABLE_IN must be set prior"
692, PRINT, "setState SET I_USB_SETUP_PACKET_RECEIVED: already I_USB_CONFIGURED"
696, WARN, "setState SET I_USB_SETUP_PACKET_RECEIVED: I_USB_CABLE_IN must be set prior"
705, WARN, "setState SET I_USB_CABLE_IN : should be in I_USB_RESET_STATE before I_USB_CABLE_IN"
714, PRINT, "setState SET I_USB_PORT_SUSPEND: I_USB_CONFIGURED must be set prior"
719, WARNN, "setState: Invalid state : %(EVENT), not setting this state"
723, PRINTN, "setState: Already in state %(EVENT)"
730, WARN, "setState CLR I_USB_RESET_STATE: not possible to clear this state"
746, WARN, "setState CLR I_USB_PORT_SUSPEND: port is not CONFIGURED"
750, WARNN, "setState: Invalid state : %(EVENT), not clearing this state"
754, PRINTN, "setState: Already not in state %(EVENT)"
758, PRINT3N, "setState: request -> %(EVENT), SET/nCLEAR=%d => PASS/nFAIL=%d"
760, WARN3N, "setState: request -> %(EVENT), SET/nCLEAR=%d => PASS/nFAIL=%d"
769, WARN, "Toogle Verbosity: not supported any more use 'x LV.L14,#' command"
820, PRINT, "getDescriptor: DEV_QUAL when forced to full-speed. Stalling control pipe"
851, ASSERTF, "getDescriptor(): 0-length descriptor generating!"
875, PRINT4N, "setConfiguration(%d) at frame %d, curMode=%(USB_MODES), newMode=%(USB_MODES)"
920, WARN, "SET_CONFIG to 0"
962, PRINT, "I_USB_HOST_PWR_WARN: Charging source is running out of battery!"
1092, PRINT2N, "setFeature(): SET_FEATURE (wValue=0x%X; wIndex=0x%X)"
1140, PRINTN, "clearFeature(0x%x): "
1147, PRINT2N, "RimUsb ClearFeature chan=%d, dir=%d"
1164, PRINT2N, "RimUsb ClearFeature chan=%d, dir=%d"
1252, PRINT4N, "USBTask: Host Versions: vid %x, pid %x, OS Version %x, Driver Version %x"
1292, PRINT, "setupPacket: calling RimUsbHandleVdrReq"
1346, PRINT, "setupPacket: Received SETUP packet, it is SAFE to turn off the charger"
1348, PRINT2N, "   bmRequestType=0x%X, bRequest=%(USB_SETUP2)"
1350, PRINT2N, "   bmRequestType=0x%X, bRequest=%(USB_SETUP)"
1351, PRINT3N, "   wValue=0x%X, wIndex=0x%X, wLength=0x%X"
1393, ASSERTF, "Invalid configuration index"
1399, PRINTN, "   USB REQUEST(0X%X) not Recognized by RimUsbHandleStdReq"
1418, PRINTN, " Rim USB Handle vendor request %X"
1430, PRINTN, "   USB_SET_CHARGER: MaxUsbPower set to %x"
1441, PRINT, "   USB_PERIPHERAL_PRESENT:  Peripheral present (disabling charger)"
1456, PRINT, "   USB_GET_RIM_STATUS: RIM Vendor USB Drivers are installed on this host"
1493, PRINT2N, "   USB_SET_DEV_MODE: current Mode=%(USB_MODES), requested Mode=%(USB_MODES)"
1509, PRINT2N, "   USB_SET_DEV_MODE: Setting new mode to %(USB_MODES) (speed = %(USB_SPEEDS))"
1515, WARN2N, "   USB_SET_DEV_MODE:The combination mode=%(USB_MODES), speed=%(USB_SPEEDS) is not supported."
1521, PRINT2N, "   USB_SET_DEV_MODE: requested Mode=%(USB_MODES) is already set"
1544, PRINT, "   Got a USB_GET_MS_DESCRIPTOR request"
1555, PRINT2N, "   USB Host Capabilities mask %x value %x"
1561, PRINTN, "   USB REQUEST(0X%X) not Recognized by RimUsbHandleVdrReq"
END FILE "FILE_USBREQ", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\usbreq.c"

BEGIN FILE "FILE_USBDESC", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\usbdesc.c"
1056, WARN, "UsbGenerateDevDesc: Buffer too small for Device Descriptor"
1063, ASSERTFN, "UsbGenerateDevDesc: Bad current mode - %(USB_MODES)"
1072, ASSERTFN, "UsbGenerateDevDesc: Bad mode arg - %(USB_MODES)"
1076, ASSERTFN, "UsbGenerateDevDesc: Bad speed arg - %(USB_SPEEDS)"
1080, PRINT2N, "UsbGenerateDevDesc: Forced to mode %(USB_MODES), speed %(USB_SPEEDS)"
1132, WARNN, "UsbGenerateDevDesc: curDescState = 0x%x"
1162, WARN, "UsbGenerateDevQualDesc: Buffer too small for Device Descriptor"
1166, ASSERTFN, "UsbGenerateDevQualDesc: DEV_QUAL req for non-HIGH speed device (speed=%(USB_SPEEDS))"
1173, ASSERTFN, "UsbGenerateDevQualDesc: Bad current mode - %(USB_MODES)"
1181, ASSERTFN, "UsbGenerateDevQualDesc: Bad mode arg - %(USB_MODES)"
1184, PRINTN, "UsbGenerateDevQualDesc: Forced to mode %(USB_MODES)"
1237, WARN, "UsbGenerateCfgDesc: Buffer too small for Configuration Descriptor"
1244, ASSERTFN, "UsbGenerateCfgDesc: Bad current mode - %(USB_MODES)"
1252, ASSERTFN, "UsbGenerateCfgDesc: Bad mode arg - %(USB_MODES)"
1255, PRINT2N, "UsbGenerateCfgDesc: Forced to mode %(USB_MODES), descType=0x%x"
1416, PRINT3N, "UsbGenerateStrDesc(): idx=%d; langId=%d; size=%d"
1426, WARN, "UsbGenerateStrDesc: Buffer too small for Languages String Descriptor"
1433, PRINTN, "UsbGenerateStrDesc() returning (lang IDs): length = %d"
1441, WARN, "UsbGenerateStrDesc: Buffer too small for Manufacturer String Descriptor"
1456, PRINT2N, "strIdx, langId: 0x%x, 0x%x"
1505, WARN, "UsbGenerateStrDesc: Buffer too small for Product String Descriptor"
1519, WARN, "UsbGenerateStrDesc: Buffer too small for Serial Number String Descriptor"
1542, WARN, "UsbGenerateStrDesc: Buffer too small for Error String Descriptor"
1550, PRINTN, "UsbGenerateStrDesc() returning: length = %d"
1572, ASSERTFN, "RimUsbIsModeAvailable: Invalid mode - %d"
1576, ASSERTFN, "RimUsbIsModeAvailable: Invalid speed - %d"
1586, PRINT2N, "RimUsbIsModeAvailable: Mode %(USB_MODES) structure pointer is 0x%X"
1592, PRINT2N, "RimUsbIsModeAvailable: Mode supported at speed %(USB_SPEEDS) check = 0x%x"
1626, PRINT2N, "RimUsbIsModeEnabled - testing: mode=%(USB_MODES), speed=%(USB_SPEEDS)"
1681, PRINT2N, "RimUsbIsModeEnabled - settings enabled: mode=%(USB_MODES), speed=%(USB_SPEEDS)"
1708, WARN, "RimUsbSetMode():  Setting core speed to FS on a HS only device.  Forcing to HS"
1714, PRINT2N, "RimUsbSetMode(): Requested mode=%(USB_MODES), speed=%(USB_SPEEDS)"
1717, WARN, "RimUsbSetMode: Cannot set mode while device is enumerated"
1723, ASSERTFN, "RimUsbSetMode: Unsupported USB Speed: %(USB_SPEEDS)"
1727, WARN2N, "RimUsbSetMode: Mode specified is not available (mode=%(USB_MODES); speed=%(USB_SPEEDS))"
1729, WARN, "Forcing BBONLY, SPEED_FULL"
1746, WARN, "RimUsbSetMode: Device is locked to BB Only; required USB_MS/MTP_FLAG_ENABLE not set."
1753, PRINT2N, "RimUsbSetMode(): Granted mode=%(USB_MODES), speed=%(USB_SPEEDS)"
1792, PRINT, "RimUsbSetModeWithFallback: Forcing reqSpeed to FULL"
1796, PRINT, "RimUsbSetModeWithFallback: Antioch present but speed is FULL (not HIGH)."
1896, PRINT, "RimUsbToggleUsbFlags: USB Flags record doesn't exist. Creating it."
1898, WARNN, "RimUsbToggleUsbFlags: Unexpected size for the USB Flags record (%d bytes)"
1908, PRINTN, "RimUsbToggleUsbFlags: USB Flags set to 0x%x"
1912, WARN, "RimUsbToggleUsbFlags(): Platform doesn't support this call"
2101, PRINTN, "parseMSDescriptors: Ext MS interface is %d"
2106, WARN, "parseMSDescriptors: NO External MS Interface found."
END FILE "FILE_USBDESC", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\usbdesc.c"

BEGIN FILE "FILE_USBMUX", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\usbmux.c"
342, WARNN, "sendAuth2Failure: Invalid channel handle (%d)"
346, WARNN, "sendAuth2Failure: No channel registered with specified handle (%d)"
350, WARN2N, "sendAuth2Failure: Channel cannot be closed from current state (handle=%d; state=0x%x)"
355, PRINTN, "MUX: Authenticate failed on channel %x"
372, PRINTN, "MUX:  Channel %x NOT Closed!"
396, WARNN, "requestEncryption: Invalid channel handle (%d)"
400, WARNN, "requestEncryption: No channel registered with specified handle (%d)"
411, PRINT2N, "Host encryption version %d.%d not supported"
420, PRINTN, "Host does not support necessary encryption capabilities (%x)"
430, WARNN, "Channel %d is not in the correct state for encryption"
435, PRINT3N, "Host supports encryption version %d.%d (caps %x)"
465, PRINT, "Sending encryption challenge"
470, WARNN, "Challenge generation failed on channel %d"
518, PRINT, "UsbGetConnectionStatus: returning:"
521, PRINTN, " -> %(CONN_STAT_ENUM)"
532, PRINT, "UsbGetChannelParamInfo: NULL chanParams argument"
539, WARN, "UsbGetChannelParamInfo: Invalid ChannelParameters variable length"
544, PRINT, "UsbGetChannelParamInfo: Unsupported version"
559, PRINT, "MUX: UsbGetChannelOpen called"
562, WARNN, "UsbGetChannelOpen: Invalid channel handle (%d)"
566, WARNN, "UsbGetChannelOpen: No channel registered with specified handle (handle=%d)"
582, PRINTCOPY, "MUX: UsbRegisterChannel called (channel: %s)"
585, WARN, "UsbRegisterChannel: Invalid channel name"
590, WARN, "UsbRegisterChannel: Channel already registered"
595, WARN2N, "UsbRegisterChannel: Invalid maximum transmit or receive unit size (rcv: %d, trm: %d)"
602, WARN2N, "UsbRegisterChannel: Invalid maximum transmit or receive buffers (rcv: %d; trm: %d)"
610, WARN, "Invalid ChannelParameters variable length"
621, PRINT2N, "MUX: Registering Channel %x (%d)"
645, WARN, "UsbRegisterChannel: Too many channels registered"
689, PRINTN, "Dequeue from channel %d (tx) failed"
704, PRINTN, "Dequeue from channel %d (rx) failed"
710, PRINTN, "MUX: Closed Channel %x"
717, PRINT, "MUX: UsbDeRegisterChannel called"
719, WARNN, "UsbDeRegisterChannel: Invalid channel handle (%d)"
723, WARNN, "UsbDeRegisterChannel: No channel registered with specified handle (handle=%d)"
732, WARN2N, "UsbDeRegisterChannel: Channel must be de-registered by owner task (owner=0x%x; current=0x%x)"
745, PRINTN, "MUX: Deregistering channel %x"
793, WARNN, "UsbOpenChannel: Invalid channel handle (%d)"
798, WARNN, "UsbOpenChannel: No channel registered with specified handle (%d)"
804, WARN2N, "UsbOpenChannel: Specified channel isn't ready to be opened (handle=%d; state=0x%x)"
811, PRINTN, "MUX: Opened Channel %x"
862, PRINTN, "MUX:  Channel %x NOT opened!!!"
881, WARNN, "UsbCloseChannel: Invalid channel handle (%d)"
885, WARNN, "UsbCloseChannel: No channel registered with specified handle (%d)"
889, WARN2N, "UsbCloseChannel: Channel cannot be closed from current state (handle=%d; state=0x%x)"
894, PRINTN, "MUX: UsbCloseChannel %x"
924, PRINTN, "MUX:  Channel %x NOT Closed!"
937, WARNN, "UsbSendPacket: Invalid channel handle (%d)"
941, WARNN, "UsbSendPacket: No channel registered with specified handle (%d)"
945, WARN2N, "UsbSendPacket: Specified channel isn't open (handle=%d; state=0x%x"
950, WARN, "UsbSendPacket: Buffer provided is larger than Max TU"
951, WARN3N, "chan=%d, maxTU=%d, length=%d"
956, WARN, "Why are you sending a 0 length packet?"
960, WARN, "UsbSendPacket: Number of buffers is already equal to Max Transmit Buffers"
965, PRINTN, "MUX:  Channel %x packet not sent!"
981, PRINT2N, "UsbAddReceiveBuffer called with channelHandle: %d, length: %d"
987, WARNN, "UsbAddReceiveBuffer: Invalid channel handle (%d)"
991, WARNN, "UsbAddReceiveBuffer: No channel registered with specified handle (%d)"
996, WARN2N, "UsbAddReceiveBuffer: Channel is in invalid state for this call (handle=%d; state=0x%x)"
1001, WARN, "UsbAddReceiveBuffer: Buffer provided is smaller than Max Receive Unit"
1005, WARN, "UsbAddReceiveBuffer: Number of buffers is already equal to Max Receive Buffers"
1009, WARN, "UsbAddReceiveBuffer: Invalid buffer pointer or size"
1033, WARN2N, "MUX: Apps attempted to add buffer 0x%X, length 0x%X"
1034, WARN4N, "MUX: st_ram=0x%08x, end_ram=0x%08x, st_iram=0x%08x, end_iram=0x%08x"
1042, PRINTN, "MUX:  Channel %x -- receive buffer not added!"
1066, PRINTN, "MUX:  QOS Reply not sent -- out of nodes!"
1093, WARNN, "UsbGetBufferInfo: Invalid channel handle (%d)"
1097, WARNN, "UsbGetBufferInfo: No channel registered with specified handle (%d)"
1103, WARN2N, "UsbGetBufferInfo: Specified channel isn't open (handle=%d; state=0x%x)"
1117, WARNN, "UsbGetChannelParameters: Invalid channel handle (%d)"
1122, WARNN, "UsbGetChannelParameters: No channel registered with specified handle (%d)"
1144, WARNN, "UsbRedirectedPasswordChallenge: Invalid channel handle (%d)"
1148, WARNN, "UsbRedirectedPasswordChallenge: No channel registered with specified handle (%d)"
1153, WARNN, "UsbRedirectedPasswordChallenge: Channel state doesn't allow redictection (%d)"
1158, PRINT2N, "MUX: UsbRedirectedPasswordChallenge (chan 0x%x; open 0x%x)"
1213, PRINTN, "MUX:  Channel %x NOT Redirected Open!"
1267, WARNN, "UsbGetChannelName: Invalid channel handle (%d)"
1271, WARNN, "UsbGetChannelName: No channel registered with specified handle (%d)"
1276, WARN, "UsbGetChannelName: Invalid channelName buffer"
1312, PRINT, "UsbMuxOn: MUX Already On"
1322, PRINT, "UsbMuxOn: MUX turned on (calling UsbRead)"
1341, PRINT, "MUX: Turning UsbMuxOff"
1378, PRINT, "Offloading UNMOUNT_ALL not supported"
1391, PRINTN, "Waiting for UNMOUNT_ALL_DONE message @ %u"
1393, PRINTN, "Received UNMOUNT_ALL_DONE message @ %u"
1401, WARN, "MUX: Calling RESET_DEVICE"
1409, ASSERTF, "Maximum pwd attempts reached!"
1440, PRINTN, "PktSent: QOS Reply not sent -- out of nodes!"
1469, PRINT2N, "CHANNEL %d TIMESTAMP: UsbSendPacket %d"
1470, PRINT2N, "CHANNEL %d TIMESTAMP: sendNextPacket %d"
1471, PRINT2N, "CHANNEL %d TIMESTAMP: RimUsbInXferDone %d"
1472, PRINT2N, "CHANNEL %d TIMESTAMP: usbMuxPacketSent %d"
1484, PRINTN, "MUX: TxQueueing error -- attempting USB_PACKET_SENT on bad channel (%d)"
1501, PRINT, "UsbMuxPacketSent: DEVICE_FAILURE packet queued"
1568, WARN, "Received CODE_REJECT from the host (this should *never* happen!!!)"
1583, WARN3N, "ping error: at offset %d expected %02x got %02x"
1584, SHOW_MEMORY, "buffer:             "
1587, SHOW_MEMORY, "buffer: "
1724, PRINTN, "INFO Request/Reply OS Type set to: OS RAM Image (raw: %li)"
1728, PRINTN, "INFO Request/Reply OS Type set to: RIM Factory OS (raw: %li)"
1732, PRINTN, "INFO Request/Reply OS Type set to: RIM OS Installer (raw: %li)"
1736, PRINTN, "INFO Request/Reply OS Type set to: USB Bootrom (raw: %li)"
1740, PRINTN, "INFO Request/Reply OS Type set to: USB RAM Image (raw: %li)"
1744, PRINTN, "INFO Request/Reply OS Type set to: Catfailed (raw: %li)"
1748, PRINT, "INFO Request/Reply OS Type set to: Normal OS (raw: 0)"
1818, ASSERTCDEV, "INFO_REQUEST reply too large"
1831, PRINTCOPY, "OPEN_REQUEST for channel: %s"
1838, PRINT, "OPEN_REQUEST failed: Channel name not found"
1840, ASSERTF, "OPEN_REQUEST failed: allowOpens == FALSE!"
1844, PRINT, "OPEN_REQUEST failed: Attempt to open already opened channel"
1847, PRINTN, "OPEN_REQUEST failed: 0x%x channels alread open."
1858, PRINTN, "Channel Open REQ setting USB MS bit, usbFlags=0x%08x"
1862, PRINT, "OPEN_REQUEST success."
1922, PRINTN, "Maximum attempts is %d (a value greater than 255).  Using 255."
1926, PRINTN, "Remaining attempts is %d (a value greater than 255).  Using 255."
1994, WARN2N, "Not enough data passed to authentication response.  Expected %d got %d"
2116, PRINTN, "Maximum attempts is %d (a value greater than 255).  Using 255."
2120, PRINTN, "Remaining attempts is %d (a value greater than 255).  Using 255."
2243, ASSERTFN, "ERROR: Transfer length is larger than the buffer in which it was received! (length=%d)"
2250, ASSERTF, "Invalid USB MUX channel index"
2251, WARNN, "Last RX Channel = %d"
2252, WARNN, "Last RX Size = %d"
2253, SHOW_MEMORY, "UsbMuxGenericBuffer: "
2272, ASSERTF4N, "Packet received larger than MRU (chan=%d;MRU=%d;dstPtrSize=%d;lengthtoCopy=%d"
2329, WARN, "Received end-of-transfer but MUX transfer isn't complete. Continuing anyway..."
2367, ASSERTF4N, "EOP size is larger than expected (chan=%d;srcSize=%d;dstSize=%d;lengthtoCopy=%d)"
2418, ASSERTF3N, "non-EOP size is larger than expected (chan=%d;srcSize=%d;dstSize=%d)"
2467, PRINTN, "MUX: RxQueueing error -- attempting USB_PACKET_RECEIVED on bad channel (%d)"
2500, PRINT2N, "CHANNEL %d TIMESTAMP: UsbRead %d"
2501, PRINT2N, "CHANNEL %d TIMESTAMP: RimUsbOutXferDone %d"
2502, PRINT2N, "CHANNEL %d TIMESTAMP: usbMuxPacketReceived %d"
2544, PRINTN, "MUX: bad peek on channel %d TxQueue"
2736, PRINT, "** USB Queue Information********************************"
2739, PRINT2N, "First & last bufferNodes: 0x%x, 0x%x"
2746, PRINTCOPY, "Channel %s"
2747, PRINTN, " Tx Queue (size=%d):"
2749, PRINT, "  <empty>"
2753, PRINTN, "  0x%x"
2755, PRINTN, "Channel#0 Tx buffer address:0x%x"
2756, SHOW_MEMORY, "Channel#0 Tx buffer: "
2760, ASSERTFN, "Invalid TX Buffer! (j=%d)"
2767, PRINTN, " Rx Queue (size=%d):"
2769, PRINT, "  <empty>"
2773, PRINTN, "  0x%x"
2775, PRINTN, "Channel#0 Rx buffer address:0x%x"
2776, SHOW_MEMORY, "Channel#0 Rx buffer: "
2780, ASSERTFN, "Invalid RX Buffer! (j=%d)"
2789, PRINT, "--------------------------------------------------------"
2790, PRINT, "Free Nodes"
2796, PRINTN, "  0x%x"
2799, ASSERTFN, "Invalid free Buffer! (i=%d)"
2805, PRINTN, " Total Free Nodes = %d"
2808, PRINT, "********************************************************"
2817, WARN2N, "Error!! UsbMuxStatus(%d,0x%x)"
2843, PRINT, "UsbMuxCatfail: Closing all USB MUX channels"
2849, PRINTN, "... except %d"
2857, PRINT, "UsbMuxCatfail: Sending DEVICE_FAILURE packet to PC MUX"
2861, PRINT, "UsbMuxCatfail: DEVICE_FAILURE packet queued"
2863, PRINT, "UsbMuxCatfail: Catfail packet not sent!"
2883, PRINT, "** MUX info ********************************************"
2889, PRINTCOPY, "Channel %s"
2892, PRINT, "********************************************************"
2901, WARNN, "UsbEncryptChannel: Invalid channel handle (%d)"
2905, WARNN, "UsbEncryptChannel: No channel registered with specified handle (%d)"
2910, WARN2N, "UsbEncryptChannel: Channel not in proper state (%d state=%d)"
2916, WARN2N, "UsbEncryptChannel: Key size invalid! (%d max=%d)"
2945, WARNN, "UsbEncryptSetKeyName: Invalid channel handle (%d)"
2949, WARNN, "UsbEncryptSetKeyName: No channel registered with specified handle (%d)"
2954, WARN2N, "UsbEncryptSetKeyName: Channel not in proper state (%d state=%d)"
2958, WARN2N, "UsbEncryptSetKeyName: Channel not encrypted (%d encrypt=%d)"
2963, WARN2N, "UsbEncryptSetKeyName: Key name length invalid! (%d max=%d)"
2989, WARNN, "UsbEncryptSetKeyName: Invalid channel handle (%d)"
2993, WARNN, "UsbEncryptSetKeyName: No channel registered with specified handle (%d)"
3340, PRINTN, "Switching from %(USB_MODES) to USB_MODE_MSONLY"
3344, PRINTN, "Switching from USB_MODE_MSONLY to %(USB_MODES)"
3479, WARNN, "Unhandled device message. %d "
3488, PRINTN, "HP_MUX_Register Channel: %d"
3492, PRINTN, "HP_MUX_DeRegister Channel: %d"
3496, PRINTN, "HP_MUX_Open Channel: %d"
3501, PRINTN, "HP_MUX_Send Packet: %d"
3506, PRINTN, "HP_MUX_ADD_RECV_BUFF Packet: %d"
3509, WARNN, "Unhandled event. %d "
END FILE "FILE_USBMUX", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\usbmux.c"

BEGIN FILE "FILE_USB_MSG", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\usbmsg.c"
150, PRINT2N, "USBTask: I_USB_PORT_SUSPEND: Posted by file: %(fileid), line %d"
175, PRINT2N, "USBTask: I_USB_CONFIGURED: Posted by file: %(fileid), line %d"
256, PRINT2N, "USBTask: I_USB_ACK_SET_CONFIG: Posted by file: %(fileid), line %d"
295, PRINT, "   this is a non-suspended host!"
312, PRINT2N, "@@ %[%f/#*1000] ms from last system reset: Device is enumerated to USB Host"
318, PRINT, "   ACKing SET_CONFIG=0"
328, WARNN, "   Received SET_CONFIG for invalid index (%d)"
339, PRINT, "   Starting re-enumeration"
349, PRINT2N, "USBTask: I_USB_SOFT_RECONNECT: Posted by file: %(fileid), line %d"
358, PRINT2N, "USBTask: I_USB_SWITCH_ENUM_MODE: Posted by file: %(fileid), line %d"
361, PRINTN, "I_USB_SWITCH_ENUM_MODE START:  Ticks= %d"
373, PRINT, "USB disconnected ==> only switching stack"
375, PRINTN, "Mode changed to %(USB_MODES)"
387, PRINT, "USB connected ==> Calling UsbDrvDetach and UsbDrvAttach"
402, PRINTN, "Mode changed to %(USB_MODES)"
424, PRINT2N, "USBTask: I_USB_CABLE_OUT: Posted by file: %(fileid), line %d"
425, WARN, "   Depreciated - use RimUsbDisconnected()"
430, PRINT2N, "USBTask: I_USB_PORT_RESET: Posted by file: %(fileid), line %d"
457, PRINT2N, "I_USB_SD_CARD_EJECT: Posted by file: %(fileid), line %d"
469, WARNN, "Packet received while not enumerated! - ignoring (channel: %d)"
529, ASSERTFN, "ERROR: MUX protocol limits transfer length to 64KB-1B. Length = %d"
555, WARNN, "Bad channel: %u"
625, WARNN, "Bad channel: %u"
632, PRINT2N, "USBTask: I_USB_PORT_RESUME: Posted by file: %(fileid), line %d"
654, PRINT2N, "USBTask: I_USB_CDHANDLER: Posted by file: %(fileid), line %d"
667, PRINT3N, "USBTask: I_USB_START_PENDING_WRITE: Posted by file: %(fileid), line %d, ep=%d"
674, WARN3N, "USBTask: Unknown Message: Posted by file: %(fileid), line %d, Event=%d"
723, ASSERTFN, "Invalid channel: %d"
737, PRINT2N, "DebugTask: I_USB_PORT_RESUME: Posted by file: %(fileid), line %d"
741, PRINT2N, "DebugTask: I_USB_CONFIGURED: Posted by file: %(fileid), line %d"
763, PRINT2N, "DebugTask: I_USB_PORT_SUSPEND: Posted by file: %(fileid), line %d"
768, PRINT2N, "DebugTask: I_USB_PORT_RESET: Posted by file: %(fileid), line %d"
772, PRINT2N, "DebugTask: I_USB_CABLE_OUT: Posted by file: %(fileid), line %d"
788, PRINT2N, "DebugTask: I_USB_MSG_RECEIVED: Posted by file: %(fileid), line %d"
792, PRINT2N, "DebugTask: I_USB_PARTIAL_MSG_RECEIVED: Posted by file: %(fileid), line %d"
830, PRINT, "   Message received"
859, PRINT, "   Restarting bugdisp read"
1009, PRINT3N, "DebugTask: I_USB_CHECK_INVALID_STATE: Posted by file: %(fileid), line %d, rtc=%d"
1014, PRINTN, "   Starting invalid state timer %d"
1027, WARN3N, "DebugTask: BAD USB MESSAGE : Posted by file: %(fileid), line %d, Event=0x%x"
1032, PRINT2N, "Event (%d) from an unknown device (%d) received"
1066, PRINT, "Bugdisp USB_PACKET_RECEIVED"
1146, PRINT, "Bugdisp USB_CHANNEL_OPEN_REQ"
1153, PRINT, "Bugdisp USB_CHANNEL_OPENED"
1162, PRINT, "Bugdisp USB_CHANNEL_CLOSED"
1169, PRINTN, "Unknown DEVICE_USB event 0x%x"
1175, PRINT2N, "Event (%d) from an unknown device (%d) received"
END FILE "FILE_USB_MSG", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\usbmsg.c"

BEGIN FILE "FILE_RIMUSB", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\rimusb.c"
288, PRINTN, "RimUsbSetDefaultMode:  Setting usbModeDefault=%(USB_MODES)"
317, WARN, "UsbRead(): Ignored... No USB Port selected"
391, PRINT, "RimUsbInitPipes()"
479, WARNN, "RimUsbCancelXfer(chan=%d): Ignored... No USB port selected"
517, WARNN, "RimUsbCancelXfer(chan=%d): Ignored... No USB port selected"
536, WARNN, "RimUsbCancelXfer(chan=%d): Ignored... No USB port selected"
625, PRINT, "StartUSB() [already started]"
632, PRINT, "StartUSB(): Device is catfailed, setting newMode to BB-Only"
643, PRINT, "StartUSB(): Antioch present but speed is FULL (not HIGH)."
648, PRINT2N, "StartUSB() starting: newMode = %(USB_MODES), newSpeed = %(USB_SPEEDS)"
650, PRINT2N, "StartUSB() --------: curMode = %(USB_MODES), curSpeed = %(USB_SPEEDS)"
658, PRINT, "StartUSB(): disabling the unused high speed port"
666, PRINT, "StartUSB(): disabling the unused full speed port"
715, PRINT, "StartUSB(): Completed USB Stack init.  Posting cable event..."
719, PRINT2N, "@@ %[%f/#*1000] ms from last system reset: StartUSB() completed"
777, WARN, "StopUSB() [not started]"
788, WARN, "StopUSB(): Ignored... No USB port selected"
792, PRINT, "StopUSB()"
871, WARN, "UsbRead(): Ignored... No USB Port selected"
886, WARNN, "UsbRead(): Ignoring read call - %d pending configs"
892, WARNN, "UsbRead: Bad read!: chan = %d"
908, PRINT4N, "UsbRead(): channel: %d, buffer: 0x%x, usingSize: %u, allocsize: %u"
922, ASSERTFN, "UsbRead: pBuffer == NULL; chan = %d"
928, ASSERTFN, "UsbRead: size == 0; chan = %d"
942, WARN, "Device is not enumerated, UsbRead is invalid"
1050, PRINT3N, "AlignUsbBuffer: Processing request for channel %d, cur_buff_idx: %d, num_buffers: %d"
1070, PRINT4N, "AlignUsbBuffer: Processing buffer %d. Addr = 0x%x; Using Size: %uAllocated Size = %u"
1081, PRINT, "AlignUsbBuffer: Currently configured for HIGH-SPEED. Multi-buffer not supported"
1091, PRINT, "AlignUsbBuffer: Always merging BD and MUX on Argon/MSM cores and Qualcomm OS"
1098, PRINT, "AlignUsbBuffer: Always merging for TavorPVx_Sim"
1106, PRINTN, "AlignUsbBuffer: Buffer failed USB alignment check (req align=%d)"
1117, PRINTN, "AlignUsbBuffer: Buffer failed DMA alignment check (req align=%d)"
1132, PRINT2N, "AlignUsbBuffer: Buffer failed CACHE check (req align=%d; req factor=%d)"
1147, PRINT2N, "AlignUsbBuffer: Buffer failed USB or DMA Factor check (usb factor=%d; dma factor=%d)"
1155, ASSERTF2N, "AlignUsbBuffer: Current destination index is invalid. Index = %d; Max = %d"
1166, PRINT2N, "Storing buffer %d information in position %d"
1177, PRINT, "AlignUsbBuffer: Resetting 'cur_buff_offset' to 0"
1196, PRINTN, "AlignUsbBuffer: Cleaning and invalidating buffer %d"
1208, ASSERTFN, "AlignUsbBuffer: Merge required for send pipe without an align buffer (chan = %d)"
1214, ASSERTF2N, "AlignUsbBuffer: Current destination index is invalid. Index = %d; Max = %d"
1233, PRINT5N, "AlignUsbBuffer: Merging from buffer %d - src: 0x%x %d; dst: 0x%x %d"
1237, PRINT2N, "... src offset: %d; dst offset: %d"
1244, PRINT2N, "AlignUsbBuffer: Copying %d bytes to the merge buffer: sendCount=%u"
1253, PRINTN, "AlignUsbBuffer: Reached packet boundary on merge, setting src offset to  %d"
1258, PRINTN, "AlignUsbBuffer: Reached the end of the merge buffer, setting src offset to %d"
1263, PRINT, "AlignUsbBuffer: Reached the end of the merge buffer at the end of a provided buffer"
1280, PRINT, "AlignUsbBuffer: Resetting 'cur_buff_offset' to 0"
1291, PRINT2N, "AlignUsbBuffer: Setting merge buffer at index %d (size = %d)"
1306, PRINTN, "AlignUsbBuffer: Returning with %d buffers to send"
1339, WARN, "UsbSend(): Ignored... No USB Port selected"
1346, ASSERTFN, "UsbSend: Multi-send failure chan = %d"
1374, ASSERTF2N, "UsbSend: pBuffer == NULL; chan = %d; buff = %d"
1380, ASSERTF2N, "UsbSend: size == 0; chan = %d; buff = %d"
1387, ASSERTF4N, "UsbSend: usingSize > allocSize; chan = %d; buff = %d, usingSize: %u, allocSize: %u"
1418, ASSERTFN, "UsbSend: Invalid channel index specified (%d)"
1423, PRINTN, "UsbSend() : [MUX channel] size = %d"
1427, PRINTN, "UsbSend() : [NOTIFICATION channel] size = %d"
1592, WARNN, "Invalid USB core: %(UsbCore)"
1599, PRINTN, "Core switch ignored: %(UsbCore) already active"
1604, PRINT, "Switching USB core to baseband"
1606, PRINT, "Switching USB core to Antioch - high speed"
1646, WARN, "RimusbSoftReconnect(): Reconnect already in progress!"
1653, PRINTN, "RimUsbSoftReconnect(): Posting %(EVENT)"
1656, PRINT, "Calling StopUSB directly - RimUsbSoftReconnect called from USB Task"
1674, PRINT, "RimUsbSoftReconnectCallback(): Speed switch requested - switching speeds."
1692, PRINT, "RimUsbSoftReconnectCallback(): Core switch requested - switching cores."
1700, PRINT, "RimUsbSoftReconnectCallback(): New mode being forced."
1703, PRINT2N, "RimUsbSoftReconnectCallback(): newMode = %(USB_MODES), newSpeed = %(USB_SPEEDS), calling StartUSB()"
1718, PRINT, "Calling bbfd_switch_stack()"
1781, PRINT, "Got 0-byte transfer"
1812, PRINT2N, "RimUsbOutXferDone: Received special 3-BYTE packet (special xfer size = %d; chan=%d)"
1840, PRINT3N, "RimUsbOutXferDone: Received %d-BYTE transfer (chan=%d), pPipe(0x%x)"
1866, PRINTN, "RimUsbOutXferDone: Received PARTIAL message (chan=%d)"
1920, PRINTN, "RimUsbInXferDone: Calling AlignUsbBuffer ( %d )"
1974, PRINT, "Suspend timer expired, initiating disconnect"
1999, PRINT4N, "RimUsbSetSuspendState: ENUMERATED?: %d; SUSPENDED?: %d; Suspend/nResume=%d at RTC=%d"
2015, PRINT, "   UsbChargerPresent, ignoring Suspend, there is no HOST."
2084, PRINT3N, "RimUsbResetInt: ENUMERATED?: %d; SUSPENDED?: %d; RTC = %d"
2089, PRINT, "   UsbChargerPresent, ignoring RESET, there is no HOST."
2109, PRINT2N, "Device forced to BB-Only mode (catfail = 0x%x; rec_allowed = 0x%x)"
2116, WARN, "USB QUINCY: USB_RESET not preceeded by USB_SUSPEND"
2138, WARN, "USB QUINCY: Skipped - Too soon since last log"
2183, PRINTN, "RimUsbSetPeriphState() : %d"
2207, PRINT, "USB_Resume_Handler(): sending wakeup"
2247, PRINT, "Deleted copy of USB NV Record"
2255, WARNN, "Unknown size read for NV_OSSTORE_USB_NUM: %d"
2260, PRINTN, "cachedNvFlags = 0x%x"
2287, PRINTN, "set cachedNvFlags = 0x%X"
2289, PRINT2N, "usbState: %x cachedNvFlags: %d"
2296, PRINT, "MS switch while no cable detected: Need bbfd_switch_stack()"
2321, PRINTN, "set cachedNvFlagsCopy = 0x%X"
2350, PRINT, "RimUsbDumpCatfailInfo()"
2351, PRINT, "-----------------------"
2352, PRINT, "Last SETUP:"
2353, PRINTN, "   bmRequestType: 0x%X"
2354, PRINTN, "   bRequest: 0x%X"
2355, PRINTN, "   wValue: 0x%X"
2356, PRINTN, "   wIndex: 0x%X"
2357, PRINTN, "   wLength: 0x%X"
2358, PRINTN, "(Received at frame %d)"
2359, PRINT, "-----------------------"
2360, PRINT, "RIM USB Pipe Dump:"
2362, PRINTN, "  Pipe %d:"
2363, PRINTN, "    pBuffer = 0x%x"
2364, PRINTN, "    pBufArray = 0x%x"
2365, PRINTN, "    buffNum = %d"
2366, PRINTN, "    completeXfer = 0x%x"
2367, PRINTN, "    status = 0x%x"
2368, PRINTN, "    halted = 0x%x"
2370, PRINT, "-----------------------"
2372, PRINT, "USB BugDisp Debug Events (oldest to newest)"
2374, PRINT3N, "  [%d]: Event=%(USB_BDISP_DEBUG_EVENTS); TimeStamp=0x%x"
2377, PRINT, "-----------------------"
2386, WARN, "Unable to dump usb core register information"
2388, PRINT, "-----------------------"
2389, PRINT, "NV Flags:"
2390, PRINTN, "cached flags are: 0x%08x"
2400, WARN, "Cannot retrieve NV flags because we are in interrupt context!"
2407, PRINTN, "non-cached flags: 0x%08x"
2408, PRINT, "-----------------------"
2436, PRINT, "Completing soft reconnect. ==> Not posting I_USB_CABLE_IN.  Will just post USB_ENUMERATEd on SET_CONFIG"
2444, WARN, "Completing soft reconnect, but cable was pulled  ==> Posting USB_CABLE_CONNECTED"
2466, PRINT, "RimUsbDisconnected: Start"
2478, WARN, "The device cable is unplugged, calling RimInitiateReset()"
2489, PRINT, "Soft reconnect in progress and cable still connected ==> Not posting USB_CABLE_DISCONNECTED. Posting USB_NOTENUMERATED instead"
2494, WARN, "Soft reconnect in progress, but cable has been disconnected==> Finishing soft reconnect, but posting USB_CABLE_DISCONNECTED instead"
2500, PRINT, "Cable disconnected, posting USB_CABLE_DISCONNECTED"
2518, WARN, "STP requested delayed reset"
2525, PRINT, "Completing soft reconnect"
2532, WARN, "Cable has been disconnected on soft reconnect completion  ==> Posted USB_CABLE_DISCONNECTED instead"
2540, WARN, "RimUsbSetMode call failed"
2543, WARN, "USB mode has changed before disconnect. ==> Switching Jungo stack for next cable insertion"
2551, PRINT, "Stopping invalid state timer"
2555, PRINT, "Stopping suspend timer (FEATURE_RIM_DISCONNECT_ON_SUSPEND)"
2558, PRINT, "RimUsbDisconnected: End"
2614, PRINT2N, "RimUsbForceModeAndSpeed: Already in %(USB_MODES) mode / %(USB_SPEEDS) speed."
2617, WARN, "RimUsbForceModeAndSpeed: Should be connected before being called.  Do Nothing."
2622, WARN, "RimUsbForceModeAndSpeed: Already in mode/speed."
2626, PRINT, "RimUsbForceModeAndSpeed: Reconnecting USB."
2689, WARN, "There have been two USB failures in this run... Catfailing the device..."
2709, PRINT, "***************************************************************"
2710, PRINT, "VSP Info"
2711, PRINT, "***************************************************************"
2713, PRINTN, "---[ Port %d]--------------------------------------------------"
2719, WARN, "USB QUINCY: Attempting USB recovery"
2723, WARN, "USB QUINCY: Skipped - Too soon since last log"
2750, PRINT4N, "setDisableClearStallFeature(): chan=%d, dir=%x, setting endpoint %d DisableClearStallFeature to %d."
2802, PRINT, "returning BDCanDisconnect()"
2808, WARNN, "UsbSwitchModeFunctionBusy: Non-existent veto function '0x%x' specified"
2819, PRINTN, "%(USB_VETO_FUNCTIONS)"
2828, PRINTN, "UsbSwitchMode: mode=%(USB_ENUM_MODE):"
2830, PRINTN, "UsbSwitchEnumMode START:  Ticks= %d"
2844, PRINT, "Checking functions: "
2854, WARN, "Switch vetoed.  Busy functions:"
2865, PRINTN, "UsbSwitchMode: error=%(USB_ERROR_CODE)"
2872, WARN, "UsbGetCurrEnumMode():  NULL mode pointer passed"
2877, PRINTN, "UsbGetCurrEnumMode():  *mode=%(USB_ENUM_MODE)"
2880, WARNN, "UsbGetCurrEnumMode():  Not in a mode suppported by UsbSwitchEnumMode: %(USB_MODES)"
2896, WARN, "UsbSwitchEnumAttach: reattachTimer already running"
2902, PRINT, "UsbSwitchEnumAttach: starting re-attach timer"
2907, PRINT, "UsbSwitchEnumAttach: timer expired, re-attaching"
2913, WARN, "UsbSwitchEnumAttach: Cable not present when reAttachTimer expired"
2915, WARN, "UsbSwitchEnumAttach: Cable not present"
2952, PRINTN, "Not posting connection status %(CONN_STAT_ENUM) again"
2977, PRINTN, "SendConnectionStatus Updating Previously Posted Message - status: %(CONN_STAT_ENUM)"
3003, PRINT, "SendConnectionStatus(0): No status to send"
3004, PRINT2N, "SendConnectionStatus(0x%02x): %(CONN_STAT_ENUM)"
3005, PRINT3N, "SendConnectionStatus(0x%02x): %(CONN_STAT_ENUM), %(CONN_STAT_ENUM)"
3007, PRINT4N, "SendConnectionStatus(0x%02x): %(CONN_STAT_ENUM), %(CONN_STAT_ENUM), %(CONN_STAT_ENUM) "
3009, PRINT5N, "SendConnectionStatus(0x%02x): %(CONN_STAT_ENUM), %(CONN_STAT_ENUM), %(CONN_STAT_ENUM), %(CONN_STAT_ENUM) "
3011, WARN, "SendConnectionStatus(0x%02x): Unexpected number of concurrent states"
3013, PRINT5N, "SendConnectionStatus(0x%02x): %(CONN_STAT_ENUM), %(CONN_STAT_ENUM), %(CONN_STAT_ENUM), %(CONN_STAT_ENUM) "
END FILE "FILE_RIMUSB", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\rimusb.c"

BEGIN FILE "FILE_USBCD", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\usbcd.c"
354, WARN, "HAL_ULPI_PortInit: USB_OTG_HS_PORTSC PHCD error"
356, PRINTN, "HAL_ULPI_PortInit: USB_OTG_HS_PORTSC PHCD is Good %d"
366, WARNN, "HAL_ULPI_PortInit: Port is not configured in ULPI mode. PTS field value: %X"
368, PRINT, "HAL_ULPI_PortInit: Port is configured in ULPI mode."
372, WARN, "HAL_ULPI_PortInit: ULPI BUSY before WakeUP!"
374, PRINT, "HAL_ULPI_PortInit: ULPI is ready for commands"
377, PRINT, "HAL_ULPI_PortInit: ULPISS = 1, Normal Operation Mode"
379, PRINT, "HAL_ULPI_PortInit: FAIL ULPISS = 0, read/write will not work"
384, WARN, "HAL_ULPI_PortInit: ULPI WakeuP error"
386, PRINTN, "HAL_ULPI_PortInit: PASS ULPI WakeuP %d"
397, PRINT, "HAL_ULPI_PortInit: Successfuly cleared VBUS Valid Int bits"
398, PRINT, "HAL_ULPI_PortInit: ULPI Initialization completed successfully."
401, WARN, "HAL_ULPI_PortInit: Failed to clear VBUS Valid bits"
427, PRINT, "checkResetULPI: ULPI PHY Init posted to Modem."
429, PRINT, "checkULPIClock: enabling ULPI clock"
432, WARN, "checkULPIClock: FAILURE turning CLKRGM_USB_HS_PCLK on."
437, WARN, "checkULPIClock: CLKRGM_USB_HS_PCLK is OFF (required to be ON)"
441, PRINT, "checkULPIClock: ULPI Clock domain is enabled."
456, PRINT, "checkULPIClock: Resetting ULPI"
462, WARN, "checkULPIClock: FAILURE turning CLKRGM_USB_HS_PCLK on."
467, WARN, "checkULPIClock: CLKRGM_USB_HS_PCLK is OFF (required to be ON)"
471, PRINT, "checkULPIClock: ULPI Clock domain is enabled."
485, PRINT, "checkULPIClock: Resetting ULPI"
501, WARN, "checkULPIClock: FAILURE turning CLKRGM_USB_HS_PCLK on."
506, WARN, "checkULPIClock: CLKRGM_USB_HS_PCLK is OFF (required to be ON)"
510, PRINT, "checkULPIClock: ULPI Clock domain is enabled."
528, PRINTN, "ULPI_WR: enter with command = 0x%x"
533, PRINTN, "ULPI_WR: ULPI BUSY waiting count.... %d"
538, PRINTN, "ULPI_WR: ULPI BUSY waiting count.... %d"
543, WARN, "ULPI_WR: Busy after sending command, failing. "
547, WARN, "ULPI_WR: Busy before sending command, failing. "
561, PRINTN, "ULPI_RD: ULPI BUSY waiting count.... %d"
565, WARN, "ULPI_RD: ULPI Busy timeout."
581, WARN2N, "checkULPIVenderID: Invalid response from ULPI PHY: (expected 0x%x?) 0x%x "
584, PRINT, "checkULPIVenderID: ULPI Vender ID confirmed, accesses working"
594, PRINTN, "checkULPIVenderID: STP_USB_GET_ULPIVENDORID -> 0x%x"
598, PRINT, "checkULPIVenderID: Not Implemented in this Build."
609, PRINTN, "IoTaskCallLater_cable_check: IoTaskCallLater(cable_check()), accDetectRetries=%d"
614, WARN, "IoTaskCallLater_cable_check: cableStateTimer already pending. Conceding..."
621, PRINT, "IoTaskCallLater_cable_check: AC/Host detection timeout, suspend charger,"
622, PRINTN, "   enable the USB driver in case this is a host, delatT = %dms"
638, PRINT, "setUlpiInACDetectMode: Setting ULPI for AC/Host Detection."
649, WARNN, "setUlpiInACDetectMode: ULPI Function should be 0x49, read: 0x%x, fixing..."
660, WARN, "setUlpiInACDetectMode: FAILED to set mode.  Cable Detection may break..."
662, PRINT, "setUlpiInACDetectMode: AC/Host Mode 0x49 set!"
665, PRINT, "setUlpiInACDetectMode: AC/Host Mode 0x49 set!"
678, PRINT2N, "cable_check: start, time since cable event = %dms, (rtc = %d)"
681, PRINT, "cable_check: Cable was removed"
703, PRINTN, "cable_check: Detected AC Charger, posting I_USB_CDHANDLER, Found in %d ms"
709, PRINTN, "cable_check: Detected USB Host, posting I_USB_CDHANDLER, Found in %d ms"
715, WARNN, "cable_check: countdn=0, don't know what we are connected to? val=%d"
728, PRINT4N, "-- linestate (-+) = 0x%x, rtc = %d, i=%2d, dT=%d ms"
748, PRINT, "end_cable_check: restoring D+/- lines from tristate/pullup state"
752, WARN, "end_cable_check: ULPI write failure; ULPI USB pathway possibly bad configuration."
774, PRINT, "ULPI_VBUS_SessionValid: ULPI PHY VBUS Session valid, cable CONNECTED"
777, PRINT, "ULPI_VBUS_SessionValid: ULPI PHY VBUS Session invalid, cable DISCONNECTED"
781, WARN, "ULPI_VBUS_SessionValid: ULPI failure"
805, WARN, "start_cable_check: Device catfailed - returning"
820, PRINT, "start_cable_check: Already pending cableStateTimer was stopped."
828, PRINTN, "start_cable_check: Cable present, starting AC/Host Detection at RTC=%d"
835, PRINTN, "start_cable_check: USB Host (already) detected, abandoning AC/Host detection at RTC=%d"
841, PRINTN, "start_cable_check: Cable absent at RTC=%d"
858, PRINT, "start_cable_check: Full Speed build using ULPI pass thru mode. Supporting STP_USB_GET_ULPIVENDORID command."
872, PRINT, "start_cable_check: No ULPI AC/HOST Detection on this platform."
944, PRINT, "READ_CD: Always returning TRUE because USB_READ_CD_WORKAROUND feature"
955, PRINT, "READ_CD: ULPI PHY VBUS Session valid, cable CONNECTED"
958, PRINT, "READ_CD: ULPI PHY VBUS Session invalid, cable DISCONNECTED"
962, WARN, "READ_CD: ULPI failure"
967, PRINTN, "READ_CD: returning UsbPresent = %d"
1016, PRINTN, "RimUsbStartCDHandler: Start, cdInterruptStatus = %d "
1026, PRINT, "RimUsbStartCDHandler: Asserting USB_VBUS_EN"
1031, PRINT, "RimUsbStartCDHandler: De-asserting USB_VBUS_EN"
1056, PRINT, "RimUsbStartCDHandler: Antioch is not initialized.  Initializing"
1059, WARNN, "RimUsbStartCDHandler: AntiochInit failed %d time(s) - retrying"
1071, WARN, "RimUsbStartCDHandler: USB Quincy:  Antioch Firmware download required retry(s)."
1093, WARN, "RimUsbCDInterruptOccurred: USB not (yet) started, ignoring cable detect interrupt"
1099, PRINTN, "RimUsbCDInterruptOccurred, cableIn=%d"
1147, PRINT, "CheckUsbAdapter: USB_CHECKS_TO_CHARGER_OFF timeout"
1153, PRINT, "CheckUsbAdapter: Host detected, AC Adapter check abandoned."
1159, PRINT, "CheckUsbAdapter: AC Adapter detection is not supported on this Build"
1171, PRINT, "CheckUsbAdapter: CHRG_AC_DET - got it!"
1182, PRINTN, "CheckUsbAdapter: Antioch Data lines register is 0x%02x"
1190, WARNN, "CheckUsbAdapter: Unknown speed (%d)"
1207, PRINT2N, "CheckUsbAdapter: Tavor PV Linestate[0]/[1] = 0x%x, 0x%x (bit1=D+,bit0=D-)"
1219, PRINT, "CheckUsbAdapter: AC Adapter detected on USB connector"
1225, WARN, "CheckUsbAdapter: VBUS is connected, D+=H,D-=L; faulty charger or not fully inserted"
1228, PRINT, "CheckUsbAdapter: HOST found, D+/- are LOW."
1232, WARN, "CheckUsbAdapter: UNEXPECTED result, D+=L, D-=H; faulty charger or not fully inserted"
1237, WARN, "CheckUsbAdapter: Successive linestate reads don't match, try again later."
1248, PRINT2N, "CheckUsbAdapter: dMinus=0x%x, dPlus=0x%x"
1250, PRINT, "CheckUsbAdapter: AC Adapter detected on USB connector"
1255, WARN, "CheckUsbAdapter():No AC Detection method exisits for this platform."
1264, PRINT, "CheckAdapter: Setting Charge Rate to USB_ADAPTER_POWER, UsbChargerPresent=TRUE"
1319, PRINT3N, "@@ %[%f/#*1000] ms from last system reset: cableInserted = %d"
1329, WARN, "USB_CD_Handler called when USB has not been started (or was started and has been stopped.  Ignoring"
1334, ASSERTF, "USB_CD_Handler: USB was started but pUsbPort == No USB port"
1338, ASSERTF, "USB_CD_Handler: USB was started but pUsbPort == NULL USB port"
1345, PRINT3N, "USB_CD_Handler: newMode=%(USB_MODES), curMode=%(USB_MODES), cableInserted=%d"
1346, PRINT2N, "USB_CD_Handler: newSpeed=%(USB_SPEEDS), curSpeed=%(USB_SPEEDS)"
1352, PRINT, "Cable connected"
1358, PRINT, "USB_CD_Handler: newModeForced=True, keeping mode"
1362, PRINT2N, "USB_CD_Handler: Forced to Full Speed, BB-Only (catfail= 0x%x; rec_allowed= 0x%x)"
1376, PRINT, "USB_CD_Handler: CD fired (cable in)"
1394, PRINT, "USB_CD_Handler: Detected AC Charger"
1401, PRINT, "USB_CD_Handler: Cable detected, but was already plugged in"
1406, PRINT, "USB_CD_Handler: CD fired (cable out), proceeding to I_USB_CABLE_OUT"
1432, PRINT, "USB_CD_Handler: Detected removal of AC Charger"
END FILE "FILE_USBCD", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\usbcd.c"

BEGIN FILE "FILE_USBPROFILE", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\usbprofile.c"
112, WARNN, "USB profiling sort field must be between 0 and 3 (Entered: %u)"
126, PRINTN, "Sorted on Field: %u"
127, PRINT, "Rank Name"
131, PRINTCOPY, "%s"
134, PRINT, "            0          1            2               3        "
135, PRINT, "+------+---------+----------+---------------+---------------+"
136, PRINT, "| Rank | # Calls | Avg Time | Max Tick/Call | Min Tick/Call |"
142, PRINT4N, "| %4u | %7u | %8u | %13u | ------------- |"
148, PRINT5N, "| %4u | %7u | %8u | %13u | %13u |"
156, PRINT, "+------+---------+----------+---------------+---------------+"
264, PRINT, "+------+-----+----------+---------------+---------------+---------------+"
265, PRINT, "| Chan | Dir | # Bytes  |    Avg  bs    |  Max Peak bs  |  Min Peak bs  |"
266, PRINT, "+------+-----+----------+---------------+---------------+---------------+"
276, PRINT4N, "| %4u | In  | %8u | %13u | %13u | ------------- |"
282, PRINT5N, "| %4u | In  | %8u | %13u | %13u | %13u |"
293, PRINT4N, "| %4u | Out | %8u | %13u | %13u | ------------- |"
299, PRINT5N, "| %4u | Out | %8u | %13u | %13u | %13u |"
307, PRINT, "+------+-----+----------+---------------+---------------+---------------+"
817, PRINTN, "Speed: %d"
842, PRINT2N, "MS Read Start: %d, T=%d"
850, PRINTN, "MS Read End:       T=%d"
858, PRINT2N, "MS Write Start: %d, T=%d"
866, PRINTN, "MS Write End:       T=%d"
876, PRINT, "Mass Storage:"
877, PRINT, "+------+-----+----------+---------------+---------------+---------------+"
883, PRINT4N, "|      | Rd  | %8u | %13u | %13u | %13u |"
891, PRINT4N, "|      | Wr  | %8u | %13u | %13u | %13u |"
899, PRINT4N, "|      | RRd | %8u | %13u | %13u | %13u |"
907, PRINT4N, "|      | RWr | %8u | %13u | %13u | %13u |"
916, PRINT, "+------+-----+----------+---------------+---------------+---------------+"
END FILE "FILE_USBPROFILE", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\usbprofile.c"

BEGIN FILE "FILE_USBDRV_TAVORPV", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\tavorpv\\usbdrv_tavorpv.c"
370, WARNN, "%(clk) is not supported yet"
398, WARNN, "%(clk) is not supported yet"
445, WARN, "getLineStates: called with drvEnable==FALSE"
467, PRINT, "USB_TavorPV: Handle Test Mode Request"
502, PRINT, "USB_TavorPV: usbHandleReset"
507, ASSERTF, "Port status of the USB_RESET was cleared before we were done. This is bad according to ChipIdea specs"
529, WARNN, "usbHandleReset: Loop count in USB_RESET = %d"
537, ASSERTF, "Port status of the USB_RESET was cleared before we were done. This is bad according to ChipIdea specs"
538, PRINTN, "Time delta = %d"
557, WARNN, "USB_TavorPV: getTd - Invalid channel number: 0x%d"
560, WARNN, "USB_TavorPV: getTd - Invalid td number: %u"
652, PRINT, "USB_TavorPV: UsbEpTdInit - Invalid data buffer pointer"
663, PRINT, "USB_TavorPV: UsbEpTdInit - Failed to find TD pointer"
766, PRINT, "USB_TavorPV: UsbEpPrime - Invalid channel number"
775, PRINT, "USB_TavorPV: UsbEpPrime - Failed to find TD pointer"
798, WARN, "Priming EP took too long, continuing anyway"
801, WARNN, "Prime ( chan=%(UsbChannel) ) Failed"
802, WARN, "Another setup packet was received during priming"
843, PRINT, "USB_TavorPV: UsbEpTdComplete - Failed to find TD pointer"
855, WARN, "TD ACTIVE Status Detected, returning..."
866, WARN4N, "USB_TavorPV: UsbEpTdComplete - Invalid endpoint status - Chan %d, status 0x%x, token 0x%x, dir %u"
963, WARN2N, "USB_TavorPV: UsbEpTdComplete chan=%u, dir=%u - Null buffer pointer."
972, PRINT, "-----------------------------"
973, PRINTN, "tdToken=0x%x"
974, PRINTN, "nextTdPtr=0x%x"
976, PRINT5N, "bufPtr: 0x%x 0x%x 0x%x 0x%x 0x%x"
980, PRINT, "-----------------------------"
981, PRINTN, "QH capability=0x%x"
982, PRINTN, "QH curTdPtr=0x%x"
983, PRINTN, "QH overlayNextTDPtr=0x%x"
984, PRINTN, "QH overlayStatus=0x%x"
985, PRINT5N, "QH overlayBufPtr: 0x%x 0x%x 0x%x 0x%x 0x%x"
987, PRINT2N, "QH setupBuf: 0x%x 0x%x"
988, PRINT, "-----------------------------"
1199, PRINT, "phyTuningValuesInit() - already ran - doing nothitng"
1216, WARN, "NV copy of USB PHY cal data does not exist - creating"
1218, WARN2N, "NV copy of USB PHY cal data older (ver: %u) than RAM copy (ver: %u).  Updating."
1229, WARNN, "Could not create/update USB PHY tuning NV record: %(NvFlashStatus)"
1239, PRINT2N, "Using NV copy of USB PHY cal data NV ver: %u, RAM ver: %u"
1246, PRINT, "SFI/MFI and NV agree on verion of USB PHY cal data"
1257, WARN, "USB PHY cal data:  NVRAM and RAM copies have the same version but different content.  Using NVRAM copy"
1259, SHOW_MEMORY, "NV copy: "
1260, SHOW_MEMORY, "RAM copy: "
1298, WARNN, "Error in test: couldn't write default data to NVRAM TavorPVUsbCal (error=%(NvFlashStatus))"
1330, WARNN, "Unknown tuning register: 0x%x"
1361, WARNN, "Unknown tuning register: 0x%x"
1373, WARNN, "Error in test: couldn't write default data to NVRAM TavorPVUsbCal (error=%(NvFlashStatus))"
1378, PRINT2N, "Writing register: 0x%x with value: 0x%x"
1413, PRINT, "USB_TavorPV: UsbDrvInit "
1419, PRINTN, "UsbDrvInit: D0CKEN_C_REG32 =  0x%08x"
1420, PRINTN, "UsbDrvInit: ACCR1_REG32    =  0x%08x"
1421, PRINTN, "UsbDrvInit: UDC_MCR        =  0x%08x"
1427, PRINTN, "UsbDrvInit: wait loop counter - start value =  %d"
1429, PRINTN, "UsbDrvInit: wait loop counter - end value =  %d"
1430, WARN, "USB_TavorPV: USB controller did not reset"
1534, PRINT2N, "writing %d to %X"
1537, PRINT2N, "wrote %d result: %X"
1544, PRINT, "UsbDrvUninit"
1581, PRINT, "USB_TavorPV: UsbDrvEnable"
1670, PRINTN, "UsbDrvEnable: attempting ULPI reset, countRetry=%d"
1675, WARN, "UsbDrvEnable: ULPI could not be initialized, sending Quincy."
1692, PRINT3N, "CHAN2QH( %d, %d)=%d"
1737, PRINT, "USB_TavorPV: UsbDrvDisable"
1765, PRINT, "UsbDrvDisable:  Resetting controller"
1770, WARN, "UsbDrvDisable:  USB controller did not reset"
1772, PRINT, "UsbDrvDisable:  Controller reset successfully"
1774, PRINT, "UsbDrvDisable:  Putting controller into host mode"
1951, WARN, "USB EP Stalled"
1954, PRINT, "Control channel not stalled anymore, clearing flag"
1959, WARNN, "UsbDrvSetupInPipe: chan %d is stalled"
1989, PRINT, "UsbDrvRemoteWakeup() ignored on Tavor PV USB core"
1994, PRINTN, "SetPeripheralState() ignored on Tavor PV USB core: %d"
2079, WARN, "UsbEpCancel() - Could not flush endpoint"
2157, PRINT, "UsbDrvAttach"
2161, PRINTN, "UsbDrvAttach: attempting ULPI reset, countRetry=%d"
2166, WARN, "UsbDrvAttach: ULPI could not be initialized, sending Quincy."
2184, PRINT, "UsbDrvDetach"
2237, PRINT, "USB_TavorPV: UsbDrvConfigureEndpoints"
2291, PRINT2N, "UsbDrvStallPipe chan=%d, dir=%x"
2324, PRINT2N, "UsbDrvUnStallPipe chan=%d, dir=%x"
2402, WARNN, "Invalid endpoint number (%d) specified"
2430, WARN, "USB_IRQ_Handler: interrupt after controller stopped - doing *nothing*"
2445, WARNN, "USB_IRQ_Handler: interrupt after disconnected (STS = 0x%x)"
2516, PRINTN, "New speed is: %(USB_SPEEDS)"
2559, PRINTN, "USB_TavorPV: USB Reset Interrupt, rtc = %d"
2567, PRINTN, "USB_TavorPV: Suspend Interrupt, D+/- are LOW, RESET state, rtc = %d"
2572, PRINTN, "USB_TavorPV: USB RESUME Interrupt, D+=L, D-=H, cleared. rtc = %d"
2580, PRINTN, "USB_TavorPV: USB Suspend Interrupt, D+=H, D-=L, cleared, rtc = %d"
2588, PRINTN, "USB_TavorPV: Suspend Interrupt, D+/- are HIGH, AC Adpater?, rtc = %d"
2591, WARN, "USB_TavorPV: Suspend Interrupt, UNEXPECTED STATE."
2637, PRINT, "UsbDrvConfigForAcCharging"
2675, PRINT, "USB Controller Registers:"
2676, PRINT, "---------------------------------------"
2677, PRINT2N, "UDC_ID (0x%08x)               : 0x%08x"
2678, PRINT2N, "UDC_HWGENERAL (0x%08x)        : 0x%08x"
2679, PRINT2N, "UDC_HWDEVICE (0x%08x)         : 0x%08x"
2680, PRINT2N, "UDC_HWTXBUF (0x%08x)          : 0x%08x"
2681, PRINT2N, "UDC_RWTXBUF (0x%08x)          : 0x%08x"
2682, PRINT2N, "UDC_SBUSCFG (0x%08x)          : 0x%08x"
2683, PRINT2N, "UDC_DCIVERSION (0x%08x)       : 0x%08x"
2684, PRINT2N, "UDC_DCCPARAMS (0x%08x)        : 0x%08x"
2685, PRINT2N, "UDC_USBCMD (0x%08x)           : 0x%08x"
2686, PRINT2N, "UDC_USBSTS (0x%08x)           : 0x%08x"
2687, PRINT2N, "UDC_USBINTR (0x%08x)          : 0x%08x"
2688, PRINT2N, "UDC_FRINDEX (0x%08x)          : 0x%08x"
2689, PRINT2N, "UDC_DEVICEADDR (0x%08x)       : 0x%08x"
2690, PRINT2N, "UDC_EPLISTADDR (0x%08x)       : 0x%08x"
2691, PRINT2N, "UDC_BURSTSIZE (0x%08x)        : 0x%08x"
2692, PRINT2N, "UDC_EPNAK (0x%08x)            : 0x%08x"
2693, PRINT2N, "UDC_EPNAKEN (0x%08x)          : 0x%08x"
2694, PRINT2N, "UDC_PORTSC (0x%08x)           : 0x%08x"
2695, PRINT2N, "UDC_OTGSC (0x%08x)            : 0x%08x"
2696, PRINT2N, "UDC_USBMODE (0x%08x)          : 0x%08x"
2697, PRINT2N, "UDC_EPSETUPSTAT (0x%08x)      : 0x%08x"
2698, PRINT2N, "UDC_EPPRIME (0x%08x)          : 0x%08x"
2699, PRINT2N, "UDC_EPFLUSH (0x%08x)          : 0x%08x"
2700, PRINT2N, "UDC_EPSTAT (0x%08x)           : 0x%08x"
2701, PRINT2N, "UDC_EPCOMPLETE (0x%08x)       : 0x%08x"
2702, PRINT2N, "UDC_EPCTRL0 (0x%08x)          : 0x%08x"
2704, PRINT3N, "UDC_EPCTRL%d (0x%08x)         : 0x%08x"
2709, PRINT2N, "UDC_MCR (0x%08x)              : 0x%08x"
2710, PRINT2N, "UDC_UDC_ISR (0x%08x)          : 0x%08x"
2711, PRINT2N, "UDC_UDC_IER (0x%08x)          : 0x%08x"
2714, PRINT, "USB PHY Registers:"
2715, PRINT, "---------------------------------------"
2716, PRINT2N, "U2_PHY_PLL (0x%08x)           : 0x%08x"
2718, WARN, "   Bit 23 indicates PLL not stable"
2720, PRINT2N, "U2_PHY_TX (0x%08x)            : 0x%08x"
2721, PRINT2N, "U2_PHY_RX (0x%08x)            : 0x%08x"
2722, PRINT2N, "UDC_U2_PHY_T0 (0x%08x)        : 0x%08x"
2723, PRINT2N, "U2_PHY_IVREF (0x%08x)         : 0x%08x"
2724, PRINT2N, "UDC_U2_PHY_480 (0x%08x)       : 0x%08x"
2728, PRINT, "--[ Sequence of last USB interrupts received newest to oldest ]-----"
2731, PRINTN, "  0x%x"
2738, PRINT, "Bus Errors:"
2739, PRINT, "-------------------------------------"
2740, PRINTN, "Halt Count: %d"
2741, PRINTN, "Data Buffer Count: %d"
2742, PRINTN, "Transaction Count: %d"
2744, PRINT, "USB Clocks"
2745, PRINT, "-------------------------------------"
2805, PRINT, "UsbXtalOn()"
2819, PRINT, "HS-USB Clocks enabled"
2926, PRINT5N, "QhArray=0x%x EpInTdArray=0x%x EpOutTdArray=0x%x EpZlpTdArray=0x%x memory_for_stack_ptr==0x%x"
END FILE "FILE_USBDRV_TAVORPV", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\USB\\tavorpv\\usbdrv_tavorpv.c"

BEGIN FILE "FILE_CLOCKS", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\clocks.c"
88, PRINT4N, "Peripheral [%(_PeripheralClock)] Clock has been ON for %u ticks (total of %u ticks and %d%%)"
95, WARN, "ClockUptime is not provided by this platform"
148, WARNN, "Clock %(_PeripheralClock) already on"
255, WARNN, "Clock %(_PeripheralClock) already off"
315, PRINT, "Can't display clock statistics as uptime = 0"
324, PRINT4N, "Peripheral [%(_PeripheralClock)] Clocks have been ON for %u ticks (total of %u ticks and %d%%)"
327, PRINT3N, "Peripheral [%(_PeripheralClock)] Clocks are OFF (ON for total of %u ticks and %d%%)"
337, PRINTN, "Perpipheral [%(_PeripheralClock)] Clocks are ON"
339, PRINTN, "Perpipheral [%(_PeripheralClock)] Clocks are OFF"
343, PRINTN, "Peripheral Clocks that have been used: 0x%X"
346, PRINTN, "DSP Running Clocks %X"
452, PRINT2N, "<ROLLING CLOCK PROFILING time: 0x%x Tickrate: %u>"
454, PRINTN, "  Sample period %u"
458, PRINT3N, "Peripheral [%(_PeripheralClock)] Clocks are ON (total of %[!%u] ticks and %[%u*100/#]%%)"
461, PRINT3N, "Peripheral [%(_PeripheralClock)] Clocks are OFF (ON for total of %[!%u] ticks and %[%u*100/#]%%)"
465, PRINTN, "Peripheral Clocks that have been used: 0x%X"
466, PRINT, "</ROLLING CLOCK PROFILING>"
468, PRINT, "Rolling clock profile not enabled"
END FILE "FILE_CLOCKS", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\clocks.c"

BEGIN FILE "FILE_PROC_CLOCKS", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\tavor_clocks.c"
END FILE "FILE_PROC_CLOCKS", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\tavor_clocks.c"

BEGIN FILE "FILE_NTIMERS", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\timers\\ntimers.c"
247, ASSERTF, "Unallocated timer being used!"
276, PRINTN, "SetHwTimer: 0x%x"
314, WARN3N, "2 earliestMax: 0x%x, now: 0x%x, rtc: 0x%x"
325, WARN3N, "3 earliestMax: 0x%x, now: 0x%x, rtc: 0x%x"
335, PRINT, "Timer table:"
336, PRINTN, "head = %d"
338, PRINT5N, "%d. %dh %(TimerName) status=0x%x flags=0x%x"
340, PRINT5N, "    prev=%dh next=%dh -- set=%x min=%x max=%x"
344, PRINT3N, "    destTask=%(TaskID) cookie=0x%x callback=%p"
354, PRINT, "Timer enum: "
356, PRINT2N, "Timer %[!%d] is timer %(!TimerName)"
395, WARN, "Out of timers!"
401, WARN, "freelist out of range"
409, WARN, "freelist entry out of range"
439, WARN, "Empty Timer free list, ignored"
448, WARN, "list item out of range"
455, WARN, "Timer queue is corrupt! - next points out of timer queue"
460, WARN, "Timer queue is corrupt! - previous isn't right"
469, WARN, "Timer queue is corrupt! - min expiry greater than max expiry"
473, WARN, "Overflow: time value overflowed OK"
480, PRINT2N, "ERROR: NumTimersInQueue=%d but there are actually %d timers queued"
488, WARN3N, "Timers free %d + alloc %d != expected %d"
526, WARNN, "startTimer(%d) bad handle"
534, WARNN, "Tried to set timer %d with minDuration > maxDuration... Na ga da!"
542, WARNN, "Tried to set timer %d with minDuration == 0!  Bad!"
553, PRINT2N, "Timer %d %(TimerName) already running, try to stop"
555, PRINT2N, "Stop failed! Timer %d %(TimerName) expired or was stopped before it could be restarted"
566, PRINTN, "Someone pre-empted us and started timer %d ... Abort!  Abort!"
604, PRINT3N, "Start %d %(TimerName) task %(TaskID)"
647, WARN, "No more system Timers"
651, WARN, "No more system Timers"
659, ASSERTF, "Allocated timer on free list!"
736, WARNN, "OsTimerDelete(%d) bad handle ignored"
786, WARNN, "Illegal handle 0x%x"
799, WARN4N, "%(TaskID) stopping timer %d %(TimerName) for %(TaskID)"
802, WARN4N, "%(TaskID) stopping timer %d %(TimerName) for %(TaskID)"
816, PRINT4N, "Stopping periodic/extended timer %d %(TimerName) for task %(TaskID) / callback %p"
825, PRINT3N, "timer %d %(TimerName) id=x%x not running"
828, PRINT3N, "timer %d %(TimerName) id=x%x not running"
834, PRINT2N, "notInInterrupt destTask %(TaskID) myTask %(TaskID)"
840, PRINT, "OK removed from queue"
842, PRINT, "OK removed from queue"
848, PRINT4N, "No message from timer %d %(TimerName) id=x%x in message queue of task %(TaskID)"
851, PRINT4N, "No message from timer %d %(TimerName) id=x%x in message queue of task %(TaskID)"
857, PRINT3N, "Can't stop timer %d %(TimerName) id=x%x: already expired for another task!"
860, PRINT3N, "Can't stop timer %d %(TimerName) id=x%x: already expired for another task!"
865, PRINT3N, "Timer %d %(TimerName) id=x%x: already stopped"
873, PRINT4N, "Stopping timer %d %(TimerName) id=x%x for task %(TaskID)"
876, PRINT4N, "Stopping timer %d %(TimerName) id=x%x for task %(TaskID)"
881, PRINT, "Actually, this timer was already expired with handling delayed until powerup"
913, PRINT, "Stopped timer"
915, PRINT, "Stopped timer"
926, PRINTN, "Purged timer events=%d"
928, PRINTN, "Purged timer events=%d"
948, PRINTN, "removeTimerMessageFromQueue(0x%x)"
956, PRINTN, "Timer id=0x%x yoinked from queue!"
962, PRINTN, "no timer messages in Q match %(EVENT)"
979, PRINTN, "updateMsg %(EVENT)"
982, PRINTN, "no timer messages in Q match %(EVENT)"
1001, WARN3N, "1 earliestMax: %x, now: %x, rtc: %x"
1004, WARN, "Timer insertion in past... dealing with it..."
1007, PRINT, "Setting HW timer in insertTimer"
1041, PRINT2N, "ERROR: NumTimersInQueue=%d but there are actually %d timers queued"
1084, PRINTN, "Someone restarted or stopped periodic timer %d for us..."
1102, PRINTN, "Doing time extension on timer %d"
1108, PRINT, "High duration periodic restart (already extended)"
1120, WARN, "Dropping an integral number of periods"
1128, PRINT4N, "Restarted timer %d %(TimerName) using delta=%d=0x%x:"
1129, PRINTN, "    0x%x status"
1130, PRINTN, "    0x%x setTime"
1131, PRINTN, "    0x%x minExpiryTime"
1132, PRINTN, "    0x%x maxExpiryTime"
1158, PRINT4N, "Expiring timer %d %(TimerName)) at time %x, to send to task %(TaskID)"
1206, PRINTN, "Periodic or high duration timer %d expired..."
1225, PRINTN, "Posting to %(TaskID)"
1227, PRINTN, "Posting to %(TaskID)"
1262, PRINTN, "NDoTimerExpiry() entered at %x"
1274, PRINT3N, "num 0x%x exp 0x%x RTC 0x%x"
1279, WARN2N, "Late!  min 0x%x max 0x%x"
1288, PRINT3N, "Late: %d  On time: %d  Average: %d"
1309, PRINTN, "Timer %d expiry delayed until device powered on"
1340, PRINT, "Another timer expired... redoing expiry"
1343, PRINT, "Setting HW timer in expiry..."
1347, PRINTN, "ERROR: NumTimersInQueue=0, but head=%d"
1408, WARN2N, "4 earliestMax: 0x%x, rtc: 0x%x"
1435, ASSERTF4N, "Timer task got spurious message, dev=%x Event=0x%x sub=%x d0=%x"
1444, PRINTN, "IGNORING illegal restart handle %d"
1450, PRINT2N, "Restarting %d %(TimerName)"
1459, PRINT, "Running expiry routine from timer task"
1469, WARNN, "Got invalid message %d"
1497, PRINTN, "Adjust time to %x"
1502, PRINTN, "=> %d"
1512, PRINT2N, "OsTimerRemainingTime(%d) => %x"
1514, WARNN, "Illegal handle %d"
1526, WARNN, "NTimerRemaining with invalid timer %(TimerName)"
1533, WARNN, "NTimeRemaining on unstarted timer %d"
1536, PRINT3N, "NTimeRemaining(%(TimerName) h=%d) => %x"
1553, PRINT2N, "%d. free (%x)"
1557, PRINT4N, "%d. h=%d %(TimerName) st=%x"
1559, PRINT, "== not in use"
1564, PRINTN, "JvmMap free=%d"
1585, PRINT3N, "Slot in use uVal=%x %d status %x"
1587, PRINTN, "== not being used %x"
1592, WARNN, "RimGetNumberOfFreeTimers is deprecated, use RimTimerCreate to get available timer. #avail %d"
1638, PRINT3N, "TimerLookupUserValue( %x ) : %(TimerName) %d"
1657, PRINTN, "TimerLookupUserValue(%x) No slots left"
1676, WARN2N, "RimSetNativeTimer is deprecated, use RimTimerCreate+RimTimerStart. uValue=x%08x ticks=%d"
1680, WARN2N, "Not AppThread(%d) = %d"
1709, WARN2N, "RimSetNativeTimer time too long: ID %x Duration %u"
1714, WARNN, "RimSetNativeTimer time too short: ID %x Duration 0"
1719, WARN2N, "App timer %x: invalid type %x.  Not started"
1738, WARNN, "RimKillTimer is deprecated, use RimTimerStop+RimTimerDelete. uValue=x%08x"
1756, WARNN, "RimKillTimer(%x) not in table"
1770, WARN2N, "RimKillTimer(%x) OsTimerStop(%d) failed"
1792, WARN, "ExpireTimersOnPowerUp must not be called while the system is off"
1803, PRINT3N, "ExpireTimersOnPowerUp: handle=%d task=%(TaskID) cookie=0x%x"
1841, WARN2N, "RimTimerStart time too long: ID %d Duration %u"
1846, WARNN, "RimTimerStart time too short: ID %d Duration 0"
1851, WARN2N, "App timer %x: invalid type %x.  Not started"
1932, WARNN, "Timer %d too big"
1946, WARNN, "Start timer %(TimerName) could not create!"
1953, WARNN, "hMapped start timer(%d) bad handle"
2009, WARNN, "Tried to set invalid timer %(TimerName)"
2015, PRINTN, "Stopping non-started timer %(TimerName)"
2030, PRINT, "Initializing Quincy Counters for TimerPool"
END FILE "FILE_NTIMERS", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\timers\\ntimers.c"

BEGIN FILE "FILE_IDLETASK", "GROUP_SYSTEM", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\tasks\\idletask.c"
245, PRINT, "Idle Task started"
265, PRINT2N, "Debug Bomb writing %d bugdisp messages on pass %d (including this one)"
268, PRINT3N, "Debug Bomb! %d/%d of pass %d"
278, PRINT, "Debug bomb test finished"
END FILE "FILE_IDLETASK", "GROUP_SYSTEM", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\tasks\\idletask.c"

BEGIN FILE "FILE_DEBUG", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\tasks\\debugtask.c"
290, PRINTN, "%u"
291, PRINTN, "%u"
292, PRINTN, "%u"
293, PRINTN, "%u"
294, PRINTN, "%u"
295, PRINTN, "%u"
296, PRINTN, "%u"
297, PRINTN, "%u"
298, PRINTN, "%u"
299, PRINTN, "%u"
300, PRINTN, "%u"
301, PRINTN, "%u"
390, PRINT2N, "Crypto Response = %d, %d"
397, PRINT, "Crypto Info Passed"
399, PRINT, "Crypto Info Failed"
507, PRINT, "PLATFORM SOFTWARE HOOK"
525, PRINTN, "GpioAltFunc2[0]=0x%X"
526, PRINTN, "GpioAltFunc2[1]=0x%X"
527, PRINTN, "GpioAltFunc2[2]=0x%X"
528, PRINTN, "GpioAltFunc2[3]=0x%X"
529, PRINTN, "GpioAltFunc2[4]=0x%X"
530, PRINTN, "GpioAltFunc2[5]=0x%X"
531, PRINTN, "GpioAltFunc2[6]=0x%X"
532, PRINTN, "GpioAltFunc2[7]=0x%X"
534, PRINTN, "EgpioAltFunc2[0]=0x%X"
535, PRINTN, "EgpioAltFunc2[1]=0x%X"
536, PRINTN, "EgpioAltFunc2[2]=0x%X"
537, PRINTN, "EgpioAltFunc2[3]=0x%X"
539, PRINTN, "GpAltFunc2[0]=0x%X"
540, PRINTN, "GpAltFunc2[1]=0x%X"
541, PRINTN, "GpAltFunc2[2]=0x%X"
542, PRINTN, "GpAltFunc2[3]=0x%X"
543, PRINTN, "GpAltFunc2[4]=0x%X"
544, PRINTN, "GpAltFunc2[5]=0x%X"
545, PRINTN, "GpAltFunc2[6]=0x%X"
546, PRINTN, "GpAltFunc2[7]=0x%X"
548, PRINTN, "PadSlewControl2[0]=0x%X"
549, PRINTN, "PadSlewControl2[1]=0x%X"
551, PRINTN, "PadDriveControl2[0]=0x%X"
552, PRINTN, "PadDriveControl2[1]=0x%X"
554, PRINTN, "PadDriveValue2[0]=0x%X"
555, PRINTN, "PadDriveValue2[1]=0x%X"
556, PRINTN, "PadDriveValue2[2]=0x%X"
557, PRINTN, "PadDriveValue2[3]=0x%X"
558, PRINTN, "PadDriveValue2[4]=0x%X"
559, PRINTN, "PadDriveValue2[5]=0x%X"
579, PRINT, "The following debugger extensions are available:"
580, PRINT, "x tq         Dump timer queue"
581, PRINT, "x tl         Dump timer enum"
582, PRINT, "x b          List Hermon / Argon Breakpoint Commands"
583, PRINT, "x h          Display the HIS state"
584, PRINT, "x he         Enable HIS"
585, PRINT, "x hd         Disable HIS"
586, PRINT, "x J          Set/clear JVM bit"
587, PRINT, "x jr <i>     Read DspSM at index <i>"
588, PRINT, "x jw <i> <v> Write value <v> to DspAudioSM at index <i>"
589, PRINT, "x jd {0,1}   PCM audio logging enable (1) or disable (0)"
590, PRINT, "x jm <i>     Set Audiomode <i>"
591, PRINT, "x jn <i>     Set PTT Audiomode <i>"
592, PRINT, "x jp         Dumps audio context"
593, PRINT, "x P          Dump power management profile ratios"
594, PRINT, "x v<0|1|...> Battery/Charger related commands"
595, PRINT, "x s          SPI Config/Read/Write commands"
596, PRINT, "x x          Invokes a hardware reset"
597, PRINT, "x y          Dumps pre-reset BugDisp log"
598, PRINT, "x ysd        Saves pre-reset BugDisp log to SD card"
599, PRINT, "x d0 or d1   Device powerdown(d0) or power up(d1)"
600, PRINT, "x dc{0,1}[!] Hold comms subsystem on (dc1) or remove hold state (dc0)"
601, PRINT, "                dc0! forces comms off (regardless of radio, audio)"
602, PRINT, "                dc1! removes forced off state"
603, PRINT, "x T          Get device side timestamp"
604, PRINT, "x C          Camera commands"
605, PRINT, "x L          LCD commands"
606, PRINT, "x LS         Light sensor commands"
607, PRINT, "x LV         Log verbosity commands"
608, PRINT, "x w          Prints the return value of RimIsRebooting"
609, PRINT, "x us         Dump SDL process states"
610, PRINT, "x e          List extended USB commands"
611, PRINT, "x ut         Dump SDL timers"
612, PRINT, "x n          Cryto-Battery Test Commands"
613, PRINT, "x B?         Backlight commands"
614, PRINT, "x df         Disable Fast Reset (ensures JVM won't fast reset next reset"
615, PRINT, "x D0 or D1   Fake battery door OPENED or CLOSED"
616, PRINT, "x Hc <user>  Configure HSL user.  <user> bits:"
617, PRINT, "                1 - Event log"
618, PRINT, "                2 - Debug test"
619, PRINT, "                4 - Third party HSL user"
620, PRINT, "x Hf <filt>  [15,14] index bits, [13,0] filter bits"
621, PRINT, "x Htc <num>  Send counter to HSL upto <num>"
622, PRINT, "x Hte <num>  Send <num> test events to HSL"
623, PRINT, "x Hts <msg>  Send single <msg> to HSL 100 times"
624, PRINT, "x i          I2C Read/Write Commands"
625, PRINT, "x go         Activate Bugdisp Logging to mass storage file"
626, PRINT, "x gs         Stop Bugdisp Logging to mass storage file"
627, PRINT, "x gr         Remove all Bugdisp Logs from mass storage (stops logging)"
628, PRINT, "x gy         Saves pre-reset BugDisp log to mass storage file"
629, PRINT, "x g?       Display current mass storage logging status and list all commands"
630, PRINT, "x ipc<num1><num2> Transfer test data from core num1 to core num2"
631, PRINT, "x ipcnv<core><act> NVRAM cross core api tests"
632, PRINT, "                   <core> = Dsp, Arm = Core to Test"
633, PRINT, "                   <act> = G,U,D = (G)et,(U)pdate,(D)elete, records"
634, PRINT, "x 1          NAND flash commands"
635, PRINT, "x U          UTC test commands"
636, PRINT, "x w?         List 802.11 WLAN Radio Controls"
637, PRINT, "x WafBufferTests"
638, PRINT, "             Run some WAF buffer API tests"
639, PRINT, "x S          Socket debug extensions"
640, PRINT, "x mem_dump <addr> <len> Memory dump of <len> bytes starting at <addr> (in hex)"
641, PRINT, "x Z          Dump the Long Persistence Bugdisp buffer into the main buffer"
642, PRINT, "x $          SDCard commands"
643, PRINT, "x al         Display all the audio logs recorded"
644, PRINT, "x I          Run Iden extended commands"
645, PRINT, "x V          Run ADC channel commands"
646, PRINT, "x GFX        Graphics commands"
659, PRINT, "w          SPI Write command w<address><data>"
660, PRINT, "r          SPI Read command r<address>"
662, PRINT, "c          SPI Config command c<rxBitLength><txBitLength><csPolarity>"
664, PRINT, "c          SPI Config command c<rxBitLength><txBitLength><csInUse><csPolarity><csGpio>"
666, PRINT, "SPI commands not supported for this platform"
685, PRINT3N, "Configured SPI with rxBitLength=%d, txBitLength=%d, cs.polarity=%d"
688, PRINT5N, "Configured SPI with rxBitLength=%d, txBitLength=%d, csInUse=%d, csPolarity=%d, csGpio=%d"
703, PRINT2N, "Address: %x Data: %x"
707, WARN, "Unknown SPI command"
713, PRINT2N, "Starting 30-second burst of messages from core %d at %d kB/s"
729, WARN, "Unkown FAT profiling command"
743, WARN, "Unknown DumpTimer command"
751, PRINT, "Starting Battery Authentication"
756, PRINT, "Loading look-up-tables"
761, PRINT, "CryptoBattery Commands"
762, PRINT, "----------------------------------"
763, PRINT, "x na    Perform Authentication"
764, PRINT, "x nl    Load look-up-table info"
768, WARN, "RIM_CRYPTO_BATTERY not defined"
781, PRINT2N, "Current UTC time is: 0x%08X %08X"
786, PRINT2N, "Setting UTC time to: 0x%08X %08X"
789, PRINT, "No input time found, not setting UTC time"
795, PRINT, "UTC Test Commands"
796, PRINT, "-----------------------"
797, PRINT, "x U.i      init UTC Time"
798, PRINT, "x U.T      Get UTC Time"
799, PRINT, "x U.T<num> Set UTC Time (num is hex)"
805, PRINTN, "RimResetReason returned %(RESET_REASON)"
810, WARN, "WLAN not supported in this build!"
816, PRINT, "Head in Sand is ON"
818, PRINT, "Head in Sand is OFF"
826, PRINT, "Head in Sand ENABLED"
830, PRINT, "Head in Sand DISABLED"
833, WARN, "unknown command - try 'x he' or 'x hd'"
843, PRINT, "user-requested timestamp"
850, PRINT, "logging timestamps from device side"
854, PRINT, "suppressing timestamps from device side"
858, WARN, "unknown command - try 'x T', 'x T0', or 'x T1'"
871, PRINT, "13M Clk & Wifi Profiling Disabled"
875, PRINT, "13M Clk & Wifi Profiling Enabled"
880, PRINT, "Available Profile Commands"
881, PRINT, "--------------------------"
882, PRINT, " x P   Dump power management profile ratios "
884, PRINT, " x P1  Enable 13MClk & Wifi profile ratios "
885, PRINT, " x P0  Disable 13MClk & Wifi profile ratios "
889, WARN, "unknown command - try 'x P?' for list of commands"
896, PRINT, "CPU -> DSP -> CPU test test started "
910, PRINT, "Faking battery door OPENED"
914, PRINT, "Faking battery door CLOSED"
918, PRINT, "Use 0 = OPENED, 1 = CLOSED"
922, WARN, "BAT_DR_DET_N is not defined"
940, WARN, "Saving pre-reset bugdisp log to SD card is unsupported"
945, PRINT, "============ START OF LP LOGS ============="
954, PRINT, "============ END OF LP LOGS ============="
957, WARN, "LP Logging not supported"
962, WARN, "Memory has been corrupted!  Attempting to dump pre-reset log anyway"
964, WARN, "Detected we are booting from a loss of power!"
965, WARN, "Trying to dump log anyway."
970, PRINT, "============ START OF LP LOGS ============="
979, PRINT, "============ END OF LP LOGS ============="
990, PRINT4N, "BqHugeInitialUtc %u, SavedBqHugeInitialUtc %u, SavedUtcOnWdtHit %u, SavedInitialUtc %u"
991, PRINTN, "Time from last WdtHit() to bootup: %u ms"
994, PRINT, "Device is SECURE"
996, PRINT, "Device is INSECURE"
1000, PRINT3N, "CurrentDisablerLR: %p, CoreIntDisableLR: %p, FastCoreIntDisableLR: %p"
1003, PRINT, "============ START OF PRE-RESET LOGS ============="
1012, PRINT, "============ END OF PRE-RESET LOGS ============="
1024, WARN, "Initiate Reset command was received"
1034, PRINT2N, "Memory dump of %d bytes starting at address 0x%08X"
1039, SHOW_MEMORY, "Memory:"
1044, SHOW_MEMORY, "Memory:"
1049, WARN, "Device does not support specified command"
1057, PRINT, "Dsp Library information"
1059, PRINTCOPY, " Audio: %s"
1061, PRINT, " Audio: version API unsupported"
1064, PRINTCOPY, " Radio: %s"
1066, PRINT, " Radio: version API unsupported"
1069, PRINTCOPY, " Gesture: %s"
1072, PRINT2N, "DspSmRead(%d) = %d"
1075, PRINT2N, "DspSmWrite(%d, %d)"
1105, PRINTN, "Setting audio mode %(RimAudioMode_t)"
1109, PRINTN, "Setting ptt audio mode %(RimAudioMode_t)"
1147, PRINTN, "Setting Video Decoder Delay by %d ms"
1153, PRINTN, "Setting video post processing to %d"
1183, PRINT, "*** Note **** Both of these commands wipe any previous simulation fuses and delete the appstore/RimCrypt key stores."
1184, PRINT, "x !FE        Enable fuse simulation"
1185, PRINT, "x !FD        Disable fuse simulation"
1188, PRINT, "Simulated BSIS fuses not supported on this platform."
1200, PRINTN, "Unknown RimCrypt command '%c'"
1211, PRINT2N, "setting %(NvramBitFlag)=%d"
1221, PRINT2N, "setting %(NvramBitFlag)=%d"
1255, PRINT, "Disabling Fast Resets"
1301, PRINT, "MS Profiling info reset"
1307, WARNN, "Unknown command: %c"
1339, WARNN, "Unknown command: %c"
1353, WARNN, "Field must be beteween 0 and %d"
1359, WARNN, "Unknown command: %c"
1374, WARNN, "Channel must be between 0 and %u"
1381, WARNN, "Channel must be between 0 and %u"
1388, WARNN, "Channel must be between 0 and %u"
1394, WARNN, "Unknown command: %c"
1419, WARNN, "Unknown command: %c"
1429, PRINT2N, "Calling UsbSwitchMode( %(_USB_ENUM_MODE), 0x%x"
1433, PRINT2N, "Result: RETURN=%(_USB_ERROR_CODE), vetoMask=0x%x"
1441, PRINTN, "Toggling BdVetoOn to %d"
1453, WARN, "unknown command"
1464, WARNN, "Unknown command: %c"
1482, PRINTN, "SubItf bitmask: 0x%02x"
1485, PRINT, "Must provide a sub interface bitmask!"
1492, PRINT, "USB Extended commands"
1493, PRINT, "----------------------------------"
1494, PRINT, "x e!    Catfail[FAILURE_USB_DRIVER]"
1495, PRINT, "x el    Enum at 100mA only"
1496, PRINT, "x eh    Enum at 500mA only"
1497, PRINT, "x er    Re-enum if 500mA available"
1498, PRINT, "x em    Print MUX info"
1499, PRINT, "x eq    Print MUX queue info"
1500, PRINT, "x ev    Reduce the verbosity of USB"
1501, PRINT, "x es    Toggle Mass Storage NV flag"
1502, PRINT, "x et    Toggle MTP NV flag"
1503, PRINT, "x ed    Dump registers information"
1505, PRINT, "x efp   Print simple profiling info"
1506, PRINT, "x efr   Reset simple profiling info"
1507, PRINTN, "x efs n Sort simple profiling data on field n (0 - %d)"
1510, PRINT, "x epvr n Change the field U2_PHY_RX_SQ_THRE of register U2_PHY_RX to n (n<=15)"
1513, PRINT, "x ecp   Print channel profiling info"
1514, PRINT, "x ecr   Reset all channel profiling info"
1515, PRINTN, "x ecc n Reset profiling info for channel n (0 - %u)"
1516, PRINTN, "x ece n Enable profiling of channel n (0 - %u)"
1517, PRINTN, "x ecd n Disable profiling of channel n (0 - %u)"
1520, PRINT, "x emsp  Print ms profiling info"
1521, PRINT, "x emsr  Reset all ms profiling info"
1524, PRINT, "x ea n   Run Antioch loopback test for n iterations"
1527, PRINT, "x ete   Run MTP API Test"
1528, PRINT, "x etd   Disable and reset MTP API Test"
1531, PRINT, "x ei    Print maximum time spent in USB ISR"
1532, PRINT, "x ep<bd><mux><vsp1><vsp2><ms> Sets a specific Antioch EP configuration "
1533, PRINT, "    <bd><mux><vsp1><vsp2><ms> - Physical endpoit pair = (0,1)"
1534, PRINT, "    The changes are applied after reconnecting the USB cable"
1535, PRINT, "    Default configuration: x ep01011 and reconnect USB the cable"
1537, PRINT, "x eM <mode> <vetoMask> Force Mode switch (Mode switch API)"
1538, PRINT, "x ey    toggle bugdisp veto 0n/0ff"
1542, WARN, "Device does not support USB"
1584, PRINT, "Breakpoints are not supported on secure devices"
1596, PRINT, "Breakpoints are not supported on secure devices"
1611, PRINT3N, "Wrote Codec[0x%02X 0x%02X] = 0x%02X"
1614, PRINT2N, "Wrote Codec[0x%02X] = 0x%02X"
1618, PRINT2N, "Read Codec[0x%02X] == 0x%02X"
1620, PRINT2N, "Read Codec[0x%02X] == 0x%02X"
1626, PRINT2N, "Read ABC[0x%02X] == 0x%02X"
1629, PRINT2N, "Wrote Codec[0x%02X] = 0x%02X"
1700, PRINTN, "mic %d mVrms"
1701, PRINTN, "mic %d delta"
1702, PRINTN, "receiver %d mVrms"
1703, PRINTN, "receiver %d delta"
1716, PRINT, "Unknown audio codec command, valid commands are:"
1719, PRINT, "x oa {0|1}           - Dis/Enable DspAvpProcess by Mode or Volume Change"
1721, PRINT, "x ow <addr> <data>   - Write <data> to Codec register <addr>"
1722, PRINT, "x or <addr>          - Read from Codec register <addr>"
1723, PRINT, "x oo <addr> <data>   - Write <data> to ABC register <addr>"
1724, PRINT, "x oi <addr>          - Read from ABC register <addr>"
1725, PRINT, "x op                 - abc toggle between pb and pb/rec"
1726, PRINT, "x od                 - Dump context"
1727, PRINT, "x oc                 - Turn codec ctrl clock on"
1728, PRINT, "x ox                 - Turn codec ctrl clock off"
1729, PRINT, "x om <mVrms> <offset>- Set mic mVrms and delta nvram"
1730, PRINT, "x on <mVrms> <offset>- Set receiver mVrms and delta nvram"
1731, PRINT, "x ob                 - Read trimming parameters from nvram"
1732, PRINT, "x oe                 - run mono/stereo detection"
1733, PRINT, "x ok[lru]            - mute left, right and unmute"
1736, PRINT, "MAXIM_AUDIO_CODEC not defined"
1741, WARN, "RIM_HSL not defined"
1777, PRINTN, "NvRam Debug [Core%d]: Testing Cross Core NVRAM calls"
1781, PRINTN, "NvRam Debug [Core%d]: Test 1 - NvGetRecordCopy"
1788, PRINTN, "NvRam Debug [Core%d]: Test 2 - NvUpdateRecord"
1795, PRINTN, "NvRam Debug [Core%d]: Test 3 - NvDeleteRecord"
1802, WARNN, "Unknown command: %c"
1861, WARN, "IPC tests stubbed!"
1872, WARN2N, "I2C Read Failed: DeviceAddr 0x%X Register 0x%X"
1874, PRINT3N, "I2C Read: DeviceAddr 0x%X Register 0x%X Value 0x%X"
1884, PRINT3N, "I2C Write: DeviceAddr 0x%X Register 0x%X Value 0x%X"
1886, WARN2N, "I2C Write Failed: DeviceAddr 0x%X Register 0x%X"
1900, WARN3N, "I2C Read Failed: DeviceAddr 0x%X Register 0x%X%X"
1902, PRINT4N, "I2C Read: DeviceAddr 0x%X Register 0x%X%X Value 0x%X"
1914, WARN3N, "I2C Write Failed: DeviceAddr 0x%X%X Register 0x%X"
1916, PRINT4N, "I2C Write: DeviceAddr 0x%X Register 0x%X%X Value 0x%X"
1929, PRINT, "I2C Bugdisp Error: Invalid syntax"
1933, PRINT, "I2C Bugdisp Error: invalid range"
1936, PRINT3N, "I2C Read: Device 0x%X ( 0x%02X - 0x%02X )"
1937, PRINT, "------------------------"
1938, PRINT, "(Reg): (Contents)"
1943, PRINT2N, " 0x%02X: 0x%02X"
1964, PRINT, "I2C Bugdisp Error: Invalid syntax"
1968, PRINT, "I2C Bugdisp Error: invalid range"
1971, PRINT3N, "I2C Read: Device 0x%X ( 0x%04X - 0x%04X )"
1972, PRINT, "------------------------"
1973, PRINT, " (Reg): (Contents)"
1981, PRINT2N, "0x%04X: 0x%02X"
1994, PRINT, "Test I2C Syntax:"
1995, PRINT, "----------------"
1996, PRINT, "read (8bit Address):                 x irIIAA"
1997, PRINT, "write(8bit Address):                 x iwIIAABB"
1998, PRINT, "read range (8bit Address):           x idIIAA-AA"
1999, PRINT, "read (16bit Address):                x iRIIAAAA"
2000, PRINT, "write(16bit Address):                x iWIIAAAABB"
2001, PRINT, "read range (16bit Address):          x iDIIAAAA-AAAA"
2002, PRINT, "print I2C profile data:              x ip"
2003, PRINT, "II = Device Address (hex)"
2004, PRINT, "AA = Register Address (hex)"
2005, PRINT, "BB = Value (hex)"
2010, PRINT, "I2C commands not supported"
2018, PRINT, "Commands for Logging To Mass Storage"
2019, PRINT, "-----------------------------------------------------------------------------"
2021, PRINT, "x gds      Set logging file destination to SD Card"
2022, PRINT, "x gdm      Set logging file destination to built-in MMC"
2029, PRINT, "x go       Activate Bugdisp Logging to mass storage file"
2030, PRINT, "x gs       Stop Bugdisp Logging to mass storage file"
2031, PRINT, "x gr       Remove all Bugdisp Logs from mass storage (stops logging)"
2032, PRINT, "x gy       Saves pre-reset BugDisp log to mass storage file"
2033, PRINT, "x gas 0    Disable auto-save of pre-reset log"
2034, PRINT, "x gas 1    Enable auto-save of pre-reset log to selected mass storage*"
2035, PRINT, "x gam 0    Disable auto-move of saved logs"
2036, PRINT, "x gam 1    Enable  auto-move of saved logs to selected mass storage*"
2037, PRINT, "           *NOTE: When enabled, auto-save/-move occurs during reset"
2044, PRINT, "x g?       Display this message"
2045, PRINT, "-----------------------------------------------------------------------------"
2046, PRINT, "CURRENT STATUS:"
2049, PRINT, "Logging Destination:                 Built-in MMC Memory"
2053, PRINT, "Logging Destination:                 SDCard Memory"
2056, PRINT, "Mass Storage Memory:                 AVAILABLE"
2058, PRINT, "Mass Storage Memory:                 NOT AVAILABLE"
2062, PRINT, "Bugdisp Logging to memory:           ENABLED"
2064, PRINT, "Bugdisp Logging to memory:           DISABLED"
2067, PRINT, "Auto-Save pre-Reset Log during init: ENABLED"
2069, PRINT, "Auto-Save pre-Reset Log during init: DISABLED"
2072, PRINT, "Auto-Backup Logs during init:        ENABLED"
2074, PRINT, "Auto-Backup Logs during init:        DISABLED"
2086, PRINT, "Enabling bugdisp logging to MMC"
2090, PRINT, "Enabling bugdisp logging to SD Card"
2094, PRINT, "Cannot enable bugdisp logging on secure device"
2101, PRINT, "Disabling bugdisp logging"
2111, PRINT, "Disabling bugdisp logging"
2112, PRINT, "Removing all bugdisp logs"
2141, WARN, "Unknown Logging Command. ('x g?' for valid commands)"
2163, WARN, "Unknown Logging Command. ('x g?' for valid commands)"
2173, PRINT, "Saving pre-reset log to SD Card"
2177, PRINT, "Saving pre-reset log to MMC"
2185, PRINT, "Unrecognized SD card logging command. ('x g?' for valid commands)"
2188, PRINT, "SD logging commands not supported"
2199, PRINT, "Unknown Command"
2202, PRINT, "Audio Logging not supported"
2216, PRINT, "RTSP not supported"
2224, PRINT, "RTSP not supported"
2242, WARN, " --- Start of Long Persistence Bugdisp data ---"
2244, WARN, " --- End of Long Persistence Bugdisp data ---"
2251, PRINT, "Process Iden cmds"
2254, PRINT, "Process Iden cmd completed"
2256, WARN, "x I not implemented!"
2284, PRINT, "Test OSGRC:"
2290, PRINT3N, "***Test case %d (0x%x, 0x%x)***"
2293, PRINT4N, "%d: 0x%x, 0x%x: %d"
2301, PRINTCOPY, "Unrecognized command: %s"
2302, PRINT2N, "ExtAddress=0x%x, ExtLength=0x%x"
2317, WARN, "PostCmdtoDSP stubbed -- FIXME!"
2329, WARN, "PostCmdtoDSP called before IPC was initialized & while catfailed, message discarded"
2434, PRINT, "Got DCMD_SECURE_HELLO"
2436, PRINT, "Ignoring, since this device is not RTAS_capable"
2440, WARN, "Bad length for DCMD_SECURE_HELLO -- ignoring"
2448, WARN, "Bad cookie for DCMD_SECURE_HELLO -- ignoring"
2470, PRINT2N, "Talking to wBugdisp version %d.%d"
2474, PRINT, "Talking to an old wBugdisp"
2536, PRINT, "Bugdisp Enabled (No password set)"
2553, PRINT, "Bugdisp Enabled (No password set)"
2560, PRINT, "Wbugdisp can accept (8k-1)B packets; this would be relevant if we were not using the mux"
2562, PRINT, "Recent (as of Aug 28 2002) wbugdisp; we will be using (8k-1)B packets"
2565, PRINTN, "Maximum send size for BugDisp USB channel on this device is set to %d bytes. Setting MaxBugdispUsbPacket appropriately"
2583, PRINT, "Got DCMD_DISCONNECT, but already disconnected"
2585, PRINT, "Disconnecting Bugdisp"
2594, WARNN, "Bad cookie for DCMD_DISCONNECT - %08x (not disconnecting)"
2609, PRINT, "Bugdisp authenticated"
2669, WARN, "Cannot display registers since we're not crashed"
2671, PRINT, "Failure Registers"
2732, ASSERTF, "bad argument in DCMD_TARGET_FILTER"
2758, WARN, "Resetting bugdisp read pointer to resend all the log we have for core 0."
2762, WARNN, "Resetting bugdisp read pointer to resend all the log we have for core %d."
2766, WARN, "Resetting bugdisp read pointers to resend all the log we have for all cores."
2773, WARN, "Resetting bugdisp read pointer to resend all the log we have."
2787, PRINT, "dsplog off - turning off DSP logging"
2794, PRINT, "dsplog on - turning on DSP logging"
2825, PRINT2N, "Unhandled command (c=%x, %08x)"
2857, WARN, "Keypad Driver not compiled in"
2893, WARNN, "Unhandled radio event=%(EVENT)"
2911, PRINT, "USB_QUINCY_TIMER expired. Re-enabling USB Quincies"
2916, PRINT2N, "USB_INVALID_STATE_TIMER %d, count = %d"
2925, PRINT, "USB_INVALID_STATE_TIMER: BBONLY, Toggling D+ to kick-start enumeration"
2938, PRINT, "USB_INVALID_STATE_TIMER: AC Charger Detected, configuring USB port"
2946, PRINT, "USB_SOFTCONNECT_TIMER"
2962, PRINT, "USB_CD_DEBOUNCE_TIMER"
2986, WARNN, "Unexpected timer Event, 0x%x"
3000, WARN, "Dumping DSP debug message queue"
3079, WARNN, "Unhandled device message: 0x%X"
3092, PRINT, "Debug task started"
END FILE "FILE_DEBUG", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\tasks\\debugtask.c"

BEGIN FILE "FILE_BUGDISP_CMDS", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\debug\\bugdisp_cmds.c"
138, WARN, "Invalid line specification"
223, WARN, "Duplicate registration attempt for bugdisp command group:"
225, WARN2N, "Old handler = %p, new handler = %p"
230, WARNN, "Too many command groups registered already.  Handler = %p"
295, PRINT3N, "Patching address %8.8x with data %8.8x, length %d"
405, WARNN, "Ignoring debug message %d"
427, PRINTN, "Executing command --> %[bugtext]"
434, WARNN, "No handler found for bugdisp command group: %[bugtext]"
442, WARNN, "can't dump more than 0x%04x bytes at once if not catfailed"
487, ASSERTF, "Too many bytes to write"
496, ASSERTF, "FlashWrite not supported"
503, SHOW_MEMORY_ADDRESS, "Wrote %08x:"
513, PRINT2N, "in(%x) = %02x"
518, PRINT2N, "in(%x) = %04x"
523, PRINT2N, "in(%x) = %08x"
528, PRINT2N, "out %x,%02x"
534, PRINT2N, "out %x,%04x"
540, PRINT2N, "out %x,%08x"
547, PRINT3N, "%(_IOTYPE)_%d value is %d"
556, PRINT3N, "Setting %(_IOTYPE)_%d to %d"
566, PRINT3N, "Setting %(_IOTYPE)_%d to alternate function %d"
597, WARN2N, "Undefined bit i/o control function %c%c specified"
605, PRINT5N, "Setting %(_IOTYPE)_%d(%c%c) to %d"
END FILE "FILE_BUGDISP_CMDS", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\debug\\bugdisp_cmds.c"

BEGIN FILE "FILE_USBTASK", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\tasks\\usbtask.c"
116, PRINT, "USB_INT_N_ENABLE_TIMER"
152, PRINTN, "HP_MUX_Register Channel: %d"
156, PRINTN, "HP_MUX_DeRegister Channel: %d"
160, PRINTN, "HP_MUX_Open Channel: %d"
164, PRINTN, "HP_MUX_Send Packet: %d"
168, PRINTN, "HP_MUX_ADD_RECV_BUFF Packet: %d"
177, PRINT2N, "FAILED MESSAGE EVENT: %d, Channel: %d"
201, PRINT, "USB Message ignored"
204, WARN3N, "Unexpected message: Device: %d, Event: %d, SubMsg: %d"
END FILE "FILE_USBTASK", "GROUP_USB", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\tasks\\usbtask.c"

BEGIN FILE "FILE_DBSERJTG", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\debug\\DbSerJtg.c"
288, ASSERT, "No saved apps LP buffer???"
292, WARN, "Could not find any data in saved apps LP buffer!"
304, ASSERT, "No saved radio LP log???"
308, WARN, "Could not find any data in saved radio LP buffer!"
323, WARN, "pCirBuf is NULL!"
336, WARN, "Old saved debug TX buffer was not bugdisp output"
355, ASSERT, "No SavedDebugTx???"
369, ASSERT, "No pre-reset radio/dsp bugdisp buffer???"
377, WARNN, "=========Log for core %u is not valid!========="
496, ASSERTF3N, "BugDisp USB Overflow, trying to queue buffer %d, ptr 0x%x, length %d"
498, PRINT4N, "  Queue element %d: buf %d, ptr 0x%x, length %d"
501, PRINT4N, "  Queue element %d: buf %d, ptr 0x%x, length %d"
520, WARN, "USB Channle is not open yet"
554, ASSERTF3N, "BugDisp USB Overflow, trying to queue buffer %d, ptr 0x%x, length %d"
556, PRINT4N, "  Queue element %d: buf %d, ptr 0x%x, length %d"
559, PRINT4N, "  Queue element %d: buf %d, ptr 0x%x, length %d"
732, PRINT, "All bugdisp since reset present"
741, PRINT, "Finished sending all backlog"
864, PRINT, "CatfailCheckUsbState(): Device is in MS-Only mode. We need to get out of this mode"
873, PRINT, "Forcing a USB Disconnect to be on the safe side"
893, PRINT, "Turning off Mass Storage for all media"
1134, WARN, "Invalid Bugdisp feature request"
1143, WARN, "Invalid Bugdisp feature request"
1146, PRINT2N, "RimLogging %(BugDispRequests) %(TRUE_FALSE)"
1186, PRINT2N, "Unhandled RimLogging %(BugDispRequests) %(TRUE_FALSE)"
1209, WARN3N, "DebugOutputBomb: Invalid parameter. Core: %d, rate: %d, duration: %d. (Min Rate 10kb/s)"
1224, WARN, "Apps core debug bomb is already being dropped"
1243, WARN, "DebugOutputBomb: Remote core debug bomb not supported on this platform"
1254, PRINT, "BDCanDisconnect=FALSE"
1257, PRINT, "BDCanDisconnect=TRUE"
END FILE "FILE_DBSERJTG", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\debug\\DbSerJtg.c"

BEGIN FILE "FILE_DBSTREAM", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\debug\\DbStream.c"
END FILE "FILE_DBSTREAM", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\debug\\DbStream.c"

BEGIN FILE "FILE_LPBUGDISP", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\debug\\lpbugdisp.c"
696, PRINT, "Requesting LP log from core 1"
699, WARN, "IpcCopy failed for core 1"
715, WARN, "Cannot determine location of remote log for core 1!"
735, WARNN, "Bugdisp LP error callback received error code %u"
745, WARNN, "Core 1 lp buffer = 0x%x"
749, WARNN, "Bugdisp LP send callback: unexpected state: %u"
768, WARNN, "Bugdisp LP receive callback: unexpected state: %u"
END FILE "FILE_LPBUGDISP", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\debug\\lpbugdisp.c"

BEGIN FILE "FILE_DEBUGPRINTF", "GROUP_APP_INTERFACE", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\debug\\debugprintf.c"
80, PRINTCOPY, "Calling %s()"
83, PRINT2N, "Function called from %(fileid):%u"
85, PRINTN, "Function called from unknown file:%u"
END FILE "FILE_DEBUGPRINTF", "GROUP_APP_INTERFACE", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\common\\firmware\\debug\\debugprintf.c"

BEGIN FILE "FILE_BUGDISPXCMDS", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\bugdispXcmds.c"
165, PRINT2N, "cycles=%d and ticks=%d"
168, PRINT3N, "This core (%u) speed is estimated to be %[%.6f/#*32768/1000000]MHz"
170, PRINTN, "This core (%u) speed is unknown"
191, PRINT, "BugdispNessusCmd"
194, PRINT, "The following Nessus specific debugger extensions are available:"
195, PRINT, "x ?          Prints available debugger extensions"
196, PRINT, "x z          enter catfail mode"
197, PRINT, "x za         Cause an abort"
199, PRINT, "x zf         Cause a fast reset"
200, PRINT, "x zh         Cause a hard reset"
202, PRINT, "x zi         Cause a watchdog with ints disabled"
203, PRINT, "x zj         Cause a jump to 0"
205, PRINT, "x zs         Cause a soft reset"
207, PRINT, "x zw         Cause a watchdog"
208, PRINT, "x a          Dump task message queues"
210, PRINT, "x dma_test   Starts mem-to-mem DMA tests on this core"
213, PRINT, "x d          Dump priority data queues"
215, PRINT, "x f          List Core Frequency Changing Commands"
216, PRINT, "x l          Dump the current event log"
217, PRINT, "x p          Dump Kernel profile data"
218, PRINT, "x pm         PMIC SM/LDO/RTC operation commands"
219, PRINT, "x q          Dump cache statistics"
220, PRINT, "x rtc        Check RTC consistency"
222, PRINT, "x rtc0       Disable RTC"
223, PRINT, "x rtc1       Enable RTC (Causes system instability!)"
225, PRINT, "x s          Get stack free info"
226, PRINT, "x sf         Disable/Enable standby mode functions"
227, PRINT, "x t          Print trace buffer"
228, PRINT, "x A<n>       Execute extended GPS command <n>"
229, PRINT, "x A?         Print extended GPS command help"
230, PRINT, "x GH         Generic Heap commands"
231, PRINT, "x mem_profile <addr> <len> Profile memory read of <len> DWORDs starting at <addr> (in hex)"
232, PRINT, "x mem_prof_pipe <addr> <len> Profile pipelined memory read of 16*<len> DWORDs starting at <addr> (in hex)"
233, PRINT, "x mem_prof_pipec <addr> <len> Profile pipelined memory (with reads from cache) read of 16*<len> DWORDs starting at <addr> (in hex)"
234, PRINT, "x mem_prof_write <addr> <len> Profile pipelined memory write of 16*<len> DWORDs starting at <addr> (in hex)"
235, PRINT, "x mem_prof_writec <addr> <len> Profile pipelined memory (with writes to cache) write of 16*<len> DWORDs starting at <addr> (in hex)"
237, PRINT, "x mem_prof_w_test Profile memory write of pre-determined number of DWORDs"
238, PRINT, "x mem_prof_r_test Profile memory read of pre-determined number of DWORDs"
239, PRINT, "x Y<n>      Test Alert: Turn it on for a short period (n=1), off (n=0)"
243, PRINT, "x mem_perf   Memory performance measurement"
247, PRINT, "x M<n>       Debug SDMA channel <n>"
250, PRINT, "x O<x><y>    Test IPC transfers from core <x> to core <y>. e.g. 'x O01'"
253, PRINT, "x r          Estimate this cores speed"
264, PRINT, "Turn off Alert"
270, PRINT, "Turn on Alert"
321, PRINT, "Creating a null function pointer"
323, PRINT, "Pointer created - Jumping to zero!"
325, PRINT, "We were supposed to be jumping to 0! You should never see this Print"
372, PRINT, "x pm<r|w><s|v><S|L|R> <p> [v]"
373, PRINT, "      PMIC read/write SM/LDO/RTC port status/voltage"
374, PRINT, "        Command:   <r>:Read, <w>:Write"
375, PRINT, "        ValueType: <s>:Status, <v>:Voltage"
376, PRINT, "        PortType:  <S>:SM, <L>:LDO, <R>:RTC"
377, PRINT, "        PortNum:   <p>:Port number, from 0 to max"
378, PRINT, "                       depending on PortType."
379, PRINT, "                       When read, specify an invalid"
380, PRINT, "                       port number to print out status"
381, PRINT, "                       /voltage of all ports"
382, PRINT, "        WriteValue:[v]:For status: 0:off, 1:on"
383, PRINT, "                       For Voltage, unit in mV"
384, PRINT, "x pm? Print x pm command usage"
394, PRINT, "x p         To print profiling statistics"
395, PRINT, "x pr        To print profiling statistics, then reset data"
396, PRINT, "x po time   To print thread usage data every <time> ms"
397, PRINT, "            Specify time = 0 to stop dumping data"
433, WARN, "NESSUS_PROFILE is not defined, so nothing is being reset"
447, PRINT, "Disabling standby mode"
451, PRINT, "Enabling standby mode"
462, PRINT, "Disabling Clock Gated mode"
466, PRINT, "Enabling Clock Gated mode"
474, WARN, "SCPrintStats is not defined on this core"
478, PRINT, "Standby Mode functions:"
479, PRINT, "-----------------------"
480, PRINT, "x sf0 - Disable L2 sleep (aka Standby, aka Deep Sleep)"
481, PRINT, "x sf1 - Re-enable L2 sleep"
482, PRINT, "x sf3 - Disable L1 sleep (aka Idle)"
483, PRINT, "x sf4 - Re-enable L1 sleep"
485, PRINT, "x sf5 - Disable Clock Gated mode"
486, PRINT, "x sf6 - Re-enable Clock Gated mode"
488, PRINT, "x sfp - Print SC profiling statistics"
492, WARN, "NESSUS_SLOWCLOCK not defined"
496, WARN, "Stack memory protection not supported"
499, PRINT, "Stack Data"
500, PRINT, "----------"
503, PRINT, "----------"
514, WARN, "RIM_CACHE not defined"
531, PRINTN, "Changing core %d frequency"
567, PRINTN, "From %(CoreFrequence):"
570, PRINT3N, " -> %(CoreFrequence) = %[%.2f/#*1000000]us"
583, PRINTN, "Current DVFM minimum speed: %[%.2f/1000000]MHz"
591, PRINT, "DVFM max speed is allowed."
595, PRINT, "DVFM max speed is not allowed."
598, PRINT, "Try x f? for help."
604, PRINT, "DVFM disabled"
608, PRINT, "DVFM enabled"
612, PRINT3N, "DVFM: last idle: %[%.1f/10]%% (enabled=%u, masked=%02X)"
619, PRINT2N, "DVFM thresholds: Lower at %[%.1f/10]%%, Raise at %[%.1f/10]%%"
630, PRINT, "DVFM disabled"
634, PRINT, "DVFM enabled"
637, PRINT, "Use: x fd{0,1} - Disable/enable DVFM"
641, PRINTN, " This core currently: %[%d/1000000]MHz"
645, PRINT, " HIGHEST DDR speed is requested"
648, PRINT, " Default DDR speed is requested"
651, PRINT, " Please choose {1|0} for HIGHEST or Default DDR speed"
656, PRINT2N, "Worst case time for frequency change =  %[%.2f/#*1000000] us"
658, PRINT, "Reseting this worst time to ZERO"
663, PRINT, "Reset worst case ARM9 wake up profiling."
669, PRINTN, "Changing core frequency to: %(CoreFrequence)"
672, PRINT, "Core Frequency Changing Commands"
673, PRINT, "----------------"
675, PRINT2N, "x f%u - %(CoreFrequence)"
677, PRINT, "x fg      - Get core frequency"
678, PRINT, "x f<c><n> - Set core 'c' to frequency 'n' (see array in freqchange.c)"
680, PRINT, "x fp      - Profile frequency changes between all possible frequencies."
683, PRINT, "x fm{0,1} - request minimum DDR speed:  DEFAULT or HIGHEST"
685, PRINT, "x fw      - Reset worst case ARM9 wake up profiling."
689, PRINT, "x fw[0]   - Print worst case frequency change time. Option '0' for resetting this value."
692, PRINT, "x fd{0,1} - Disable/enable DVFM"
693, PRINT, "x f>(min) - Set minimum DVFM speed (in Hz)"
694, PRINT, "x f<{0,1} - Disable/enable the maximum frequency"
695, PRINT, "x ft L R  - set DVFM lowering/raising thresholds (in tenths of %)"
697, PRINT, "x fd{0,1} - Disable/enable DVFM"
699, PRINTN, " This core currently: %[%d/1000000]MHz"
703, PRINT, "Frequency changing not supported on this core"
712, WARN, "RIM_EVENTLOG not defined"
726, WARN, "RIM_TRACEBUF not defined"
731, PRINT, "Translation table profiling:"
744, WARN, "There is no RTC"
768, WARN, "GPS commands not supported"
778, WARN, "Generic Heap debug commands not supported"
END FILE "FILE_BUGDISPXCMDS", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\drivers\\bugdispXcmds.c"

BEGIN FILE "FILE_IPC", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\ipc.c"
78, WARN2N, "Task %(TaskID) trying to send to task %(TaskID)"
79, WARN2N, "Message: Device = %(_DEVICE) event %(EVENT)"
128, PRINT3N, "messageSendRemote(%(TaskID),%(TaskID) toCore=%x"
136, WARNN, "Received IpcSigErr %u when trying to send remote message!"
137, PRINT3N, "Message stats: Device 0x%x, Event 0x%x, SubMsg 0x%x"
138, PRINT2N, "FromTask was %(TaskID), ToTask was %(TaskID)"
160, WARN2N, "Interprocess msgQ full! write %u, read %u"
222, ASSERTFAILURE, "Out of messages"
264, WARNN, "Bad Mask: 0x%x"
351, WARNN, "Blocking call in critical section from task %(TaskID)"
371, WARN3N, "Large message already received once, needs to be freed (Device=0x%x Event=0x%x SubMsg=0x%x)"
391, WARN3N, "Large message received on an unsupported core (Sender=%(TaskID) Device=0x%x Event=0x%x)"
418, PRINTN, "Priority Message Count %d"
421, PRINTN, "JVM RimGetMessage: %(EVENT)"
429, PRINTN, "GetMessage availNow ret=%(TaskID)"
448, PRINTN, "GetMessage blocking ret=%(TaskID)"
469, WARNN, "DequeueLargeMessage: The message queue for task 0x%x is empty"
476, WARN, "DequeueLargeMessage: Attempting to remove a non-large message"
515, PRINTN, "JVM RimGetMessage: %(EVENT)"
548, PRINTN, "Priority Message Count %d"
592, PRINT3N, "PostMessage(to=%(TaskID), Event=%(EVENT), from=%(TaskID)"
606, PRINTN, "toTaskIndex=%d"
632, PRINTN, "call messageSendRemote(%(TaskID))"
642, WARNN, "Kernel flags set, removing (flags=0x%x)"
653, WARN, "PostUniqueMessage(): Illegal attempt to post a large message"
665, WARN, "PostUniqueMessage(): Illegal attempt to update a large message"
713, WARN2N, "Task %(!TaskID) (%u) not blocked but not flagged as ready in mask 0x%08x"
715, ASSERTFC, "Task scheduler inconsistency"
751, PRINT, "Thread state info dump: (threads blocked in GetMessage aren't printed)"
753, PRINTN, "DSP task ready mask 0x%08x"
757, PRINTN, "Number Priority Messages for the APP_THREAD: %d "
772, WARN3N, "Task %d %(TaskID) not blocked, TaskIsReadyToRun %u"
775, WARN2N, "Task %d %(TaskID) not blocked"
782, WARN2N, "Task %d %(TaskID) blocked in WaitForSpecificMessage"
784, PRINT4N, "  Specific Mask 0x%x, Device = %(DEVICE), Event = %(EVENT), SubMsg = 0x%x"
794, WARN3N, "Task %d %(TaskID) blocked in LockSemaphore: %p"
799, PRINT3N, "  state: 0x%x, waiters %d, owner %d"
804, WARN, "  Blocked on a NULL semaphore"
808, WARN3N, "Task %d %(TaskID) blocked in LockCountingSemaphore: %p"
813, PRINT2N, "  count: %d, firstwaiter %d"
816, WARN, "  Blocked on a NULL semaphore"
820, WARN2N, "Task %d %(TaskID) not yet created"
823, WARN2N, "Task %d %(TaskID) stopped"
826, WARN2N, "Task %d %(TaskID) blocked on page fault"
829, WARN2N, "Task %d %(TaskID) blocked on instruction bounce"
832, WARN2N, "Task %d %(TaskID) blocked on flag"
835, WARN2N, "Task %d %(TaskID) blocked"
846, PRINT, "  Current message:"
847, PRINT4N, "    %8x Message: Device=%(_DEVICE) Event=%(EVENT) SubMsg=0x%x"
850, PRINT4N, "      Length=0x%x DataPtr=0x%08x Data[0]=0x%08x Data[1]=0x%08x"
856, PRINT, "  Queued messages:"
858, PRINT5N, "    %8x Message from task %(TaskID): Device=%(_DEVICE) Event=%(EVENT) SubMsg=0x%x"
861, PRINT4N, "      Length=0x%x DataPtr=0x%08x Data[0]=0x%08x Data[1]=0x%08x"
885, PRINT4N, "ScanMessageQ(%(TaskID) where=%p msg=%p isInt=%d"
891, PRINT2N, "%(TaskID) => %d"
894, WARN2N, "Task %(TaskID) trying to scan queue of task %(TaskID)"
900, PRINT2N, "Starting New Scan On task %(TaskID) tidx=%d"
902, PRINTN, "scanPtr=%p"
916, PRINT3N, "Scan Task %(TaskID). Message:  device %(_DEVICE) event %(EVENT)"
918, PRINT3N, "   Sub 0x%x Data0 0x%x Data1 0x%x"
940, PRINTN, "ScanMessageSpecific %d"
945, WARN2N, "Task %(TaskID) trying to scan queue of task %(TaskID)"
974, WARNN, "Error sending message!!  Error code: %u"
1035, WARNN, "MessageReceive callback: Unknown SigState: 0x%x"
END FILE "FILE_IPC", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\ipc.c"

BEGIN FILE "FILE_CRITICAL", "", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\critical.c"
133, WARNN, "Not enabling interrupts due to catfail. lr = %p"
135, WARN, "Not enabling interrupts due to catfail."
141, WARNN, "Not enabling interrupts due to init or interrupt. lr = %p"
143, WARN, "Not enabling interrupts due to init or interrupt."
223, PRINT2N, "Interrupts were disabled for a maximum of %d ticks (%d us)"
226, WARN, "      Max time exceeds 200 us limit"
228, PRINTN, "     IntDisable was called from address %p"
230, PRINTN, "     IntEnable  was called from address %p"
233, PRINTN, "Interrupts are currently disabled by %p"
236, PRINT, "Interrupts are not currently disabled by CoreIntDisable"
239, PRINT, "Profiling not enabled for IntDisable/IntEnable"
END FILE "FILE_CRITICAL", "", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\critical.c"

BEGIN FILE "FILE_THREAD", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\thread.c"
107, WARNN, "Requesting thread class of nonexistent thread: 0x%x, default to OS_THREAD"
120, WARNN, "Counting sem 0x%x used when not initialized!"
121, WARN4N, "count %d maxcount %d firstwaiter %d, initState 0x%x"
134, WARNN, "sem 0x%x used when not initialized!"
135, WARN4N, "state %d waiters %d owner %d, initState 0x%x"
161, WARNN, "UnlockCountingSemaphore got bad task ID (%d)"
170, WARNN, "UnlockCountingSemaphore unblocking %d, not blocked on this semaphore"
181, PRINT2N, "Unblocking %d from Sem 0x%x"
184, PRINTN, "Sem 0x%x unlocking"
201, PRINT2N, "Unblocking from Sem 0x%x task %(TaskID)"
209, PRINTN, "Sem 0x%x unlocking, no task is blocked"
217, WARNN, "Thread %(TaskID) returned!"
342, ASSERTF, "No blocking in critical sections"
346, ASSERTC, "Attempting to block, but reason is BLOCK_NONE"
368, WARN3N, "Unblock %(TaskID) mismatch! currentBlock=%(BlockState), unblock=%(BlockState)"
382, ASSERTF, "No blocking in critical sections"
392, ASSERTFN, "Deadlock! Owner already holds semaphore: 0x%x"
402, PRINTN, "Thread %d blocked on semaphore"
406, PRINT2N, "Block on Sem 0x%x, picking %d to run"
411, PRINT2N, "Task %(TaskID) locking sem 0x%x "
416, WARN4N, "Bad semaphore 0x%x state %u, waiters %u, owner %u"
442, ASSERTC, "sem unlock inconsistency"
460, WARNN, "Locked Semaphore initialized! 0x%x"
475, ASSERTF, "No blocking in critical sections"
505, PRINT2N, "Block on Sem 0x%x, picking %d to run"
508, PRINTN, "Locking sem 0x%x"
522, WARN2N, "count = %d, max count = %d"
528, WARNN, "Trying to initialize locked semaphore! 0x%x"
549, ASSERTFN, "Maximum Critical Section Count (%d)"
557, PRINTN, "CriticalSectionCounter %d (E)"
565, ASSERTF, "Critical Section Counter < 0! "
571, PRINTN, "CriticalSectionCounter %d (L)"
588, WARN, "Can't block a task in a critical section"
609, PRINT2N, " OsTaskSchedulerRestart: WakeTaskFast %d from %(BlockState)"
638, WARN, "Can't exit a task while it is in a critical section"
643, WARNN, "Task %(TaskID) stopping, yet its message queue isn't empty"
647, WARN2N, "Dropping message: %(DEVICE) %(EVENT)"
660, PRINTN, "Stopping task %(TaskID)"
682, PRINTN, "Task %(TaskID) is not a member of a stop set"
694, PRINT2N, "Task %(TaskID) has stop set value of %u"
702, WARN5N, "Task %(TaskID) (set %u) cannot be restarted: task %(TaskID) (set %u) is blocked on %(BlockState)"
712, PRINTN, "Task %(TaskID) can restart"
729, WARN3N, "Task %(TaskID) %d block state (0x%x) not stopped"
740, PRINTN, "Restarting task %(TaskID)"
753, PRINT2N, "RimGetCurrentTaskID %d=%(TaskID)"
764, ASSERTC, "Priority==index"
818, ASSERTF, "Too Many Threads!"
844, WARNN, "RimTaskYield called with non zero critical section counter"
879, ASSERTFAILURE, "Bad Task ID!"
888, PRINT5N, "CreateThread idx=%d %(TaskID) MAX_ID=%d stackptr 0x%x Watchdog %u msec."
892, ASSERTFAILURE, "out of memory"
899, WARN2N, "%(TaskID): Stack size not a multiple of 8, reducing to %d"
908, ASSERTFAILURE, "Bottom of stack must be 8-byte aligned to comply with APCS"
959, PRINT2N, "Task %(TaskID) stopped stackptr 0x%x"
984, WARNN, "MAKE_TASK_ID %(TaskID) out of range index!"
990, WARNN, "MAKE_TASK_ID(%d) nonexistant"
997, PRINT3N, "OsTaskGetID(%d)=>%d %(TaskID)"
1013, PRINTN, "TASK_NONE/FIQ 0x%x=> no priority!"
1017, PRINTN, "Remote task! TaskPriority(%d)"
1022, WARN2N, "RimTaskPriority(%d) too small < %d"
1026, WARN2N, "RimTaskPriority(%d) too big > %d)"
1032, WARN2N, "RimTaskPriority(%(TaskID) index %d) is unassigned!"
1050, PRINT, "Booting from battery pull - can't dump after crash stack data"
1056, PRINT, "Stack status before reset:"
1060, PRINT2N, "%(TaskID) had %d free stack"
1089, PRINT2N, "%(TaskID) has %d free stack"
1101, SHOW_MEMORY, "SP+ 0-> "
1103, PRINT2N, "%(TaskID) stack pointer 0x%X invalid or alternate stack; not printing stack values"
1117, PRINTN, "Kernel profiling tick rate: %u"
1131, PRINT2N, "Time since %(TaskID) blocked or yielded(ticks): %d"
1138, PRINT, "-------------------------------------"
1139, WARNN, "%(TaskID) registers:"
1147, PRINT2N, "Time since %(TaskID) blocked or yielded(ticks): %d"
1173, WARN4N, "%(TaskID) has %d of %d stack used (max used %d)"
1229, ASSERTC, "GetVMStackInfo() bad APP_THREAD"
1262, ASSERTC, "RimTaskIsStopped: Invalid task id"
1292, WARNN, "GetThreadInstructionPointer: Invalid task id (%u)"
1313, ASSERTC, "GetCurThreadInstructionPointer: No running thread"
END FILE "FILE_THREAD", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\thread.c"

BEGIN FILE "FILE_FLAGS", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\flags.c"
48, WARN, "FlagCreate: null parameter"
55, WARN, "FlagCreate: Insufficient flags"
69, WARNN, "FlagDelete( %u ) invalid flag"
88, WARN2N, "FlagSet( %u, 0x%04x ) invalid flag"
114, WARN2N, "Unexpected block information for task (pTask->Block=%u value=0x%x)"
127, PRINT2N, "FlagSet flag %u wakes %(TaskID)"
147, PRINT2N, "FlagSet flag %u schedules %(TaskID)"
154, ASSERTFN, "FlagSet: invalid operation %(FlagOp)"
159, PRINT4N, "FlagSet( %u, 0x%08x, %(FlagOp) ) flag is 0x%08x"
176, WARNN, "FlagWait( %u ) invalid flag"
193, ASSERT, "FlagWait called with invalid suspend value"
207, PRINT5N, "FlagWait( %u, 0x%08x, %(FlagOp), %(FlagSuspend) ) flag is 0x%08x"
218, WARN2N, "FlagPeek( %u, 0x%08x ) invalid flag"
231, WARN2N, "FastFlagCreate( %u, %(TaskID) ) invalid taskid"
235, WARN2N, "FastFlagCreate( %u, %(TaskID) ) invalid flag"
239, WARN3N, "FastFlagCreate( %u, %(TaskID) ) flag already created for task %(TaskID)"
244, PRINT2N, "FastFlagCreate flag %u created for task %(TaskID)"
257, WARNN, "FastFlagDelete( %u ) invalid flag"
273, WARN2N, "FastFlagSet( %u, 0x%04x ) invalid flag"
276, WARN2N, "FastFlagSet( %u, 0x%04x ) flag not created"
281, WARN2N, "FastFlagSet( %u, 0x%04x ) can't set flag for stopped task"
288, PRINT2N, "FastFlagSet flag %u wakes %(TaskID)"
301, PRINT2N, "FastFlagSet flag %u schedules %(TaskID)"
311, PRINT3N, "FastFlagSet( %u, 0x%04x ) flag is 0x%04x"
325, WARNN, "FastFlagWait( %u ) invalid flag"
328, WARNN, "FastFlagWait( %u ) flag not created"
333, WARN3N, "FastFlagWait( %u ) flag created for task %(%TaskID), waited on by task %(TaskID)"
350, PRINT2N, "FastFlagWait( %u ) flag is 0x%08x"
362, WARN3N, "FastFlagPeek( %u, 0x%08x, 0x%08x ) invalid flag"
366, WARN3N, "FastFlagPeek( %u, 0x%08x, 0x%08x ) flag not created"
370, WARN3N, "FastFlagPeek( %u, 0x%08x, 0x%08x ) null task pointer"
374, WARN3N, "FastFlagPeek( %u, 0x%08x, 0x%08x ) null value pointer"
392, PRINT, "Fast Flag states:"
395, PRINT4N, "Flag %u task %(TaskID) state %(_FastFlagState) mask 0x%04x"
412, WARN3N, "Task %(TaskID) stopping with ready flag %d (mask 0x%04x)"
END FILE "FILE_FLAGS", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\flags.c"

BEGIN FILE "FILE_KERNEL_PROF", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\kernel_profile.c"
229, PRINTN, "AddHooks %p"
259, ASSERT, "RemoveHook: hook wasn't on list"
272, PRINTN, "RemoveHooks %p"
549, WARN3N, "%(TaskID): Task Time %u, Watchdog Interval %u"
939, PRINT, "Starting kernel profiling"
1063, PRINT3N, "<ROLLING PROFILING DATA time: 0x%x Tickrate: %u, Wordsize %u>"
1066, PRINTN, "  Sample period %u"
1068, PRINT2N, "  Task ISRs: time in %[%0.1f/#*100] (units %%) "
1081, PRINT5N, "  Task %(TaskID): time in %[%0.1f/#*100] time starved %[%0.1f/#*100] (units %%)"
1084, PRINT3N, "  Task %(TaskID): time in %[%0.1f/#*100] (units %%)"
1088, PRINT, "</ROLLING PROFILING DATA>"
1098, PRINT, "Rolling uptime profile not enabled"
1131, PRINT3N, "<INCREMENTAL PROFILING DATA time: 0x%x Tickrate: %u, Wordsize %u>"
1135, PRINTN, "  Task ISRs: time in %[%f*0.1] (units %%)"
1138, PRINTN, "  Task ISRs: time in %[%f*0.1] (units %%)"
1145, PRINT3N, "  Task %(TaskID): time in %[%f*0.1], time starved %[%f*0.1] (units %%)"
1151, PRINT2N, "  Task %(TaskID): time in %[%f*0.1] (units %%)"
1158, PRINT3N, "  Task %(TaskID): time in %[%f*0.1], time starved %[%f*0.1] (units %%)"
1164, PRINT2N, "  Task %(TaskID): time in %[%f*0.1] (units %%)"
1171, PRINT, "</INCREMENTAL PROFILING DATA>"
1327, WARN3N, "Bad kernel profile call on entry.  Interrupt? %u, serv 0x%x, inKernel 0x%x"
1358, WARNN, "Bad kernel profile call on exit. inKernel 0x%x"
1388, PRINT, "<PROFILING DATA name='threads' format=2>"
1389, PRINTN, "Profile data:  Thread execution times, tickrate %u"
1402, WARN, "   No sum of uptime (nothing has run yet!)"
1406, PRINT2N, "    Time in interrupt handlers: %u (%[%f*0.1] %%)"
1413, PRINTN, "  %(TaskID) task:"
1416, PRINT2N, "    Time in task: %u (%[%f*0.1] %%)"
1419, PRINT2N, "    Time starved: %u (%[%f*0.1] %%)"
1423, PRINT2N, "    Time in task: %u (%[%f*0.1] %%)"
1426, PRINT2N, "    Time starved: %u (%[%f*0.1] %%)"
1432, PRINTN, "    Max Not Blocked: %u"
1434, PRINTN, "    Avg Not Blocked: %u"
1438, PRINTN, "    Max Time starved: %u"
1441, PRINTN, "    Max MsgQ Empty time: %u"
1445, PRINT, "</PROFILING DATA>"
1447, PRINT, "Thread profiling data not enabled"
1461, WARN, "Time specified has to be greater than 100ms"
1470, PRINT, "NESSUS_PROFILE has to be defined for this to work"
1485, PRINT, "No thread efficiency profiling data available"
1495, PRINT, "<PROFILING DATA name='thread efficiency' format=2>"
1496, PRINT, "Profile data:  Thread execution times"
1499, PRINTN, "Context Switches:  0x%08x"
1501, PRINT2N, "Context Switches:  0x%08x%08x"
1516, ASSERTC, "PERFMON_CLOCK must always be enabled"
1522, PRINTN, "  %(TaskID) task:"
1524, PRINT, "    (No Activity)"
1533, PRINT2N, "      0x%08x %(_PERFMON_STAT)"
1537, PRINT3N, "      0x%08x%08x %(_PERFMON_STAT)"
1548, PRINTN, "      Cycles per instruction: %u"
1554, PRINT, "</PROFILING DATA>"
1556, PRINT, "Thread efficiency profiling not enabled"
1566, PRINTN, "Kernel entrypoint handler stats (tick rate %u):"
1568, PRINT, "       Calls    Avg    Max  Entrypoint"
1575, PRINT4N, "  %10u %6u %6u  %(_EntryPoint)"
1580, PRINT, "Kernel entrypoint stats disabled in this build"
1588, WARN2N, "GetEntryPointProfileData: entryPointIndex specified is %d but NUM_ENTRYPOINTS is %d"
1642, ASSERTC, "NULL data pointer"
1646, ASSERTF, "Invalid cross-core request"
1648, ASSERTF2N, "Invalid thread ID %d %(TaskID)"
END FILE "FILE_KERNEL_PROF", "GROUP_DEBUGGER", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\kernel_profile.c"

BEGIN FILE "FILE_DEADLOCK", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\deadlock.c"
47, WARN, "=== Deadlock detected for the following tasks ==="
53, WARN2N, "%(TaskID): Binary semaphore/mutex %p"
59, WARN2N, "%(TaskID): Unknown resource %(BlockState)"
125, PRINT, "On-block deadlock detection started"
136, PRINTN, "Resource request by task 0x%.2x results in a deadlock"
164, PRINT, "On-block deadlock detection ended"
197, PRINT, "Periodic deadlock detection started"
265, PRINT, "Periodic deadlock detection ended"
266, PRINTN, "Detection algorithm runtime: %u ns"
END FILE "FILE_DEADLOCK", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\deadlock.c"

BEGIN FILE "FILE_SEMAPHORE", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\semaphore.c"
35, ASSERTC, "Invalid cookie"
36, PRINT2N, "Timeout expired for %(TaskID) from Sem 0x%x"
40, WARN, "Task already succeeded in locking semaphore"
57, ASSERTFN, "OsSemaphoreLock invalid semaphore (from %p)"
62, ASSERTFN, "OsSemaphoreLock called from critical section (from %p)"
68, WARN2N, "minExpiry %d greater than maxExpiry %d"
70, ASSERTFN, "OsSemaphoreLock invalid argument (from %p)"
76, WARN2N, "Timers not supported (requested minExpiry %d, maxExpiry %d)"
78, ASSERTFN, "OsSemaphoreLock invalid argument (from %p)"
85, WARN2N, "invalid minExpiry %d maxExpiry %d"
87, ASSERTFN, "OsSemaphoreLock invalid argument (from %p)"
107, WARN, "Couldn't allocate semaphore timer"
116, WARN, "Couldn't start semaphore timer"
120, PRINT2N, "Started timer %d for sem 0x%08x"
127, PRINT4N, "%(TaskID) Block on Sem 0x%x, picking %(TaskID) to run, count %d"
144, ASSERTFN, "OsSemaphoreUnlock invalid semaphore (from %p)"
156, PRINTN, "Stopping timer %d"
164, PRINT3N, "Unblocking %(TaskID) from Sem 0x%x count %d"
167, PRINT2N, "Sem 0x%x unlocking count %d"
177, ASSERTFN, "OsSemaphoreCreate null argument (from %p)"
182, WARN2N, "SemaphoreCreate Invalid Parameters: count = %d, max count = %d"
184, ASSERTFN, "OsSemaphoreCreate Invalid Parameters (from %p)"
190, WARN2N, "Semaphore allocation failed for task %(TaskID) tag %p"
197, PRINT3N, "Allocated semaphore 0x%08x for task %(TaskID) tag %p"
206, ASSERTFN, "OsSemaphoreDelete invalid semaphore (from %p)"
211, ASSERTFN, "OsSemaphoreDelete semaphore has waiters (from %p)"
216, PRINT2N, "Freed semaphore 0x%08x for task %(TaskID)"
226, ASSERTFN, "OsSemaphoreGetCount invalid semaphore (from %p)"
240, ASSERTFN, "OsSemaphoreGetFirstWaiter invalid semaphore (from %p)"
END FILE "FILE_SEMAPHORE", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\semaphore.c"

BEGIN FILE "FILE_MUTEX", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\mutex.c"
32, ASSERTFN, "RimMutexLock mutex nesting limit exceeded (from %p)"
40, ASSERTFN, "RimMutexLock mutex re-acquired erroneously (from %p)"
48, PRINT2N, "Task %(TaskID) locking impl 0x%x "
53, WARN4N, "Bad mutex 0x%x state %u, waiters %u, owner %u"
55, ASSERTFN, "RimMutexLock corrupt mutex (from %p)"
66, PRINTN, "MutexTryLock 0x%08x"
68, ASSERTFN, "RimMutexTryLock invalid mutex (from %p)"
80, PRINTN, "MutexLock 0x%08x"
82, ASSERTFN, "RimMutexLock invalid mutex (from %p)"
87, ASSERTFN, "RimMutexLock called from critical section (from %p)"
96, PRINTN, "Thread %(TaskID) blocked on mutex"
99, PRINT2N, "Block on Mutex 0x%x, picking %(TaskID) to run"
110, PRINTN, "MutexUnlock 0x%08x"
112, ASSERTFN, "RimMutexUnlock Invalid mutex (from %p)"
117, ASSERTFN, "RimMutexUnlock unlock of unlocked mutex (from %p)"
122, ASSERTFN, "RimMutexUnlock unlock of unowned mutex (from %p)"
131, ASSERTC, "sem unlock inconsistency"
145, ASSERTFN, "RimMutexCreate null mutex (from %p)"
150, ASSERTFN, "RimMutexCreate invalid style (from %p)"
165, PRINT3N, "Allocated mutex 0x%08x for task %(TaskID) tag %p"
174, ASSERTFN, "RimMutexDelete invalid mutex (from %p)"
179, ASSERTFN, "RimMutexDelete attempt to free locked mutex (from %p)"
184, ASSERTFN, "RimMutexDelete attempt to free mutex with waiters (from %p)"
189, PRINT2N, "Freed mutex 0x%08x for task %(TaskID)"
199, ASSERTFN, "MutexGetOwner invalid mutex (from %p)"
END FILE "FILE_MUTEX", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\mutex.c"

BEGIN FILE "FILE_KERNELHEAP", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\kernel_heap_minimal.c"
85, ASSERTF, "JVM kernel_heap_minimal: no fast reset handle invalidation!"
92, PRINT3N, "Initializing kernel heap for type %(_KernelType), %u items %u bytes"
109, ASSERTC, "Invalid item size"
112, WARNN, "KernelTypedMalloc of type %(_KernelType) failed"
115, PRINT4N, "KernelMalloc task %(TaskID) tag 0x%x type %(_KernelType) returns 0x%08x"
125, PRINT2N, "KernelFree task %(TaskID) ptr 0x%08x"
143, PRINT3N, "ValidateKernelPointer task %(TaskID) handle 0x%08x type %(_KernelType)"
165, PRINT3N, "KernelHeap %(_KernelType) has %u free, first is 0x%08x"
173, WARN, "Beginning KernelHeapTest"
180, ASSERTC, "bad handle"
181, ASSERTC, "bad malloc"
193, PRINTN, "KernelPointerFromHandle( 0, KERNELTYPE_SEMAPHORE ) returns %u"
195, WARN2N, "Ending KernelHeapTest after %u allocations %u deallocations"
END FILE "FILE_KERNELHEAP", "GROUP_OS_INTERNAL", "c:\\pviews\\sraminiOSPlatformSWInt\\miniOS\\armos\\nessus\\kernel\\kernel_heap_minimal.c"

BEGIN SYMBOLS
a00c00: ABT_STACK
a00e00: ABT_STACK_TOP
a092b0: APP_THREAD_STACK
81d5: AckItemToPacket
a07654: ActiveList
edd9: AddDeviceSideTimestamp
4665: AddNodeToList
9571: AlignUsbBuffer
36174: AllBufferInfo
d66b: AppThreadEntryPoint
1483c: ArmCpWait
a07618: ArsrRegResetValue
12c39: AssertCrossCoreInt
12c37: AssertInterrupt
ed77: BDCanDisconnect
a07630: BRtcWasInvalid
a06f0c: BT_EN_Line
a06f10: BT_UART_RX_Line
a06f14: BT_UART_TX_Line
a07c20: BdVetoOn
12071: BigShowMemory
13661: BlockCurrentThread
13501: BlockTaskFast
e0f3: BufPrint2NFun
e10f: BufPrint3NFun
e137: BufPrint4NFun
e169: BufPrint5NFun
e0c1: BufPrintFun
e0d9: BufPrintNFun
edd5: BugdispBufferSpaceAvailable
dcb3: BugdispCmdPermitted
a07c1c: BugdispConnected
a07c24: BugdispLoggingEnabled
f535: BugdispNessusCmd
a07c04: BugdispProtocol
e8df: BugdispSend
e8d1: BugdispSendUnencrypted
40cb: BusInit
11b60: C$$code
a06f18: CB_UART_RX_Line
a06f1c: CB_UART_TX_Line
a06f20: CODEC_INT_N_Line
a06f24: CODEC_RESET_N_Line
15090: CacheCleanAndInvalidateDataRange
1507c: CacheCleanDataRange
15068: CacheInvalidateDataRange
15054: CacheInvalidateInstructionRange
a06d90: CatastrophicFailure
147ef: CatastrophicFailureInOut
159d: CatastrophicFailureWithCode
15a1: CatastrophicFailureWithContext
eaa5: CatfailCheckUsbState
4a27: ChangeCoreFrequency
49a7: ChangeCoreNFrequency
49b9: ChangeCoreNVoltage
a077b4: ChannelWithStoppedMessages
ffef: CheckCoreMode
1470d: CheckCoreModeResetOrInterrupt
13539: CheckCountingSemaphoreInitialization
138d5: CheckCriticalSection
11e15: CheckCriticalSectionEntry
132ef: CheckIntDisable
1803: CheckIntDisableError
13315: CheckIntDisableLeaveCS
132db: CheckIntDisableStrict
431d: CheckRtcConsistency
1356d: CheckSemaphoreInitialization
141d9: CheckThreadStack
a7eb: CheckUsbAdapter
40d5: ChipSpecificInit
e987: CircBufferSend
c488: Clean_DCache
13d3d: ClearFastFlagsOnTaskStop
12c35: ClearInterrupt
a07bbc: Clock13MOutDmd
a07bcc: Clock26MOut
a07b9c: ClockD0ckenAxiBus
a07bac: ClockD0ckenAxiMmcUsb
a07acc: ClockD0ckenCaddo
a07a3c: ClockD0ckenCamera
a07a1c: ClockD0ckenDisp
a07b7c: ClockD0ckenGraphics
a07b6c: ClockD0ckenI2c
a07a9c: ClockD0ckenKeypad
a07a6c: ClockD0ckenMmc0
a07a7c: ClockD0ckenMmc1
a07a8c: ClockD0ckenMmc2
a07b5c: ClockD0ckenMsl
a07b8c: ClockD0ckenMved
a07a2c: ClockD0ckenPixel
a07a4c: ClockD0ckenSmc
a07b1c: ClockD0ckenSsp1
a07b2c: ClockD0ckenSsp2
a07b3c: ClockD0ckenSsp3
a07b4c: ClockD0ckenSsp4
a07afc: ClockD0ckenUart1
a07aec: ClockD0ckenUart2
a07b0c: ClockD0ckenUart3
a07adc: ClockD0ckenUdc
a07aac: ClockD0ckenUsim0
a07abc: ClockD0ckenUsim1
a07a5c: ClockD0ckenVBRom
c8ab: ClockDisable
c89b: ClockEnable
a079dc: ClockFreqBlockLcd
a079ec: ClockFreqBlockNand
a079fc: ClockFreqMaxCamera
a07a0c: ClockFreqMaxGraphics
c87d: ClockRunning
a079cc: ClockStats
a079d0: ClockStatsActual
c88d: ClockUptime
c90b: ClocksAllowSleep
c98f: ClocksInit
c923: ClocksNextRollingSample
10479: CmdLookup
e55f: CombineTypeAndIndex
e27d: CommonBugdispCommand
412b: ConfigureSRAM
bf7f: ConvertEPAntiochToRim
156bd: CoreIntDisable
156b5: CoreIntDisableInternal
1570d: CoreIntEnable
156c5: CoreIntEnableInternal
40cd: CoreSpecificInit
158b8: CountLeadingZeros
15ab7: CreateThread
158fd: CreateThreads
a01244: CurrentContextEndPtr
a0123c: CurrentTaskIndex
a079d8: CwsbrShadow
c955: D0ckenAControl
c957: D0ckenBControl
c959: D0ckenCControl
a082b0: DEBUG_THREAD_STACK
b253: DISABLE_USB_INTERRUPTS
bf8b: DISABLE_USB_OUTPUTS
bf87: DISABLE_XCVER
2d5f: DataAbort_Handler
15144: DataMemoryBarrier
1514c: DataSyncBarrier
10209: DeadlockDetectPeriodic
a07c7e: DeadlockVector
a07c8c: DebugDrv
d771: DebugExtension
e7ad: DebugInitializePort
a07c90: DebugLevel
e947: DebugSender
ea69: DebugStartOutput
e0a1: DebugTaskEntryPoint
a12520: DebugTx
11e99: DequeueLargeMessageEntry
35e44: DevFailPkt
3d4b: DeviceSpecificPadConfigure
c820: DisableCacheOnly
c854: DisableDomain
12bc9: DisableInterrupt
134c5: DisableInterrupts
11e51: DisableInterruptsEntry
c449: Disable_Cache
fc01: DisplayAppMessageQueues
11dfd: DisplayAppMessageQueuesEntry
101a3: DisplayFastFlagState
e921: DoBugdispWraparound
107f5: DrvControl
107e7: DrvDebug
10857: DrvDecDebugLevel
107d5: DrvDisable
106e5: DrvEnable
10721: DrvFrameworkInit
1077b: DrvFrameworkInitialized
107c5: DrvGetConfig
106f7: DrvGetHandle
107b5: DrvGetStats
107a5: DrvGetStatus
10849: DrvIncDebugLevel
10781: DrvPollEvents
10817: DrvPrint
a07c10: DspLoggingEnabled
1090d: DummyStubControl
1090b: DummyStubDebug
10907: DummyStubDisable
10903: DummyStubEnable
10901: DummyStubGetConfig
108ff: DummyStubGetStatistics
108fd: DummyStubGetStatus
10911: DummyStubInitialize
104b1: DumpCmdList
fe8d: DumpKernelStacks
2ddd: DumpRegisters
e7f7: DumpSavedBUGDISPLog
e8e3: DumpSavedToCurrentBugdispLog
fed5: DumpStackContents
fe53: DumpStacksAfterCrash
ff1b: DumpSuspendedTaskRegisters
1897: DumpSystemStacks
1895: DumpSystemStacksAfterCrash
ca89: DumpTimerEnum
ca11: DumpTimerQueue
a79d: ENABLE_CD
b237: ENABLE_USB_INTERRUPTS
bf89: ENABLE_USB_OUTPUTS
bf85: ENABLE_XCVER
a07640: Earliest
a07be4: EarliestMaxExpiryTime
a07634: EarliestSource
40bd: EarlyWatchdogHandler
11d28: EmptyBaseFiqHandler
11cfc: EmptyBaseIrqHandler
14799: EmptyFiqHandler
2d63: EmptyIrqHandler
ecf5: EmptyShmemBuffersIntoStagingBuffers
c7dc: EnableCacheAndMMU
1587c: EnableCurrentThreadInterrupts
c838: EnableDomain
4585: EnableEarlyWatchdogTimer
129d9: EnableInterrupt
134df: EnableInterrupts
11e55: EnableInterruptsEntry
c35d: EnableMMUCache
13345: EnableThreadInterrupts
101eb: EnableThreadProfileData
eebf: Encode2NFun
ef71: Encode3NFun
f051: Encode4NFun
f163: Encode5NFun
f38b: EncodeBigShowMemory
f29d: EncodeCopyFun
f483: EncodeDebugItem
ee1d: EncodeFun
ee57: EncodeNFun
f2f3: EncodeShowMemory
a06dac: EndOfAllocatedERam
3a0: EndOfAllocatedFlash
35ea4: EngScreen_UsbInfo
35e70: EngScreen_UsbPortInfo
35e48: EngScreen_UsbPortInfoMenu
6209: EngSprintf
138db: EnterCriticalSection
11e0d: EnterCriticalSectionEntry
11bf0: EnterKernelDataAbort
11b8c: EnterKernelFIQ
11bd0: EnterKernelIRQ
11c10: EnterKernelPrefetchAbort
11c80: EnterKernelSWI
11c40: EnterKernelUndefined
11b8c: EntryExitPoints
11dec: EntryThunk
a09980: EpInTdArray
a09ce0: EpOutTdArray
a0a040: EpZlpTdArray
d069: ExpireOneTimer
474f: ExpireSemaphoreTimer
d00b: ExpireTimers
d04b: ExpireTimersInt
147bb: FIQ_Handler
a00600: FIQ_STACK
a00c00: FIQ_STACK_TOP
1582c: FastCoreIntDisable_real
15844: FastCoreIntEnable_real
11e45: FastFlagSetEntry
11e49: FastFlagWaitEntry
a01508: FastTaskStacks
2cb9: FixRegisters
1012d: FlagCreate
1017d: FlagDelete
13d13: FlagPeek
13bd5: FlagSet
11e3d: FlagSetEntry
13c8f: FlagWait
11e41: FlagWaitEntry
3e61: FlashConfigPadDrive
a06d9c: FlashDriversPassedInit
bd59: FlushEps
c474: Flush_DCache
c468: Flush_ICache
4129: ForceCommsOff
a07c88: FrameworkInit
a0690c: FreeList
a07bfc: Freelist
c973: FrequencyBlockControl
4a2b: FrequencyChangeBlock
49a3: FrequencyChangeCommonInit
4a75: FrequencyChangeForceMax
49bd: FrequencyChangeInit
4a9b: FrequencyChangeWaitMax
c981: FrequencyMaxControl
a07eb4: GPIOHdlr
a07304: GPIO_REVERSE_MAPPINGS
233f: GenericCallNowX
222d: GenericCallNowX_internal
15c18: GetCPSR
4ac3: GetCoreFrequency
4acb: GetCoreNFrequency
e7d9: GetDebugBufferInfo
e7eb: GetDebugBufferInfoSize
8dcb: GetEndpointHaltStatus
3627: GetInterruptState
5951: GetJvmStartStatus
15315: GetMessage
11df1: GetMessageEntry
158c0: GetModeRegisters
15725: GetNextTaskReadyToRun
e7d5: GetNumDebugBuffers
2f9d: GetPadDefinition
2aab: GetPadPropertyPrimaryAltMode
2ad3: GetPadPropertyPullDownEnable
2afb: GetPadPropertyPullUpEnable
2b23: GetPadPropertySecondaryAltMode
158e8: GetPreservedRegisters
ecfd: GetRimLogging
15874: GetSPSR
fe11: GetThreadClass
101ef: GetThreadProfileData
ff87: GetThreadStackFree
4be5: GetTotalCoreStateTicks
42f5: GetUptimeAtRtc
c2c1: GetUsbFSPort
c2bb: GetUsbHSPort
a123: GetUsbSetupBuffer
11e01: GetVMStackInfoEntry
620d: GetVendorId
3f87: GpioInit
a0b1b4: GpioInterruptStates
a07060: GpioLatchStates
c9b5: Handle2Timer
24b3: HandleTaskCall
a07bf8: Head
15c78: Hex_digits
12661: HwDelay
12669: HwDelayInIram
a06f28: I2C_SCL_Line
a06f2c: I2C_SDA_Line
a06f30: I2S_BCLK_Line
a06f34: I2S_SDIN_Line
a06f38: I2S_SDOUT_Line
a06f3c: I2S_SYSCLK_Line
a06f40: I2S_WCLK_Line
a01508: IDLE_THREAD_STACK
a07c94: IODriverTable
a00e00: IRQ_STACK
a01000: IRQ_STACK_TOP
a07658: IdleList
d677: IdleThreadEntryPoint
b8: Image$$EndOfFlash$$Length
a06908: Image$$IRAM_KERNEL_MSGQ_DATA$$Base
488: Image$$IRAM_KERNEL_MSGQ_DATA$$Length
a01200: Image$$IRAM_KERNEL_TASK_DATA$$Base
304: Image$$IRAM_KERNEL_TASK_DATA$$Length
363ec: Image$$IVT$$Base
48: Image$$IVT$$Length
a54000: Image$$MMU_PAGE_TAB$$ZI$$Base
a58400: Image$$MMU_PAGE_TAB$$ZI$$Limit
a06d90: Image$$RAM$$Base
a0a700: Image$$RAM$$ZI$$Base
a52b5c: Image$$RAM$$ZI$$Limit
e1c3: InBit
a0763c: InTmr4InterruptHandler
8: Init
1387d: InitCountingSemaphore
2bd5: InitLinkedList
151ed: InitMessageQueue
137d5: InitSemaphore
11e31: InitSemaphoreEntry
4de9: InitUSBChargerRate
2aa1: InitializeVersionSpecificSignalMappings
150bc: InstructionSyncBarrier
a07cec: IntCtrlHandlers
2eed: InterruptControllerInit
128dd: InterruptHandler
15818: InterruptsAreEnabled
9857: IsBugdispConnected
609b: IsCurrentModeComposite
15b7: IsHeadInSand
12cb3: IsInterruptMasked
12c3b: IsInterruptPending
1579b: IsOSTaskPending
a0b458: IsSet
11d54: JumpToZeroHandler
2c8d: JumpToZero_Handler
3ac: Jumptable_2_or_less_Args
1250: Jumptable_3_or_more_Args
a06f44: KEYIN_0_Line
a06f48: KEYIN_1_Line
a06f4c: KEYIN_2_Line
a06f50: KEYIN_3_Line
a06f54: KEYIN_4_Line
a06f58: KEYIN_5_Line
a06f5c: KEYOUT_0_Line
a06f60: KEYOUT_1_Line
a06f64: KEYOUT_2_Line
a06f68: KEYOUT_3_Line
a06f6c: KEYOUT_4_Line
a06f70: KEYOUT_5_Line
a06f74: KEYOUT_6_Line
a06f78: KEYOUT_7_Line
101e1: KernelDumpAPIProfileInfo
2ef9: KernelDumpISRProfileInfo
fe01: KernelDumpIntDisableProfileInfo
101b9: KernelDumpRollingProfilingData
101d7: KernelDumpThreadPerfmonInfo
101c3: KernelDumpThreadProfileInfo
14745: KernelGetLargeMessage
141d5: KernelHandleFromPointer
12595: KernelHeapInit
361f8: KernelMetricsData
141d7: KernelPointerFromHandle
146b9: KernelPostMessageWithFlags
157ed: KernelProfileIncrementalTickEvent
101cd: KernelStartIncrementalProfileDump
12625: KernelTypedFree
125f1: KernelTypedMalloc
151c4: L1AllocateVA
151e4: L1CleanAndInvalidateDCache
1510c: L1CleanAndInvalidateDCacheMVA
15114: L1CleanAndInvalidateDCacheSetWay
151dc: L1CleanDCache
150f4: L1CleanDCacheMVA
150fc: L1CleanDCacheSetWay
15174: L1FetchAndLockICacheMVA
150cc: L1FlushBTBIMP
150c4: L1InvalidateBTB
150d4: L1InvalidateDCache
150dc: L1InvalidateDCacheMVA
150e4: L1InvalidateDCacheSetWay
15134: L1InvalidateDTLB
1513c: L1InvalidateDTLBMVA
150ec: L1InvalidateIAndDCacheAndBTB
1511c: L1InvalidateIAndDTLB
150a4: L1InvalidateICacheAndBTB
150ac: L1InvalidateICacheMVA
150b4: L1InvalidateICacheSetWay
15124: L1InvalidateITLB
1512c: L1InvalidateITLBMVA
15104: L1PrefetchICacheMVA
151b4: L1TranslateAndLockDTLBMVA
151a4: L1TranslateAndLockITLBMVA
1519c: L1UnlockDCache
151bc: L1UnlockDTLB
15184: L1UnlockICache
151ac: L1UnlockITLB
15194: L2AllocateAndLockCacheMVA
1516c: L2CleanAndInvalidateCacheSetWay
151d4: L2CleanCacheAll
1515c: L2CleanCacheMVA
15164: L2CleanCacheSetWay
1517c: L2FetchAndLockCacheMVA
151cc: L2InvalidateCacheAll
15154: L2InvalidateCacheMVA
1518c: L2UnlockCache
a06f7c: LCD_A0_Line
a06f80: LCD_CS_N_Line
a06f84: LCD_CTRL_Line
a06f88: LCD_DATA_0_Line
a06f90: LCD_DATA_10_Line
a06f94: LCD_DATA_11_Line
a06f98: LCD_DATA_12_Line
a06f9c: LCD_DATA_13_Line
a06fa0: LCD_DATA_14_Line
a06fa4: LCD_DATA_15_Line
a06f8c: LCD_DATA_1_Line
a06fa8: LCD_DATA_2_Line
a06fac: LCD_DATA_3_Line
a06fb0: LCD_DATA_4_Line
a06fb4: LCD_DATA_5_Line
a06fb8: LCD_DATA_6_Line
a06fbc: LCD_DATA_7_Line
a06fc0: LCD_DATA_8_Line
a06fc4: LCD_DATA_9_Line
a06fc8: LCD_RD_N_Line
a06fcc: LCD_RST_N_Line
a06fd4: LCD_VSYNC1_Line
a06fd0: LCD_VSYNC_Line
a06fd8: LCD_WR_N_Line
a06fdc: LS_PWR_Line
a07ce8: LastIrqNum
a07620: LastRtcDword
13a75: LeaveCriticalSection
11e11: LeaveCriticalSectionEntry
14283: LeaveKernel
1681: LeaveKernelFirstTime
11ca8: LeaveKernelFirstTime_asm
11cb4: LeaveKernelReal
3a0: LinkerInfo
2c01: ListAddToEnd
2c23: ListGetElementIndex
2c47: ListRemoveElement
2bdf: ListRemoveFromBeginning
40000: Load$$EndOfFlash$$Base
3bc18: Load$$IRAM_KERNEL_MSGQ_DATA$$Base
36510: Load$$IRAM_KERNEL_TASK_DATA$$Base
363ec: Load$$IVT$$Base
3c0a0: Load$$RAM$$Base
8: Load$$ROM$$Base
3a4: LoadBase
13813: LockCountingSemaphore
11e19: LockCountingSemaphoreEntry
136d3: LockSemaphore
11e29: LockSemaphoreEntry
a07c08: LogDeviceSideTimestamps
a1243e: LogTaskMessages
11e9d: LogTraceUserEntry
ea3f: LpDebugPush
2fa5: MFPR_REG32
a06fe0: MICROSD_SD_CLK_Line
a06fe4: MICROSD_SD_CMD_Line
a06fe8: MICROSD_SD_DATA0_Line
a06fec: MICROSD_SD_DATA1_Line
a06ff0: MICROSD_SD_DATA2_Line
a06ff4: MICROSD_SD_DATA3_Line
a58000: MMUCoarsePageTable
c4bc: MMUGetDFSR
c4b0: MMUGetFAR
c4c8: MMUGetIFSR
a0793c: MMUSectionLayoutRAM
a54000: MMUSectionTable
35ecc: MMU_MEM_LAYOUT_ENTRIES
c8ad: MSARunningMask
c91d: MSAUsedMask
a116b4: Map
a0b46c: MatchValue
a07c3c: MaxBugdispUsbPacket
a07bf0: MaxNumPooledTimers
a07bec: MaxNumTimersInQueue
1f73: MbBigShowMemory
1ba5: MbBugdispAddBuffer
1d29: MbPrint2NFun
1d79: MbPrint3NFun
1dcb: MbPrint4NFun
1e27: MbPrint5NFun
1e89: MbPrintCopyFun
1c9f: MbPrintFun
1ce3: MbPrintNFun
1ecf: MbSendDebugItem
1f13: MbShowMemory
a06910: MessageBuffer
1e8: MetricsData
10395: MutexCreate
11e71: MutexCreateEntry
103e5: MutexDelete
11e75: MutexDeleteEntry
1414d: MutexGetOwner
11e79: MutexGetOwnerEntry
14077: MutexLock
11e65: MutexLockEntry
14057: MutexTryLock
11e69: MutexTryLockEntry
140cd: MutexUnlock
11e6d: MutexUnlockEntry
d12d: NDoTimerExpiry
cf45: NRestartPeriodicTimer
d453: NStartTimerCallback
d419: NStartTimerSpecific
d435: NStartTimerSpecificHandle
d3f7: NStartTimerStatic
d479: NStopTimer
d31b: NTimeRemaining
d1e3: NTimerGetMaxSleep
d353: NTimerGetNextToExpire
d1af: NTimerInitialise
a07c38: NewBugdispConnection
a0765c: NextExpiry
a07c58: NullFunc
a07bf4: NumPooledTimers
a01238: NumThreads
a07be8: NumTimersInQueue
a07bdc: NumberOfTimers
15b3: NvDeleteRecord
15ab: NvGetRecordCopy
15af: NvUpdateRecord
a06ff8: ONENAND_AVD_N_Line
a06ffc: ONENAND_CE_N_CS2_Line
a07000: ONENAND_CLK_Line
a07004: ONENAND_INT_Line
a07008: ONENAND_RD_N_Line
a0700c: ONENAND_WR_N_Line
195f: OSMain
3200000: OSTrailer
425b: OldRimTicksToRtc
a06d98: OldSvcStackFree
11ea0: OsCodeBugdispAux
12188: OsCodeBugdispPrint
12594: OsCodeGenericHeap
125f0: OsCodeGenericHeapFast
12668: OsCodeHwDelay
12dc8: OsCodeIsr
141d4: OsCodeKernelServAux
157f0: OsCodeKernelServCore
a07cb8: OsDataGenericHeap
a07eb4: OsDataIsr
a08258: OsDataKernelServCore
a06908: OsDataMsgQueues
a082a8: OsDataPreserve
a01500: OsDataTaskDescriptors
1321d: OsDisableInterrupts
13275: OsEnableInterrupts
2581: OsGetMessageWithTimeout
15a58: OsInitialization
144bd: OsPostUniqueMessage
13b5d: OsTaskGetCount
13b57: OsTaskGetID
cd39: OsTimerCreate
ce85: OsTimerDelete
ce31: OsTimerLookup
d2fb: OsTimerRemainingTime
cee1: OsTimerStart
cf21: OsTimerStartCallback
cf05: OsTimerStartOnTask
cb5b: OsTimerStop
11b60: OssrWrite
e1a1: OutBit
a07010: PCM_CLK_Line
a07014: PCM_IN_Line
a07018: PCM_OUT_Line
a0701c: PCM_SYNC_Line
2e41: PJ4SpecificInit
a01d08: PLATFORM_THREAD_STACK
a07020: PMIC_INT_N_Line
3775: PadClear
3e75: PadConfigure
3cd5: PadInterruptClear
3b55: PadInterruptConfigure
3c33: PadInterruptDisable
3945: PadInterruptEnable
a0af1c: PadPropertiesList
a0b068: PadPropertyTypes
34fb: PadRead
3bff: PadRegisterIntHandler
3645: PadSet
387f: PadSetMode
a0799c: PageLayoutNonCacheRAM
a07934: PageLayoutStruct
15533: PeekSpecificMessage
11e05: PeekSpecificMessageEntry
c903: PeripheralRunningMask
c8b3: PeripheralUsedMask
a52788: PfCmdList
105a7: PfCmdRegister
1089f: PfMsgHandler
10865: PfMsgRegister
104e5: PlatformBugdispEntry
10455: PlatformThreadEntryPoint
8fab: PmInitAllowApps
d6b5: PmInitIsComplete
35cb0: PossibleCoreFrequencies
35cc0: PossibleDspCoreFrequencies
153c1: PostMessage
11ded: PostMessageEntry
11e95: PostMessageWithFlagsEntry
2d61: PrefetchAbort_Handler
c494: Prefetch_ICache
14201: PrepareForTaskSwitch
a01500: PreviousContextEndPtr
a01240: PreviousTaskIndex
12223: Print2NFun
122af: Print3NFun
12365: Print4NFun
1243f: Print5NFun
f4f7: PrintCallerInfo
c8bb: PrintClockStatistics
12539: PrintCopyFun
12189: PrintFun
15a9: PrintMessage
121c7: PrintNFun
c925: PrintRollingClockStatistics
dce7: ProcessBugDispCommand
df11: ProcessDebugTaskMessage
e619: ProcessUsbTaskMessage
a09800: QhArray
a07790: QueueDevFail
2441: QueueMsgCall
e815: QueuePacketsForUsb
a599: READ_CD
363ec: RamImageIntVector
21af: RbAdded
1fdd: RbClear
1ff9: RbCount
1ffd: RbCountNoWrap
20e7: RbGetBytesFree
20ef: RbGetBytesFreeNoWrap
2021: RbGetHeadPtr
2029: RbGetTailPtr
1ff3: RbInit
211d: RbPeek
2159: RbPeekInto
208b: RbRead
21e5: RbSkip
2031: RbWrite
14bdc: ReadCpReg32AUXCTRL
14f54: ReadCpReg32AUXDEBUGCTRL0
14f94: ReadCpReg32AUXDEBUGCTRL1
14fd4: ReadCpReg32AUXFUNCCTRL
14f0c: ReadCpReg32CACHELEVELID
14ec4: ReadCpReg32CACHELOCK
14f04: ReadCpReg32CACHESIZEID
14f14: ReadCpReg32CACHESIZESELECT
14ccc: ReadCpReg32CCNT
14e4c: ReadCpReg32CHKPT0
14e74: ReadCpReg32CHKPT1
14b9c: ReadCpReg32CPAR
1485c: ReadCpReg32CTRL
14854: ReadCpReg32CTYPE
148dc: ReadCpReg32DACR
14b5c: ReadCpReg32DBCON
14adc: ReadCpReg32DBR0
14b1c: ReadCpReg32DBR1
14e1c: ReadCpReg32DCSR
1499c: ReadCpReg32DLOCK
14c54: ReadCpReg32ERRADRL
14c7c: ReadCpReg32ERRADRU
14c2c: ReadCpReg32ERRLOG
14d44: ReadCpReg32EVTSEL
1495c: ReadCpReg32FAR
14d1c: ReadCpReg32FLAG
1491c: ReadCpReg32FSR
14a5c: ReadCpReg32IBR0
14a9c: ReadCpReg32IBR1
1484c: ReadCpReg32ID
149dc: ReadCpReg32ILOCK
14cf4: ReadCpReg32INTEN
15014: ReadCpReg32L2CERRTHRESHOLD
14c24: ReadCpReg32L2CTYPE
14c1c: ReadCpReg32L2ID
14a1c: ReadCpReg32PID
14d6c: ReadCpReg32PMN0
14d94: ReadCpReg32PMN1
14dbc: ReadCpReg32PMN2
14de4: ReadCpReg32PMN3
14ca4: ReadCpReg32PMNC
14e14: ReadCpReg32RX
14e44: ReadCpReg32TBREG
1489c: ReadCpReg32TTBR0
14e9c: ReadCpReg32TXRXCTRL
4015: ReadRtcDword
4021: ReadRtcWhole
4047: ReadRtcWord
1360b: ReadyThreadForRunning
a0b480: ReentrancyProtection
d64d: RefreshFPCookieTimeout
a07c00: RefreshFPStartTime
e1ed: RegisterCommandGroupHandler
1294d: RegisterIntHandler
45b5: RegisterTimerExpiry
81cd: RejectCodeToPacket
4693: RemoveNodeFromList
4127: RequireComms
170: ResetALLSettings
34: ResetHandler
417d: ResetHwGetResetPower
4151: ResetHwInit
a082a8: ResetIndicator
a077f8: ResetOnCablePull
4119: ResetPeripherals
4593: ResumeEarlyWatchdogTimer
ecc5: RimBugdispLogging
159f: RimCatastrophicFailure
1302f: RimCheckCriticalSection
f4e3: RimDebugPrintf
f4bd: RimDebugVprintf
12e99: RimDisplayAppMessageQueues
12fd5: RimEnterCriticalSection
17b3: RimFlagCreate
17db: RimFlagDelete
131f1: RimFlagPeek
13177: RimFlagSet
131b7: RimFlagWait
1577f: RimGetCurrentTaskID
fe47: RimGetCurrentTaskPriority
6211: RimGetDeviceHardwareInfo
6235: RimGetDeviceInfo
14505: RimGetMessage
4035: RimGetNativeTicks
4043: RimGetNativeTicksPerSecond
42db: RimGetTicks
6e1d: RimGetUSBInfo
42b3: RimGetUptime
12f09: RimInitCountingSemaphore
130d9: RimInitSemaphore
12fff: RimLeaveCriticalSection
12eb9: RimLockCountingSemaphore
47fd: RimLockCountingSemaphoreWithTimeout
13099: RimLockSemaphore
ed1f: RimLogging
1725: RimMutexCreate
1779: RimMutexDelete
1315b: RimMutexGetOwner
130f9: RimMutexLock
1311d: RimMutexTryLock
13137: RimMutexUnlock
14571: RimPeekMessage
1455d: RimPeekSpecificMessage
1447b: RimPostMessage
15551: RimPriorityMessageCount
d6b9: RimResetReason
14599: RimScanMessageQueue
14645: RimScanMessageSpecific
168f: RimSemaphoreCreate
16eb: RimSemaphoreDelete
12f91: RimSemaphoreGetCount
12fb3: RimSemaphoreGetFirstWaiter
12f31: RimSemaphoreLock
12f5d: RimSemaphoreUnlock
a06dc0: RimSignalLines
2631: RimSleep
29ed: RimSprintf
13b63: RimTaskIsStopped
13533: RimTaskPriority
13065: RimTaskRestart
ff9b: RimTaskStackInfo
13049: RimTaskStop
14589: RimTaskYield
12ed9: RimUnlockCountingSemaphore
130b9: RimUnlockSemaphore
26f5: RimUnsupportedAPIFailure
2723: RimUnsupportedAPIFailureRawAddress
a0f1a0: RimUsbBugdispAlignedBuffer
a79f: RimUsbCDInterruptOccurred
a129: RimUsbCableConnected
8d45: RimUsbCancelRead
8ccb: RimUsbCancelSend
8c01: RimUsbCancelXfer
8ca7: RimUsbCleanupPipes
8b0d: RimUsbControlSendStatus
90cd: RimUsbDisconnected
9fe9: RimUsbDumpCatfailInfo
98a3: RimUsbFlagSoftReconnect
a153: RimUsbForceModeAndSpeed
a1b5: RimUsbForceModeMSONLY
6153: RimUsbGetConfigDescriptor
5fa3: RimUsbGetCurrentMode
613d: RimUsbGetCurrentPort
6093: RimUsbGetCurrentSpeed
8af5: RimUsbGetDefaultMode
6175: RimUsbGetEndpointDescriptor
6155: RimUsbGetInterfaceDescriptor
8b49: RimUsbGetMaxOperatingSpeed
8b27: RimUsbGetOperatingSpeed
568d: RimUsbHandleStdReq
5467: RimUsbHandleVdrReq
9c4f: RimUsbInXferDone
8b53: RimUsbInitPipes
5f43: RimUsbIsModeAvailable
5fa9: RimUsbIsModeEnabled
98ab: RimUsbIsSoftReconnectPending
a0e9a0: RimUsbMuxMergeBuffer
9915: RimUsbOutXferDone
9ea3: RimUsbResetInt
8cb9: RimUsbResumePipes
83f5: RimUsbSetControlReadDestination
8afb: RimUsbSetDefaultMode
5fc7: RimUsbSetMode
6043: RimUsbSetModeWithFallback
9d65: RimUsbSetSuspendState
98b1: RimUsbSoftReconnect
a4d5: RimUsbSoftReconnectCallback
a771: RimUsbStartCDHandler
90c5: RimUsbStopAllChannels
a1c5: RimUsbSwitchSpeed
6099: RimUsbToggleUsbFlags
51f7: RimUsbToggleVerbosity
2739: RimVsprintf
1467b: RimWaitForSpecificMessage
26a1: RimWatchdogHit
41d7: RtcDelay
4057: RtcHwInit
419d: RtcInit
a07624: RtcInitialized
4379: RtcToMs
4247: RtcToOldRimTicks
a07024: SD_CD_N_Line
b4f5: SETUP_USB_INTERRUPTS
a00000: SVC_STACK
a00600: SVC_STACK_TOP
a32630: SavedDebugTx
13365: ScanMessageQueue
11df9: ScanMessageQueueEntry
133f1: ScanMessageSpecific
11e4d: ScanMessageSpecificEntry
15a59: ScheduleInitialize
e1d9: SelectAltFunction
13d65: SemTimeout
102d9: SemaphoreCreate
11e85: SemaphoreCreateEntry
1033b: SemaphoreDel
11e89: SemaphoreDeleteEntry
13f0b: SemaphoreGetCount
11e8d: SemaphoreGetCountEntry
13f2d: SemaphoreGetFirstWaiter
11e91: SemaphoreGetFirstWaiterEntry
13daf: SemaphoreLock
11e7d: SemaphoreLockEntry
13ebd: SemaphoreUnlock
11e81: SemaphoreUnlockEntry
ea9d: SendBacklog
8faf: SendConnectionStatus
11ea1: SendDebugItem
a07c28: SendingBacklog
1585c: SetCPSR
158a0: SetCurrentThreadMode
4583: SetEarlyWatchdogTimer
8d93: SetEndpointHaltStatus
4525: SetHWTimer
a0783c: SetHighPower
12d59: SetInterruptPriority
c5f8: SetMMUCoarsePageTable
c4d4: SetMMUSectionRange
c580: SetMMUSectionRangeAsCoarsePageTable
43ff: SetMatchRegister
d6bf: ShowBuildInfo
11f05: ShowMemory
11f47: ShowMemoryAddress
a082b0: SlowTaskStacks
15789: StartKernel
9ffffc: StartOfAllocatedERam
9ffffc: StartOfERam
8e39: StartUSB
920d: StopForReEnum
459b: StopHWTimer
9175: StopUSB
6e73: StopUsbMessages
15bf0: StoreArmRegisters
11d7c: StoreCoreRegisters
15bf0: StoreRegisters
11e61: SwitchToKernelModeEntry
4055: SwitchToTxtal
11e5d: SwitchToUserModeEntry
142a3: SyscallHandlerOs
1444f: SystemSWIEntryPoint
a01908: TIMER_THREAD_STACK
a07028: TRACKBALL_DOWN_LINE_Line
a0702c: TRACKBALL_LEFT_LINE_Line
a07030: TRACKBALL_RIGHT_LINE_Line
a07034: TRACKBALL_UP_LINE_Line
a07038: TRACKBALL_X_POWER_Line
11e35: TaskBlockEntry
245b: TaskCallNowX
a07c60: TaskClasses
a01368: TaskContexts
a52740: TaskInfoTable
13b15: TaskRestart
11e25: TaskRestartEntry
13aa3: TaskStop
11e21: TaskStopEntry
a01248: TaskTable
11e39: TaskUnblockEntry
1575d: TaskYield
11df5: TaskYieldEntry
a07610: TavorCommInitInProgress
b5e7: TestPVUsbTuningSupported
b663: TestReadPVUsbTuningReg
b5eb: TestRestorePVUsbTuningRegs
b6a3: TestWritePVUsbTuningReg
e9d9: ThisCoreDebugPush
fe2f: ThreadReturnCatfail
a07650: TimedSemaphoreInitCompleted
46d1: TimedSemaphoreStartTimer
a0764c: TimedSemaphoreTask
4703: TimedSemaphoresInit
d575: Timer2Handle
45cb: TimerHWInit
d1f7: TimerThreadEntryPoint
a11904: Timers
a07be0: TimersPoolSize
13ff1: TryLockInternal
b50d: UNCONFIG_USB_INTERRUPTS
a01000: UND_STACK
a01201: UND_STACK_TOP
a07c44: UQin
a07c48: UQout
3e6b: USBConfigPadDrive
a59d: USB_CD_Handler
b265: USB_IRQ_Handler
a05908: USB_THREAD_STACK
135d9: UnblockFromSemaphore
136a1: UnblockThread
2cfb: Undefined_Handler
35e2c: UniStrBBDevEnglish
86f3: UnifiedUsbDebugTaskHandler
83fb: UnifiedUsbTaskHandler
1359d: UnlockCountingSemaphore
11e1d: UnlockCountingSemaphoreEntry
13769: UnlockSemaphore
11e2d: UnlockSemaphoreEntry
4bbd: UpdateCoreNFrequency
a07628: Uptime
6c21: UsbAddReceiveBuffer
35dc8: UsbBBItf
35da0: UsbBB_BDispSubItf
35db4: UsbBB_MUXSubItf
a113fc: UsbBDispDebug
a07810: UsbBDispDebugIndex
a09800: UsbBuffers
35d60: UsbBugDispInEp
35d70: UsbBugDispOutEp
a077b0: UsbCatfailChannels
a0b6a0: UsbCatfailStatus
a07c34: UsbChannelOpen
a07800: UsbChargerPresent
67f7: UsbCloseChannel
a0e7a0: UsbCommandBuffer
68f7: UsbDeRegisterChannel
4dcf: UsbDeviceReset
bdfd: UsbDrvAttach
c2b7: UsbDrvCancelChanXfer
bfa1: UsbDrvCancelIO
bfa3: UsbDrvCancelOutXfer
bf9d: UsbDrvClearCD
bf9f: UsbDrvClearInts
bf8f: UsbDrvConfigForAcCharging
be4d: UsbDrvConfigureEndpoints
ac35: UsbDrvControlSend
bd4f: UsbDrvControlSendStatus
c2b3: UsbDrvCoreHandlesZLPReads
be19: UsbDrvDetach
baad: UsbDrvDisable
c29f: UsbDrvDisableInPipe
c29d: UsbDrvDisableOutPipe
bf83: UsbDrvDisablePipe
4db5: UsbDrvDummyBYTEArgBYTERet
4d5f: UsbDrvDummyChanArg
bfb9: UsbDrvDumpRegisters
ba37: UsbDrvEnable
bf51: UsbDrvEpToChan
be41: UsbDrvGetCurrentFrame
c2a1: UsbDrvGetMaxOperatingSpeed
ab1f: UsbDrvGetOperatingSpeed
bf81: UsbDrvHandleFailure
b723: UsbDrvInit
bfb3: UsbDrvInitChannel
bf8d: UsbDrvInitPeriph
c2b9: UsbDrvResumeChanXfer
bf4f: UsbDrvSetForceStall
bb5b: UsbDrvSetupInPipe
bb13: UsbDrvSetupOutPipe
bfb7: UsbDrvShutdown
be77: UsbDrvStallPipe
bed1: UsbDrvUnStallPipe
ba25: UsbDrvUninit
aa19: UsbEpPrime
ad89: UsbEpTdComplete
aac1: UsbEpTdInit
ab41: UsbEpTdListInit
a076a0: UsbFullVerbosity
60b3: UsbGenerateBBItfDesc
5b0b: UsbGenerateCfgDesc
5955: UsbGenerateDevDesc
5a5d: UsbGenerateDevQualDesc
5d13: UsbGenerateStrDesc
6d7f: UsbGetBufferInfo
6e85: UsbGetChannelName
62b7: UsbGetChannelOpen
6dd1: UsbGetChannelParameters
4dff: UsbGetChargerRate
623b: UsbGetConnectionStatus
a401: UsbGetCurrEnumMode
8def: UsbGetNvFlags
6281: UsbGetRegisterChannelCapabilities
e753: UsbHPMuxAddReceiveBuffer
e703: UsbHPMuxDeRegisterChannel
e71b: UsbHPMuxOpenChannel
e6df: UsbHPMuxRegisterChannel
e735: UsbHPMuxSendPacket
5437: UsbHostVersionsReadComplete
35de0: UsbModeBBOnly
7c29: UsbMuxCatfail
7c9b: UsbMuxDbgDumpInfo
7adf: UsbMuxDbgDumpQueueInfo
a0d260: UsbMuxGenericBuffer
35d80: UsbMuxInEp
6f37: UsbMuxOff
6ec7: UsbMuxOn
35d90: UsbMuxOutEp
7763: UsbMuxPacketReceived
7135: UsbMuxPacketSent
a076a8: UsbNoPort
4cf1: UsbNoPortCatfailNoArgs
4d41: UsbNoPortControlSend
4d55: UsbNoPortDumpRegisters
4d2d: UsbNoPortSetForceStall
4d05: UsbNoPortStallPipe
4d19: UsbNoPortUnStallPipe
6981: UsbOpenChannel
a07c2c: UsbPacketSending
a0dfa0: UsbQueue
920f: UsbRead
63db: UsbRegisterChannel
62fb: UsbRegisterChannelEx
967d: UsbSend
6a6d: UsbSendPacket
4ef3: UsbSetChargerRate
9fc5: UsbSetNvFlags
35df0: UsbStrCompDevEnglish
35e1a: UsbStrMtpDev
a447: UsbSwitchEnumAttach
a24f: UsbSwitchEnumMode
a543: UsbSwitchModePrintFunctions
e6cd: UsbTaskEntryPoint
b9df: UsbTavorPVChangePhyRX
11e59: UserTaskSyscallEntry
a528f0: VfCmdList
1060f: VfCmdRegister
49a1: VoltageVote
a0703c: WLAN_EN_Line
a07040: WLAN_SD_CLK_Line
a07044: WLAN_SD_CMD_Line
a07048: WLAN_SD_DATA0_Line
a0704c: WLAN_SD_DATA1_Line
a07050: WLAN_SD_DATA2_Line
a07054: WLAN_SD_DATA3_Line
4227: WaitForRtcTicks
11e09: WaitForSpecificMessageEntry
e7f9: WakeDebugTask
1350f: WakeTaskFast
a07c30: WakeupSent
410b: WdtHit
40dd: WdtHitInternal
410f: WdtInit
14bec: WriteCpReg32AUXCTRL
14be4: WriteCpReg32AUXCTRLAnd
14c00: WriteCpReg32AUXCTRLOr
14f64: WriteCpReg32AUXDEBUGCTRL0
14f5c: WriteCpReg32AUXDEBUGCTRL0And
14f78: WriteCpReg32AUXDEBUGCTRL0Or
14fa4: WriteCpReg32AUXDEBUGCTRL1
14f9c: WriteCpReg32AUXDEBUGCTRL1And
14fb8: WriteCpReg32AUXDEBUGCTRL1Or
14fe4: WriteCpReg32AUXFUNCCTRL
14fdc: WriteCpReg32AUXFUNCCTRLAnd
14ff8: WriteCpReg32AUXFUNCCTRLOr
14ed4: WriteCpReg32CACHELOCK
14ecc: WriteCpReg32CACHELOCKAnd
14ee8: WriteCpReg32CACHELOCKOr
14f24: WriteCpReg32CACHESIZESELECT
14f1c: WriteCpReg32CACHESIZESELECTAnd
14f38: WriteCpReg32CACHESIZESELECTOr
14cdc: WriteCpReg32CCNT
14cd4: WriteCpReg32CCNTAnd
14ce4: WriteCpReg32CCNTOr
14e5c: WriteCpReg32CHKPT0
14e54: WriteCpReg32CHKPT0And
14e64: WriteCpReg32CHKPT0Or
14e84: WriteCpReg32CHKPT1
14e7c: WriteCpReg32CHKPT1And
14e8c: WriteCpReg32CHKPT1Or
14bac: WriteCpReg32CPAR
14ba4: WriteCpReg32CPARAnd
14bc0: WriteCpReg32CPAROr
1486c: WriteCpReg32CTRL
14864: WriteCpReg32CTRLAnd
14880: WriteCpReg32CTRLOr
148ec: WriteCpReg32DACR
148e4: WriteCpReg32DACRAnd
14900: WriteCpReg32DACROr
14b6c: WriteCpReg32DBCON
14b64: WriteCpReg32DBCONAnd
14b80: WriteCpReg32DBCONOr
14aec: WriteCpReg32DBR0
14ae4: WriteCpReg32DBR0And
14b00: WriteCpReg32DBR0Or
14b2c: WriteCpReg32DBR1
14b24: WriteCpReg32DBR1And
14b40: WriteCpReg32DBR1Or
14e2c: WriteCpReg32DCSR
14e24: WriteCpReg32DCSRAnd
14e34: WriteCpReg32DCSROr
149ac: WriteCpReg32DLOCK
149a4: WriteCpReg32DLOCKAnd
149c0: WriteCpReg32DLOCKOr
14c64: WriteCpReg32ERRADRL
14c5c: WriteCpReg32ERRADRLAnd
14c6c: WriteCpReg32ERRADRLOr
14c8c: WriteCpReg32ERRADRU
14c84: WriteCpReg32ERRADRUAnd
14c94: WriteCpReg32ERRADRUOr
14c3c: WriteCpReg32ERRLOG
14c34: WriteCpReg32ERRLOGAnd
14c44: WriteCpReg32ERRLOGOr
14d54: WriteCpReg32EVTSEL
14d4c: WriteCpReg32EVTSELAnd
14d5c: WriteCpReg32EVTSELOr
1496c: WriteCpReg32FAR
14964: WriteCpReg32FARAnd
14980: WriteCpReg32FAROr
14d2c: WriteCpReg32FLAG
14d24: WriteCpReg32FLAGAnd
14d34: WriteCpReg32FLAGOr
1492c: WriteCpReg32FSR
14924: WriteCpReg32FSRAnd
14940: WriteCpReg32FSROr
14a6c: WriteCpReg32IBR0
14a64: WriteCpReg32IBR0And
14a80: WriteCpReg32IBR0Or
14aac: WriteCpReg32IBR1
14aa4: WriteCpReg32IBR1And
14ac0: WriteCpReg32IBR1Or
149ec: WriteCpReg32ILOCK
149e4: WriteCpReg32ILOCKAnd
14a00: WriteCpReg32ILOCKOr
14d04: WriteCpReg32INTEN
14cfc: WriteCpReg32INTENAnd
14d0c: WriteCpReg32INTENOr
15024: WriteCpReg32L2CERRTHRESHOLD
1501c: WriteCpReg32L2CERRTHRESHOLDAnd
15038: WriteCpReg32L2CERRTHRESHOLDOr
14a2c: WriteCpReg32PID
14a24: WriteCpReg32PIDAnd
14a40: WriteCpReg32PIDOr
14d7c: WriteCpReg32PMN0
14d74: WriteCpReg32PMN0And
14d84: WriteCpReg32PMN0Or
14da4: WriteCpReg32PMN1
14d9c: WriteCpReg32PMN1And
14dac: WriteCpReg32PMN1Or
14dcc: WriteCpReg32PMN2
14dc4: WriteCpReg32PMN2And
14dd4: WriteCpReg32PMN2Or
14df4: WriteCpReg32PMN3
14dec: WriteCpReg32PMN3And
14dfc: WriteCpReg32PMN3Or
14cb4: WriteCpReg32PMNC
14cac: WriteCpReg32PMNCAnd
14cbc: WriteCpReg32PMNCOr
148ac: WriteCpReg32TTBR0
148a4: WriteCpReg32TTBR0And
148c0: WriteCpReg32TTBR0Or
14e0c: WriteCpReg32TX
14eac: WriteCpReg32TXRXCTRL
14ea4: WriteCpReg32TXRXCTRLAnd
14eb4: WriteCpReg32TXRXCTRLOr
1939: __ARM_get_argv
11150: __ARM_ll_mullu
11158: __ARM_switch8
10915: __I_use_heap_region
10fd0: __aeabi_idiv
10fd0: __aeabi_idivmod
11170: __aeabi_lmul
10d04: __aeabi_memclr
10da8: __aeabi_memclr4
10da8: __aeabi_memclr8
10c30: __aeabi_memcpy
10d44: __aeabi_memcpy4
10d44: __aeabi_memcpy8
10c20: __aeabi_memset
11b34: __aeabi_uidiv
11b34: __aeabi_uidivmod
10918: __aeabi_uldivmod
10f80: __aeabi_uread4
10fa0: __aeabi_uwrite4
1102c: __arm_div4
10ffc: __arm_div8
11080: __arm_div_large
362e9: __ctype
363ec: __lcctype_c_end
362e0: __lcctype_c_name
362e8: __lcctype_c_start
8: __main
116b9: __printf
11b0c: __rt_ctype_table
11b24: __rt_locale
a52b48: __rt_locale_data
10d04: __rt_memclr
10da8: __rt_memclr_w
10c30: __rt_memcpy
10d44: __rt_memcpy_w
11158: __rt_switch8
11ae0: __rt_udiv10
10f80: __rt_uread4
10fa0: __rt_uwrite4
115cd: __strtok_internal
10913: __use_no_heap_region
1933: __user_initial_stackheap
15c28: _get_lc_ctype
10bdc: _ll_div0
11170: _ll_mul
11150: _ll_mullu
10918: _ll_udiv
11618: _ll_udiv10
10a88: _ll_udiv_big
10bbc: _ll_udiv_ginormous
10978: _ll_udiv_small
10ce4: _memcpy_lastbytes
10d90: _memcpy_lastbytes_aligned
10d08: _memset
10dac: _memset_w
1158d: _printf_char_common
11569: _printf_charcount
11a51: _printf_input_char
11999: _printf_int_common
11471: _printf_int_dec
114e1: _printf_longlong_dec
11319: _printf_longlong_hex
113e1: _printf_longlong_oct
11a37: _printf_outstr_char
11991: _printf_percent
111b7: _printf_post_padding
1118d: _printf_pre_padding
1198f: _printf_return_value
11993: _printf_sizespec
11205: _printf_str
111d9: _printf_truncate_signed
111ef: _printf_truncate_unsigned
1125d: _printf_wctomb
115c1: _sputc
a07cb4: _strtok_saves1
10bf9: _vsprintf
11a5b: _wcrtomb
a077a0: activeSendChannel
a07868: addressState
a0779c: allowOpens
8221: appendPowerString
8273: appendStateString
35d50: asciiCvrtTable
41b7: bIsItTickingYet
a07814: bSoftReconnectPending
45f1: between
a07668: blockMask
a0769c: brversion
a0a744: buf
a077ac: bufferListInitialized
a0da60: bufferNode
a07c18: bugdispCommandFpCookie
a0af10: busyCallPool
a0781c: cachedNvFlags
a07820: cachedNvFlagsValid
a0a964: callPool
43bd: catfailTimer
a0784c: cdInterruptStatus
a0c714: channel
12869: checkCtrlIdValidity
4eb9: checkState
1c3b: checkThreshold
9883: clearChannelNotificationPending
5893: clearFeature
a116a8: clockSemaphore
6481: closeChannel
a124d0: cmdGroupHandler
a12480: cmdGroupName
a07764: config
81e9: controlChannelOn
71f9: controlPacketReceived
6fbd: controlPacketSent
a0b694: controlReadBuf
a077e8: controlReadDestination
a0b680: controlReadXfer
a07670: coreFrequencyHz
a01234: criticalSectionCounter
a0775a: curMode
a0778c: curPwrLvl
a07758: curSpeed
a076a4: currentDescriptorState
c95b: cwsbrControl
a07851: debugCurUsbIntIdx
a11698: debugLastUsbInts
a07870: defaultCalData
1284f: defaultIrqHandler
640f: dequeue
a0a804: device
126d3: dmaIsr
a07854: drvEnabled
a07858: drvInited
a07754: dwPendingConfigTransitions
a07778: endpoints
6775: enqueue
a08224: entryHook
35d0c: errorString
a0a824: event
a08228: exitHook
3ac: export_jump_table
43cb: findEarliest
152db: findQueuedMessage
a08164: flags
a0af04: freeCallPool
4adb: freqHzToPossibleIdx
a07660: freqWaitFlag
a06da0: gate
5201: getDescriptor
a231: getDisableClearStallFeature
5803: getGuid
a9b5: getLineStates
53bf: getStatus
a9d3: getTd
9555: getUsbReadStatus
9843: getUsbSendStatus
12dc9: gpioIsr
a0b5e0: guidCache
d383: hMappedStartTimer
a0b600: hostVersionsCommandBuffer
a11610: hwFlags
a0c700: hwInfo
a07794: hwInfoCacheState
a07c0c: iRebootingState
a07614: iResetPowerState
1943: initMemoryFirstStage
1951: initMemorySecondStage
2a05: initMemory_internal
1a54: initSystemStacks
2e51: initializeIntCtrlHandlers
2f03: initializeIntCtrlHw
a07638: initialized
caad: insertTimer
1276b: int17Isr
1271f: int35Isr
12803: int4Isr
12689: int51Isr
127b7: int5Isr
a0815c: intDisableCheckState
a0122c: intDisableCount
a01230: intDisableState
d2c1: internalRemainingTime
cc5f: internalStartTimer
a08160: interruptsWereEnabled
15275: isAcceptableMessage
1c07: isBufferEnabled
9867: isChannelNotificationPending
81a1: isChannelSupported
a07cb8: kernelHeap
a08158: kernelServiceRequestor
a00000: kstacks
a07680: lastSetupFrame
a07694: lastSetupPkt
a06da8: lazyInit
35cf0: locale
15c28: locale$$code
362dc: locale$$data
35d2a: manufacturerString
a0a7c4: mask
a0766c: maxMask
a0767c: maxUsbPower
a0a100: mergeBuffer
151fd: moveMessageToTaskQueue
a52968: msgMap
a08258: mutexHeap
15c89: myArray
a07850: newAddress
a0767e: newMode
a07788: newModeForced
a0767d: newSpeed
a0785c: nextTrn
a0a854: notified
a07c14: numCommandGroups
a07798: openedChannels
36434: os_extended
a07930: pSecTable
a07684: pUsbPort
6565: peek
35ed0: peripheralClocks
a07c84: pfCmdCount
b50f: phyTuningValuesInit
a111a0: pipes
a0b4e0: pmTicks
a07884: port
a06908: priorityMessageCount
b17b: processSetupPacket
a07848: profileMtpSwitchStartTime
a07664: queuedFrequency
a1136c: readPipes
c9e1: recalcEarliestMaxExpiryTime
4287: recalcUptime
a077a8: receiveState
d59b: removeTimerMessageFromQueue
a07c1e: rimLogging
4053: rtcCheckOsc
a0760c: rtcHigh
41ab: rtcPause
a07644: rtcRollHandled
a08230: semaphoreHeap
a0b48c: semaphoreTimers
65b3: sendNextPacket
a11378: sendPipes
52bd: setConfiguration
a1e1: setDisableClearStallFeature
5809: setFeature
4fe1: setState
d589: setTimerInterrupt
80d1: setUsbMsEnaFlag
a07808: setupBuf
a11500: setupBufDW
a0768c: setupCpy
57b9: setupPacket
a07818: softReconnect
a0780c: speedSwitchRequired
a07804: startUSBFinished
a78d: start_cable_check
a06d94: storageForRegisters
a0a700: storageForRegisters_data
10ee0: strcmp
10dfd: strcpy
11a9f: strcspn
10e99: strlen
10e49: strncmp
11ac1: strspn
10fc1: strtok
a077f0: switchStack
53b3: synchFrame
a0a844: task
a01350: taskOldStackUsage
a0822c: taskReadyHook
a07860: testMode
a07864: testModePending
a0a7e4: thresh
4445: timerInterruptHandler
a07648: tmr5Func
80df: toggleMSOnly
80d5: toggleUsbSpeed
a077e4: topFreeNode
a01201: updateAccrBusFreqs
4b21: updateCoreFreqPmTicks
a11384: usbBufArray
a07840: usbCheckAdapterCounter
a11620: usbDrvPipes
a077a4: usbFree
acd1: usbHandleReset
ac93: usbHandleTestModeReq
a0775c: usbIAD
a493: usbInfoItemDataFunc
a453: usbInfoItemInfoFunc
8179: usbInfoMenuInfoFunc
812f: usbInfoMenuItemDataFunc
80e3: usbInfoMenuItemInfoFunc
7ce5: usbInfoScreenInfoFunc
a0776e: usbInterface
a0782c: usbInvStHandle
a077f4: usbModeDefault
35ccc: usbModes
a07844: usbQuincyEnabled
a07830: usbScreens
a077fc: usbStarted
a07838: usbState
4e05: usbStateDump
a07c86: vfCmdCount
fd7b: warnMsgInfo
END SYMBOLS 

BEGIN STRUCTURE DECLARATIONS
;
typedef unsigned char BYTE;
typedef signed char SBYTE;
typedef unsigned short WORD;
typedef signed short SWORD;
typedef unsigned int DWORD;
typedef signed int SDWORD;
typedef unsigned long long QWORD;
typedef signed long long SQWORD;
typedef long                LONG;
typedef unsigned int UINT;
typedef int BOOL;
typedef double DOUBLE;
typedef float FLOAT;
typedef WORD TASK;
typedef struct {
    DWORD bType;
    WORD wide;
    WORD high;
    BYTE *data;
    WORD stride;
    BYTE padding[2];
} BitMap;
typedef struct {
    SDWORD x;
    SDWORD y;
    SDWORD width;
    SDWORD height;
} Rect;
typedef BYTE IOBYTE;
typedef WORD IOWORD;
typedef DWORD IODWORD;
typedef QWORD IOQWORD;
struct _MESSAGE {
    DWORD Device;
    DWORD Event;
    DWORD SubMsg;
    DWORD Length;
    char *DataPtr;
    DWORD Data[2];
};
typedef struct _MESSAGE MESSAGE;
typedef enum {
    RIM_E_FULL = 12,
    E_FULL = 12,
    RIM_E_NODATA = 11,
    E_NODATA = 11,
    RIM_E_EXIST = 10,
    E_EXIST = 10,
    RIM_E_NOTFOUND = 9,
    E_NOTFOUND = 9,
    RIM_E_CATFAIL = 8,
    E_CATFAIL = 8,
    RIM_E_CRITSEC = 7,
    E_CRITSEC = 7,
    RIM_E_TIMEDOUT = 6,
    E_TIMEDOUT = 6,
    RIM_E_ISBUSY = 5,
    E_ISBUSY = 5,
    RIM_E_PERM = 4,
    E_PERM = 4,
    RIM_E_DEADLCK = 3,
    E_DEADLCK = 3,
    RIM_E_ARG = 2,
    E_ARG = 2,
    RIM_E_NOMEM = 1,
    E_NOMEM = 1,
    RIM_E_OK = 0,
    E_OK = 0
} Error_t;
typedef DWORD OsError_t;
typedef struct {
    BYTE second;
    BYTE minute;
    BYTE hour;
    BYTE date;
    BYTE month;
    BYTE day;
    WORD year;
    BYTE TimeZone;
    BYTE unused[3];
} TIME;
typedef unsigned int size_t;
struct __va_list {
    void *__ap;
};
typedef struct __va_list va_list;
typedef enum {
    NUM_BUGDISP_REQUESTS = 8,
    BUGDISP_KEYPAD_LOGGING = 7,
    BUGDISP_SD_CARD_LOGGING = 6,
    BUGDISP_PCMSPEECHLOGGING = 5,
    BUGDISP_ALL_LOGGING = 4,
    BUGDISP_QUINCYSPEECHLOGGING = 3,
    BUGDISP_SPEECHLOGGING = 2,
    BUGDISP_MESSAGES = 1,
    BUGDISP_TIMESTAMPS = 0
} BugDispRequests;
typedef enum {
    PASSWORD_MATCH2 = 2,
    PASSWORD_MATCH1 = 1,
    PASSWORD_NOMATCH = 0
} PASSWORD_MATCH;
typedef enum {
    NUKE_NUKING_5 = 8,
    NUKE_NUKING_4 = 7,
    NUKE_NUKING_3 = 6,
    NUKE_NUKING_2 = 5,
    NUKE_NUKING_1 = 4,
    NUKE_NUKING_0 = 3,
    NUKE_COMPLETE = 2,
    NUKE_NUKING = 1,
    NUKE_OK = 0
} NUKE_STATUS;
typedef enum {
    RESET_CODE_RIMINITIATERESET = 12,
    RESET_CODE_SERIAL_CODE_LOAD = 11,
    RESET_CODE_DEVICE_NUKE = 10,
    RESET_CODE_TEST = 9,
    RESET_CODE_BUGDISP = 8,
    RESET_CODE_STP = 7,
    RESET_CODE_USB_MUX = 6,
    RESET_CODE_DEAD_BATTERY_CHARGE = 5,
    RESET_CODE_BATTERY_PULL = 4,
    RESET_CODE_APPS_REQUIRED = 3,
    RESET_CODE_ERROR = 2,
    RESET_CODE_USER_INITIATED = 1,
    RESET_CODE_UNCLASSIFIED = 0
} ResetCode;
typedef enum {
    SC_DVFM_4_RATIO = 11,
    SC_DVFM_3_RATIO = 10,
    SC_DVFM_2_RATIO = 9,
    SC_DVFM_1_RATIO = 8,
    SC_COMMS_L2_RATIO = 7,
    SC_WIFI_RATIO = 6,
    SC_GPS_RATIO = 5,
    SC_AUDIO_RATIO = 4,
    SC_PL2_RATIO = 3,
    SC_L2_RATIO = 2,
    SC_L1_RATIO = 1,
    SC_LCD_RATIO = 0
} SLOW_CLOCK_RATIO;
typedef enum {
    SC_UPTIME_INTERVAL = 2,
    SC_BATTERY_UPDATE_INTERVAL = 1
} SLOW_CLOCK_INTERVAL;
typedef struct {
    DWORD r4;
    DWORD r5;
    DWORD r6;
    DWORD r7;
    DWORD r8;
    DWORD r9;
    DWORD r10;
    DWORD r11;
    DWORD sp;
    DWORD lr;
    DWORD cpsr;
    DWORD r0;
    DWORD r1;
    DWORD r2;
    DWORD r3;
    DWORD r12;
    DWORD pc;
} RegisterContext;
typedef enum {
    NV_FLASH_OK = 0,
    NV_HASH_EXISTS = -6,
    PACK_FAILED = -7,
    PACK_SUCCESSFUL = -8,
    PACK_REQUIRED = -9,
    NV_FAIL = -10,
    NV_PASS = -11,
    NV_FLASH_NOT_SHARED_MEMORY = -12,
    NV_FLASH_MULTIPLE_UPDATE = -13,
    NV_FLASH_RETRY = -14,
    NV_FLASH_FULL = -15,
    NV_FLASH_FAILED = -16,
    NV_FLASH_DENIED = -17
} NvFlashStatus;
struct DbgTimestamp {
    DWORD DBG_TICK;
    WORD DBG_LATCH;
};
typedef struct DbgTimestamp DbgTimeStamp;
typedef unsigned long BDPARM;
typedef struct {
    DWORD *pReadIndex;
    DWORD *pWriteIndex;
    DWORD SizeMask;
    BYTE *pBuffer;
} CircularBuffer;
struct CountingSemaphore_tag {
    SWORD count;
    SWORD maxCount;
    DWORD initState;
    WORD firstWaiter;
};
typedef struct CountingSemaphore_tag CountingSemaphore;
typedef struct {
    WORD state;
    WORD waiters;
    TASK owner;
    DWORD initState;
} Semaphore;
typedef enum {
    IDLE_THREAD = 5,
    PLATFORM_THREAD = 4,
    APP_THREAD = 3,
    USB_THREAD = 2,
    DEBUG_THREAD = 1,
    TIMER_THREAD = 0
} TaskID;
typedef enum {
    OS_THREAD = 5,
    UMTS_THREAD = 4,
    GPRS_THREAD = 3,
    WIFI_THREAD = 2,
    MWAF_THREAD = 1,
    IDEN_THREAD = 0
} ThreadClass;
typedef enum {
    BLOCK_REASON_BREAKPOINT = 3,
    BLOCK_REASON_INST_BOUNCE = 2,
    BLOCK_REASON_PAGE_FAULT = 1,
    BLOCK_REASON_NONE = 0
} BLOCK_REASON;
enum _OSRET {
    OSRET_FLAG_NOT_PRESENT = 6,
    OSRET_NO_FLAGS = 5,
    OSRET_INVALID_MODE = 4,
    OSRET_INVALID_REF = 3,
    OSRET_INVALID_POINTER = 2,
    OSRET_FAIL = 1,
    OSRET_SUCCESS = 0
};
typedef BYTE OSRET;
enum FlagSuspend {
    FLAG_SUSPEND = 5,
    FLAG_NO_SUSPEND = 4
};
typedef enum FlagSuspend FlagSuspend;
enum FlagOp {
    FLAG_AND_CLEAR = 3,
    FLAG_AND = 2,
    FLAG_OR_CLEAR = 1,
    FLAG_OR = 0
};
typedef enum FlagOp FlagOp;
typedef BYTE RimFlag;
enum CoreMode {
    CORE_MODE_USER = 8,
    CORE_MODE_IN_KERNEL = 7,
    CORE_MODE_KERNEL_INTS_ENABLED = 6,
    CORE_MODE_KERNEL_ENTRYPOINT = 5,
    CORE_MODE_IN_RESET_OR_INTERRUPT = 4,
    CORE_MODE_IN_INTERRUPT = 3,
    CORE_MODE_RESET_OR_CATFAIL = 2,
    CORE_MODE_CATFAIL = 1,
    CORE_MODE_RESET = 0
};
typedef enum CoreMode CoreMode;
typedef struct {
    void *base;
    void *lastSP;
    DWORD size;
    DWORD highWaterMark;
} StackInfo;
typedef enum {
    ALLOC_SCHEME_HYBRID_BUDDY_BLOCK = 2,
    ALLOC_SCHEME_MULTI_SIZE_BUCKETS = 1,
    ALLOC_SCHEME_DEFAULT = 0
} BlockAllocScheme_e;
typedef struct {
    DWORD heapSize;
} AllocSchemeDefaultProperties_t;
typedef struct {
    DWORD blockSize;
    DWORD blockCount;
} AllocSchemeMultiSizeBucketsProperties_t;
typedef struct {
    DWORD partitionSize;
    WORD blockCount;
} AllocSchemeHybridBuddyBlockProperties_t;
typedef enum {
    BLOCK_ALIGN_256 = 256,
    BLOCK_ALIGN_128 = 128,
    BLOCK_ALIGN_64 = 64,
    BLOCK_ALIGN_32 = 32,
    BLOCK_ALIGN_16 = 16,
    BLOCK_ALIGN_8 = 8,
    BLOCK_ALIGN_4 = 4,
    BLOCK_ALIGN_DEFAULT = 0
} BlockAlignment_e;
typedef struct {
    union {
        AllocSchemeDefaultProperties_t defaultScheme;
        AllocSchemeMultiSizeBucketsProperties_t multiSizeBuckets;
        AllocSchemeHybridBuddyBlockProperties_t hybridBuddyBlock;
    } allocSchemeProperties;
    DWORD freeMemoryHighWatermark;
    DWORD freeMemoryLowWatermark;
    BlockAllocScheme_e allocScheme;
    BlockAlignment_e blockAlignment;
    BYTE otherProperties;
    BYTE coresToGrantAccess;
} GenericHeapProperties_t;
typedef enum {
    PREVIOUSLY_OWNED = 2,
    CURRENTLY_OWNED = 1,
    NEVER_OWNED = 0
} HeapBlockOwnerStatus_e;
typedef struct {
    DWORD tag;
    TASK ownerTaskId;
    HeapBlockOwnerStatus_e ownerStatus;
    BYTE referenceCount;
} GenericHeapBlockProperties_t;
typedef BYTE GenericHeapHandle_t;
typedef DWORD GenericHeapBlockHandle_t;
typedef enum {
    GENERIC_HEAP_FAILURE_INVALID_BLOCK = 10,
    GENERIC_HEAP_FAILURE_EXISTING_WATERMARK_LISTENER = 9,
    GENERIC_HEAP_FAILURE_MAX_WATERMARK_LISTENERS = 8,
    GENERIC_HEAP_FAILURE_NOT_BLOCK_OWNER = 7,
    GENERIC_HEAP_FAILURE_BLOCK_ALREADY_OWNED = 6,
    GENERIC_HEAP_FAILURE_ACCESS_RESTRICTION = 5,
    GENERIC_HEAP_FAILURE_ALIGNMENT = 4,
    GENERIC_HEAP_FAILURE_SIZE_OUT_OF_RANGE = 3,
    GENERIC_HEAP_FAILURE_OUT_OF_MEMORY = 2,
    GENERIC_HEAP_FAILURE = 1,
    GENERIC_HEAP_SUCCESS = 0
} GenericHeapErr_e;
typedef enum {
    HEAP_STATS_BASIC_AND_ALLOC_SCHEME = 2,
    HEAP_STATS_BASIC_AND_TAG = 1,
    HEAP_STATS_BASIC = 0
} GenericHeapStatsType_e;
typedef struct {
    GenericHeapStatsType_e type;
    DWORD tag;
} GenericHeapStatsRequest_t;
typedef struct {
    void *heapStart;
    void *heapEnd;
    DWORD allocBlocks;
    DWORD usedBytes;
    DWORD freeBytes;
    DWORD minFreeBytes;
} GenericHeapStatsBasic_t;
typedef struct {
    DWORD tag;
    DWORD tagAllocBlocks;
    DWORD tagUsedBytes;
} GenericHeapStatsTag_t;
typedef struct {
    DWORD largestFreeBlocks[2];
} GenericHeapStatsAllocSchemeMultiSizeBuckets_t;
typedef enum {
    HBB_TYPE_INVALID = -1,
    HBB_NUMBER_OF_TYPES = 4,
    HBB_TYPE_EXTRA_LARGE = 3,
    HBB_TYPE_LARGE = 2,
    HBB_TYPE_MEDIUM = 1,
    HBB_TYPE_SMALL = 0
} HybridBuddyBlockType_e;
typedef struct {
    WORD blocksUsed[4];
    WORD maxBlocksUsed[4];
} GenericHeapStatsAllocSchemeHybridBuddyBlock_t;
typedef struct {
    GenericHeapStatsType_e type;
    GenericHeapStatsBasic_t basic;
    union {
        GenericHeapStatsTag_t tag;
        GenericHeapStatsAllocSchemeMultiSizeBuckets_t msb;
        GenericHeapStatsAllocSchemeHybridBuddyBlock_t hbb;
    } ext;
} GenericHeapStats_t;
typedef enum {
    SEARCH_HAVING_TAG = 6,
    SEARCH_PREVIOUSLY_OWNED_BY_TASK = 5,
    SEARCH_PREVIOUSLY_OWNED = 4,
    SEARCH_NOT_CURRENTLY_OWNED = 3,
    SEARCH_CURRENTLY_OWNED_BY_TASK = 2,
    SEARCH_CURRENTLY_OWNED = 1,
    SEARCH_NEVER_OWNED = 0
} GenericHeapBlockSearchType_e;
typedef enum {
    HEAP_NAME_GROUP_WAF_BUFFER_END = 511,
    HEAP_NAME_GROUP_WAF_BUFFER_START = 256,
    HEAP_NAME_SYSTEM_MC_HEAP = 4,
    HEAP_NAME_DATAQUEUE_HEAP = 3,
    HEAP_NAME_KERNEL_HEAP = 2,
    HEAP_NAME_SYSTEM_HEAP = 1,
    HEAP_NAME_NO_NAME = 0
} GenericHeapName_e;
typedef enum {
    PAD_LATCH_NONE = 2,
    PAD_LATCH_RISING_EDGE = 1,
    PAD_LATCH_FALLING_EDGE = 0
} PadLatchState;
typedef enum {
    PAD_DRIVE_FAST = 3,
    PAD_DRIVE_MEDIUM = 2,
    PAD_DRIVE_SLOW = 1,
    DEFAULT_STRENGTH_SLEW = 0
} PadDriveStrengthSlewRate;
typedef enum {
    SLEEP_SEL_COMMS = 2,
    SLEEP_SEL_APPS = 1,
    SLEEP_SEL_DEFAULT = 0
} PadSleepSel;
typedef enum {
    SLEEP_DATA_LOW = 2,
    SLEEP_DATA_HIGH = 1,
    SLEEP_DATA_DEFAULT = 0
} PadSleepData;
typedef enum {
    SLEEP_DIRECTION_OUTPUT = 2,
    SLEEP_DIRECTION_INPUT = 1,
    SLEEP_DIRECTION_DEFAULT = 0
} PadSleepDirection;
typedef enum {
    EDGE_DETECT_DISABLE = 2,
    EDGE_DETECT_ENABLE = 1,
    EDGE_DETECT_DEFAULT = 0
} PadEdgeDetect;
typedef enum {
    PULL_SEL_ALT_MODE = 2,
    PULL_SEL_MFPR = 1,
    PULL_SEL_DEFAULT = 0
} PadPullSel;
typedef enum {
    USE_RDH_DISABLE = 2,
    USE_RDH_ENABLE = 1,
    USE_RDH_DEFAULT = 0
} PadUseRdh;
typedef struct {
    PadDriveStrengthSlewRate drive;
    PadSleepSel sleepSel;
    PadSleepData sleepData;
    PadSleepDirection sleepDirection;
    PadPullSel pullSel;
    PadUseRdh useRdh;
    PadEdgeDetect edgeDetectEnable;
    BOOL detectRisingEdge;
    BOOL detectFallingEdge;
} DeviceSpecificPadConfiguration;
typedef DWORD Line;
typedef enum {
    PAD_INTERRUPT_LOW_LEVEL = 5,
    PAD_INTERRUPT_HIGH_LEVEL = 4,
    PAD_INTERRUPT_BOTH_EDGES = 3,
    PAD_INTERRUPT_FALLING_EDGE = 2,
    PAD_INTERRUPT_RISING_EDGE = 1,
    PAD_INTERRUPT_NONE = 0
} PadInterruptType;
typedef enum {
    PAD_DIRECTION_OUTPUT = 1,
    PAD_DIRECTION_INPUT = 0
} PadDirection;
typedef enum {
    PAD_FALLING_EDGE_LATCH = 8,
    PAD_RISING_EDGE_LATCH = 7,
    PAD_INPUT = 6,
    PAD_PULL_DOWN = 5,
    PAD_PULL_UP = 4,
    PAD_INPUT_ENABLE = 3,
    PAD_OUTPUT_ENABLE = 2,
    PAD_OUTPUT_SLEEP_OFF = 1,
    PAD_OUTPUT = 0
} PadAttribute;
struct PadConfiguration_struct {
    DWORD altFunctionMode;
    PadDirection initialDirection;
    BOOL initialLevel;
    BOOL pullUpEnable;
    BOOL pullDownEnable;
    PadInterruptType interruptType;
    void *interruptHandler;
    BOOL interruptsInitiallyEnabled;
    BOOL interruptDebounceEnabled;
};
typedef struct PadConfiguration_struct PadConfiguration;
struct MsgQTag {
    struct MsgQTag *Next;
    TASK Sender;
    WORD Flags;
    MESSAGE Msg;
};
typedef struct MsgQTag MsgQ;
typedef enum {
    NUMBER_OF_NTIMERS = 589,
    GPS_LOCATION_AIDING_REQUEST_TIMER = 588,
    TIMER_GETMESSAGE_TIMEOUT = 587,
    LATTE_STATIC_TIMER = 586,
    BQHUGE_FAKE_REMOVAL_TIMER = 584,
    IPC_SIGNAL_RATE_TIMER = 584,
    ORPHEUS_CHANNEL_SCAN_DELAY_TIMER = 583,
    TIMER_GAN_WAIT_FOR_USER = 582,
    TIMER_GAN_CSR_HANDOVER_RETRY = 581,
    SIMCARD_FORCE_RETRY_TIMER = 580,
    SIMCARD_RECOVERY_BACKOFF_TIMER = 579,
    TIMER_CC_TONE = 578,
    ICMP_ERROR_TOKEN_BUCKET_TIMER = 577,
    IPP_OSAPI_MC_WAIT_TIMER = 576,
    IPP_OSAPI_DEBLOCK_WAIT_TIMER = 575,
    IPP_OSAPI_DMA_WAIT_TIMER = 574,
    IPP_OSAPI_MTX_WAIT_TIMER = 573,
    LAST_OUTPUTSYS_TASK_TIMER = 572,
    OUTPUTSYS_TASK_TIMER_11 = 571,
    OUTPUTSYS_TASK_TIMER_10 = 570,
    OUTPUTSYS_TASK_TIMER_9 = 569,
    OUTPUTSYS_TASK_TIMER_8 = 568,
    OUTPUTSYS_TASK_TIMER_7 = 567,
    OUTPUTSYS_TASK_TIMER_6 = 566,
    OUTPUTSYS_TASK_TIMER_5 = 565,
    OUTPUTSYS_TASK_TIMER_4 = 564,
    OUTPUTSYS_TASK_TIMER_3 = 563,
    OUTPUTSYS_TASK_TIMER_2 = 562,
    FIRST_OUTPUTSYS_TASK_TIMER = 561,
    NEW_SEMAPHORE_TIMER = 560,
    MN_DELAYED_MESSAGE_TIMER = 559,
    GPS_EE_REQUEST_TIMER = 558,
    FREQ_CHANGE_TIMER = 557,
    RIM_OMX_TIMER_0 = 556,
    I2C_TIMEOUT_TIMER = 555,
    BUGMON_TIMER = 554,
    SERMUX_TIMEOUT_TIMER = 553,
    TIMER_L1CTL = 552,
    DYNAMIC_TIMER_48 = 551,
    DYNAMIC_TIMER_47 = 550,
    DYNAMIC_TIMER_46 = 549,
    DYNAMIC_TIMER_45 = 548,
    DYNAMIC_TIMER_44 = 547,
    DYNAMIC_TIMER_43 = 546,
    DYNAMIC_TIMER_42 = 545,
    DYNAMIC_TIMER_41 = 544,
    DYNAMIC_TIMER_40 = 543,
    DYNAMIC_TIMER_39 = 542,
    DYNAMIC_TIMER_38 = 541,
    DYNAMIC_TIMER_37 = 540,
    DYNAMIC_TIMER_36 = 539,
    DYNAMIC_TIMER_35 = 538,
    DYNAMIC_TIMER_34 = 537,
    DYNAMIC_TIMER_33 = 536,
    DYNAMIC_TIMER_32 = 535,
    DYNAMIC_TIMER_31 = 534,
    DYNAMIC_TIMER_30 = 533,
    DYNAMIC_TIMER_29 = 532,
    DYNAMIC_TIMER_28 = 531,
    DYNAMIC_TIMER_27 = 530,
    DYNAMIC_TIMER_26 = 529,
    DYNAMIC_TIMER_25 = 528,
    DYNAMIC_TIMER_24 = 527,
    DYNAMIC_TIMER_23 = 526,
    DYNAMIC_TIMER_22 = 525,
    DYNAMIC_TIMER_21 = 524,
    DYNAMIC_TIMER_20 = 523,
    DYNAMIC_TIMER_19 = 522,
    DYNAMIC_TIMER_18 = 521,
    DYNAMIC_TIMER_17 = 520,
    DYNAMIC_TIMER_16 = 519,
    DYNAMIC_TIMER_15 = 518,
    DYNAMIC_TIMER_14 = 517,
    DYNAMIC_TIMER_13 = 516,
    DYNAMIC_TIMER_12 = 515,
    DYNAMIC_TIMER_11 = 514,
    DYNAMIC_TIMER_10 = 513,
    DYNAMIC_TIMER_9 = 512,
    DYNAMIC_TIMER_8 = 511,
    DYNAMIC_TIMER_7 = 510,
    DYNAMIC_TIMER_6 = 509,
    DYNAMIC_TIMER_5 = 508,
    DYNAMIC_TIMER_4 = 507,
    DYNAMIC_TIMER_3 = 506,
    DYNAMIC_TIMER_2 = 505,
    DYNAMIC_TIMER_1 = 504,
    SYSPROF_NATIVE_IP_TIMER = 503,
    USER_DEFINED_TEST_TIMER = 502,
    RNG_MIX_TIMER = 498,
    CAMERA2_MV9319_ISP_ESD_CHK = 497,
    CAMERA2_MV9319_ISP_DARKNESS_CHK = 496,
    CAMERA2_MV9319_ISP_AF_COMPLETE_CHK = 495,
    CAMERA2_MV9319_ISP_CLK_VERIFY = 494,
    CAMERA2_MV9319_ISP_STATUS_MONITOR = 493,
    CAMERA2_ESD_CHK = 492,
    CAMERA2_DARKNESS_CHK = 491,
    CAMERA2_STATUS_MONITOR = 490,
    DUMMY_TIMER = 489,
    WATCHDOG_TIMER = 488,
    DVFM_NTIMER = 487,
    OVERTEMPERATURE_TIMER = 486,
    RIM_SEMAPHORE_TIMER = 485,
    TASKSLEEP_TIMER = 484,
    LAST_IOTASK_TIMER = 483,
    IO_TASK_TIMER_49 = 482,
    IO_TASK_TIMER_48 = 481,
    IO_TASK_TIMER_47 = 480,
    IO_TASK_TIMER_46 = 479,
    IO_TASK_TIMER_45 = 478,
    IO_TASK_TIMER_44 = 477,
    IO_TASK_TIMER_43 = 476,
    IO_TASK_TIMER_42 = 475,
    IO_TASK_TIMER_41 = 474,
    IO_TASK_TIMER_40 = 473,
    IO_TASK_TIMER_39 = 472,
    IO_TASK_TIMER_38 = 471,
    IO_TASK_TIMER_37 = 470,
    IO_TASK_TIMER_36 = 469,
    IO_TASK_TIMER_35 = 468,
    IO_TASK_TIMER_34 = 467,
    IO_TASK_TIMER_33 = 466,
    IO_TASK_TIMER_32 = 465,
    IO_TASK_TIMER_31 = 464,
    IO_TASK_TIMER_30 = 463,
    IO_TASK_TIMER_29 = 462,
    IO_TASK_TIMER_28 = 461,
    IO_TASK_TIMER_27 = 460,
    IO_TASK_TIMER_26 = 459,
    IO_TASK_TIMER_25 = 458,
    IO_TASK_TIMER_24 = 457,
    IO_TASK_TIMER_23 = 456,
    IO_TASK_TIMER_22 = 455,
    IO_TASK_TIMER_21 = 454,
    IO_TASK_TIMER_20 = 453,
    IO_TASK_TIMER_19 = 452,
    IO_TASK_TIMER_18 = 451,
    IO_TASK_TIMER_17 = 450,
    IO_TASK_TIMER_16 = 449,
    IO_TASK_TIMER_15 = 448,
    IO_TASK_TIMER_14 = 447,
    IO_TASK_TIMER_13 = 446,
    IO_TASK_TIMER_12 = 445,
    IO_TASK_TIMER_11 = 444,
    IO_TASK_TIMER_10 = 443,
    IO_TASK_TIMER_9 = 442,
    IO_TASK_TIMER_8 = 441,
    IO_TASK_TIMER_7 = 440,
    IO_TASK_TIMER_6 = 439,
    IO_TASK_TIMER_5 = 438,
    IO_TASK_TIMER_4 = 437,
    IO_TASK_TIMER_3 = 436,
    IO_TASK_TIMER_2 = 435,
    FIRST_IOTASK_TIMER = 434,
    BQHUGE_UTC_TICK = 433,
    BQHUGE_ACPG_DEBOUNCE_TIMER = 432,
    BQHUGE_USBPG_DEBOUNCE_TIMER = 431,
    BQMIGHTY_ACPG_DEBOUNCE_TIMER = 430,
    BQMIGHTY_USBPG_DEBOUNCE_TIMER = 429,
    BQMIGHTY_STATUS_DEBOUNCE_TIMER = 428,
    CAMERA_FLASH_TIMER = 427,
    SMARTCARD_OPEN_TIMER = 426,
    SERIAL_TEST_TIMER = 425,
    GPS_ADC_NVRAM_SAVE_TIMER = 424,
    GPS_RADIO_PDU_KEEP_AWAKE_TIMER = 423,
    GPS_FREQ_AIDING_TIMER = 422,
    GPS_CHANNEL_BLOCK_TIMER_3 = 421,
    GPS_CHANNEL_BLOCK_TIMER_2 = 420,
    GPS_CHANNEL_BLOCK_TIMER_1 = 419,
    GPS_AIDING_REQUEST_TIMER = 418,
    GPS_PERIODIC_FIX_TIMER = 417,
    GPS_TEST_TIMER_3 = 416,
    GPS_TEST_TIMER_2 = 415,
    GPS_TEST_TIMER_1 = 414,
    GPS_WAKEUP_TIMER = 413,
    GPS_HIBERNATE_TIMER = 412,
    GPS_SERIAL_TIMER = 411,
    BLUETOOTH_TIMER_A2DP_AUDIO_TICK = 410,
    BLUETOOTH_TIMER_UART_RESET = 409,
    BLUETOOTH_TIMER_OS = 408,
    TIMER_WB_CAL = 407,
    OSA_TASK_SLEEP = 406,
    OSA_TIMER_24 = 405,
    OSA_TIMER_23 = 404,
    OSA_TIMER_22 = 403,
    OSA_TIMER_21 = 402,
    OSA_TIMER_20 = 401,
    OSA_TIMER_19 = 400,
    OSA_TIMER_18 = 399,
    OSA_TIMER_17 = 398,
    OSA_TIMER_16 = 397,
    OSA_TIMER_15 = 396,
    OSA_TIMER_14 = 395,
    OSA_TIMER_13 = 394,
    OSA_TIMER_12 = 393,
    OSA_TIMER_11 = 392,
    OSA_TIMER_10 = 391,
    OSA_TIMER_9 = 390,
    OSA_TIMER_8 = 389,
    OSA_TIMER_7 = 388,
    OSA_TIMER_6 = 387,
    OSA_TIMER_5 = 386,
    OSA_TIMER_4 = 385,
    OSA_TIMER_3 = 384,
    OSA_TIMER_2 = 383,
    OSA_TIMER_1 = 382,
    RADIO_PROTOTYPING_TIMER_50 = 381,
    RADIO_PROTOTYPING_TIMER_49 = 380,
    RADIO_PROTOTYPING_TIMER_48 = 379,
    RADIO_PROTOTYPING_TIMER_47 = 378,
    RADIO_PROTOTYPING_TIMER_46 = 377,
    RADIO_PROTOTYPING_TIMER_45 = 376,
    RADIO_PROTOTYPING_TIMER_44 = 375,
    RADIO_PROTOTYPING_TIMER_43 = 374,
    RADIO_PROTOTYPING_TIMER_42 = 373,
    RADIO_PROTOTYPING_TIMER_41 = 372,
    RADIO_PROTOTYPING_TIMER_40 = 371,
    RADIO_PROTOTYPING_TIMER_39 = 370,
    RADIO_PROTOTYPING_TIMER_38 = 369,
    RADIO_PROTOTYPING_TIMER_37 = 368,
    RADIO_PROTOTYPING_TIMER_36 = 367,
    RADIO_PROTOTYPING_TIMER_35 = 366,
    RADIO_PROTOTYPING_TIMER_34 = 365,
    RADIO_PROTOTYPING_TIMER_33 = 364,
    RADIO_PROTOTYPING_TIMER_32 = 363,
    RADIO_PROTOTYPING_TIMER_31 = 362,
    RADIO_PROTOTYPING_TIMER_30 = 361,
    RADIO_PROTOTYPING_TIMER_29 = 360,
    RADIO_PROTOTYPING_TIMER_28 = 359,
    RADIO_PROTOTYPING_TIMER_27 = 358,
    RADIO_PROTOTYPING_TIMER_26 = 357,
    RADIO_PROTOTYPING_TIMER_25 = 356,
    RADIO_PROTOTYPING_TIMER_24 = 355,
    RADIO_PROTOTYPING_TIMER_23 = 354,
    RADIO_PROTOTYPING_TIMER_22 = 353,
    RADIO_PROTOTYPING_TIMER_21 = 352,
    RADIO_PROTOTYPING_TIMER_20 = 351,
    RADIO_PROTOTYPING_TIMER_19 = 350,
    RADIO_PROTOTYPING_TIMER_18 = 349,
    RADIO_PROTOTYPING_TIMER_17 = 348,
    RADIO_PROTOTYPING_TIMER_16 = 347,
    RADIO_PROTOTYPING_TIMER_15 = 346,
    RADIO_PROTOTYPING_TIMER_14 = 345,
    RADIO_PROTOTYPING_TIMER_13 = 344,
    RADIO_PROTOTYPING_TIMER_12 = 343,
    RADIO_PROTOTYPING_TIMER_11 = 342,
    RADIO_PROTOTYPING_TIMER_10 = 341,
    RADIO_PROTOTYPING_TIMER_9 = 340,
    BATTERY_INFO_TIMEOUT_TIMER = 339,
    TX_RX_ICON_TIMER = 338,
    IDEN_RX_ICON_TIMER = 337,
    IDEN_TX_ICON_TIMER = 336,
    INTERCONNECT_CALL_TIMER = 335,
    SMS_DELETE_TIMER = 334,
    SMS_BOOTUP_TIMER = 333,
    AIRPLANE_MODE_TIMER = 332,
    RALP_COMM_RETRY_TIMER = 331,
    RALP_ENG_SCREEN_TRACE_TIMER = 330,
    RALP_ENG_SCREEN_FAST_TIMER = 329,
    LOGSERVER_GENERAL_TIMER = 328,
    COMM_TIMEOUT_TIMER = 327,
    RALP_SIGNAL_LEVEL_TIMER = 326,
    RALP_BATT_LEVEL_TIMER = 325,
    TIMER_WACK = 324,
    TIMER_ENQ = 323,
    RRP_RETRANSMIT_TIMER = 322,
    RRP_DELAYED_ACK_TIMER = 321,
    RRP_LINK_PROBE_TIMER = 320,
    PPP_IP_REASSEMBLY_TIMEOUT_TIMER = 319,
    PPP_RECEIVE_TIMEOUT = 318,
    PPP_LCP_PING_TIMEOUT = 317,
    PPP_AT_RESPONSE_TIMER = 316,
    PATRIOT_OS_TIMER = 315,
    TIMER_LCS_VERIFY = 314,
    TIMER_DSM = 313,
    TIMER_PHYLLO = 312,
    WAF_3GPP_DEACTIVATE_GUARD_TIMER = 311,
    SIB7_MONITORING_TIMER = 310,
    DP_TEST_TIMER = 309,
    MO_SMS_RETRY_TIMER = 308,
    TIMER_INIT_DELAY = 307,
    TIMER_NAS_TRAFFIC_TEST = 306,
    TIMER_HZ_CBSMS = 305,
    AUDIO_SERVICES_TIMER = 304,
    BATTERY_MEASURE_TIMER = 303,
    AUTO_ANSWER_DELAY = 302,
    TIMER_CC_AOC = 301,
    TIMER_IN_CALL_SS = 300,
    TIMER_337 = 299,
    TIMER_336 = 298,
    TIMER_CC6 = 297,
    TIMER_CC5 = 296,
    TIMER_CC4 = 295,
    TIMER_CC3 = 294,
    TIMER_CC2 = 293,
    TIMER_CC1 = 292,
    TIMER_CC0 = 291,
    TIMER_SIM_RESPONSE_GUARD = 290,
    SAT_EVENTLIST_TIMER = 289,
    SAT_TIMER_MANAGEMENT_8 = 288,
    SAT_TIMER_MANAGEMENT_7 = 287,
    SAT_TIMER_MANAGEMENT_6 = 286,
    SAT_TIMER_MANAGEMENT_5 = 285,
    SAT_TIMER_MANAGEMENT_4 = 284,
    SAT_TIMER_MANAGEMENT_3 = 283,
    SAT_TIMER_MANAGEMENT_2 = 282,
    SAT_TIMER_MANAGEMENT_1 = 281,
    SAT_PLAYTONE_TIMER = 280,
    AT_APP_CALLBACK_TIMER = 279,
    AT_CKPD_KEYPAUSE_TIMER = 278,
    AT_CKPD_KEYSTROKE_TIMER = 277,
    AT_COPS_MODE_4_TIMER = 276,
    PPP_TIMEOUT_TIMER = 275,
    TIMER_SAT_RESPONSE = 274,
    TIMER_SAT_SEND_MO_SM = 273,
    TIMER_SAT_MO_CALL = 272,
    KEYPAD_DEBOUNCE_TIMER = 271,
    CAMERA2_SIMULATOR_FRAME_CAPTURE_SIM = 270,
    CAMERA2_AF_COMPLETE_CHK = 269,
    TIMER_DELAY_APPS_ACK = 268,
    TRAM_TIMER = 267,
    TR2M_TIMER = 266,
    TR1M_TIMER = 265,
    MT_TC1M_TIMER = 264,
    MO_TC1M_TIMER = 263,
    TIMER_RAB_ESTABLISH = 262,
    TIMER_33XX_NSAPI_11 = 261,
    TIMER_33XX_NSAPI_10 = 260,
    TIMER_33XX_NSAPI_9 = 259,
    TIMER_33XX_NSAPI_8 = 258,
    TIMER_33XX_NSAPI_7 = 257,
    TIMER_33XX_NSAPI_6 = 256,
    TIMER_33XX_NSAPI_5 = 255,
    TIMER_MM_UI_DEBOUNCE = 254,
    TIMER_MM_RECOVERY = 253,
    TIMER_E911_CALL_BACK = 252,
    TIMER_RAT_CHANGE = 251,
    TIMER_GPRS_DETACH_COMPLETE = 250,
    TIMER_3330 = 249,
    TIMER_3321 = 248,
    TIMER_3320 = 247,
    TIMER_3318 = 246,
    TIMER_3314 = 245,
    TIMER_3312 = 244,
    TIMER_3311 = 243,
    TIMER_3310 = 242,
    TIMER_3302 = 241,
    TIMER_3240 = 240,
    TIMER_3230 = 239,
    TIMER_3220 = 238,
    TIMER_3213 = 237,
    TIMER_3212 = 236,
    TIMER_3211 = 235,
    TIMER_3210 = 234,
    TIMER_FLA_LIST_DELETE = 233,
    TIMER_PLMN_SEARCH = 232,
    T201_LL11_TIMER = 231,
    T201_LL9_TIMER = 230,
    T201_LL5_TIMER = 229,
    T201_LL3_TIMER = 228,
    SELECT_MODE_TIMEOUT = 227,
    RSSI_SCAN_TIMER = 225,
    TIMER_GAN_DEREGISTRATION_GUARD = 224,
    TIMER_GAN_KEEPALIVE_ACTIVE = 223,
    TIMER_GAN_FLUSH_PACKET_BUFFER = 222,
    TIMER_GAN_FLOW_CONTROL = 221,
    TIMER_TU4003 = 220,
    TIMER_TU4002 = 219,
    TIMER_TU4001 = 218,
    TIMER_TU3920 = 217,
    TIMER_TU3910 = 216,
    TIMER_TU3908 = 215,
    TIMER_TU3907 = 214,
    TIMER_TU3906 = 213,
    TIMER_TU3905 = 212,
    TIMER_TU3904 = 211,
    TIMER_TU3903 = 210,
    TIMER_TU3902 = 209,
    TIMER_TU3901 = 208,
    GAS_T3184 = 207,
    GAS_T3166 = 206,
    GAS_T3192 = 205,
    GAS_T3190 = 204,
    GAS_T3180 = 203,
    GAS_T3164 = 202,
    GAS_T3182 = 201,
    GAS_RRC_TIMER = 200,
    UMTS_MAC_TIMER = 199,
    UMTS_RLC_TIMER = 198,
    UMTS_RRC_TIMER = 197,
    SOCKET_IP_TX_BE_TIMER = 196,
    SOCKET_CLOSE_TIMER = 195,
    SOCKET_LINGER_TIMER = 194,
    SOCKET_TX_TIMER = 193,
    SOCKET_RX_TIMER = 192,
    VPN_IPSEC_LIFETIME_TIMER = 191,
    VPN_IKE_LIFETIME_TIMER = 190,
    VPN_KEEPALIVE_TIMER = 189,
    VPN_SIM_RETRY_TIMER = 188,
    VPN_IKE_REPLY_TIMER = 187,
    WAF_WLAN_DEACTIVATE_GUARD_TIMER = 186,
    WLAN_LLC_ARP_TIMEOUT = 185,
    DTIMEXTEND_ARP_REFRESH = 184,
    ADCTRL_TIMER = 183,
    ESCREEN_APP_TIMER_11 = 182,
    ESCREEN_APP_TIMER_10 = 181,
    PGEN_EXECUTION_TIMER = 180,
    PGEN_SEND_PACKET_TIMER = 179,
    ESCREEN_APP_TIMER_7 = 178,
    ESCREEN_APP_TIMER_6 = 177,
    ESCREEN_APP_TIMER_5 = 176,
    ESCREEN_APP_TIMER_4 = 175,
    ESCREEN_APP_TIMER_3 = 174,
    ESCREEN_APP_TIMER_2 = 173,
    ESCREEN_APP_TIMER_1 = 172,
    SUPP_TIMER_14 = 171,
    SUPP_TIMER_13 = 170,
    SUPP_TIMER_12 = 169,
    SUPP_TIMER_11 = 168,
    SUPP_TIMER_10 = 167,
    SUPP_TIMER_9 = 166,
    SUPP_TIMER_8 = 165,
    SUPP_TIMER_7 = 164,
    SUPP_TIMER_6 = 163,
    SUPP_TIMER_5 = 162,
    SUPP_TIMER_4 = 161,
    SUPP_TIMER_3 = 160,
    SUPP_TIMER_2 = 159,
    SUPP_TIMER_1 = 158,
    SUPP_TIMER_0 = 157,
    TI_WLAN_AP_POLL_TIMER = 156,
    TI_WLAN_TIMER_44 = 155,
    TI_WLAN_TIMER_43 = 154,
    TI_WLAN_TIMER_42 = 153,
    TI_WLAN_TIMER_41 = 152,
    TI_WLAN_TIMER_40 = 151,
    TI_WLAN_TIMER_39 = 150,
    TI_WLAN_TIMER_38 = 149,
    TI_WLAN_TIMER_37 = 148,
    TI_WLAN_TIMER_36 = 147,
    TI_WLAN_TIMER_35 = 146,
    TI_WLAN_TIMER_34 = 145,
    TI_WLAN_TIMER_33 = 144,
    TI_WLAN_TIMER_32 = 143,
    TI_WLAN_TIMER_31 = 142,
    TI_WLAN_TIMER_30 = 141,
    TI_WLAN_TIMER_29 = 140,
    TI_WLAN_TIMER_28 = 139,
    TI_WLAN_TIMER_27 = 138,
    TI_WLAN_TIMER_26 = 137,
    TI_WLAN_TIMER_25 = 136,
    TI_WLAN_TIMER_24 = 135,
    TI_WLAN_TIMER_23 = 134,
    TI_WLAN_TIMER_22 = 133,
    TI_WLAN_TIMER_21 = 132,
    TI_WLAN_TIMER_20 = 131,
    TI_WLAN_TIMER_19 = 130,
    TI_WLAN_TIMER_18 = 129,
    TI_WLAN_TIMER_17 = 128,
    TI_WLAN_TIMER_16 = 127,
    TI_WLAN_TIMER_15 = 126,
    TI_WLAN_TIMER_14 = 125,
    TI_WLAN_TIMER_13 = 124,
    TI_WLAN_TIMER_12 = 123,
    TI_WLAN_TIMER_11 = 122,
    TI_WLAN_TIMER_10 = 121,
    TI_WLAN_TIMER_9 = 120,
    TI_WLAN_TIMER_8 = 119,
    TI_WLAN_TIMER_7 = 118,
    TI_WLAN_TIMER_6 = 117,
    TI_WLAN_TIMER_5 = 116,
    TI_WLAN_TIMER_4 = 115,
    TI_WLAN_TIMER_3 = 114,
    TI_WLAN_TIMER_2 = 113,
    TI_WLAN_TIMER_1 = 112,
    TI_WLAN_TIMER_0 = 111,
    WLAN_POWER_STATISTICS_TIMER = 110,
    WLAN_ACTIVITY_PERCENTAGE_TIMER = 109,
    IOTCTRL_XMIT_TIMER = 108,
    SEMAPHORE_TIMER = 107,
    TEST_WLAN_TIMER = 106,
    STACK_FREE_STATUS_TIMER = 105,
    WLAN_STATE_MACHINE_TIMER = 104,
    ESCREENS2_REFRESH_TIMER = 103,
    ESCREENS2_GENERIC_TIMER = 102,
    WLAN_RX_ICON_TIMER = 101,
    WLAN_TX_ICON_TIMER = 100,
    WLAN_SIGNAL_TIMER = 99,
    DHCP_TX_TIMER = 98,
    DHCP_STATE_TIMER = 97,
    ARP_CLEAR_CACHE_TIMER = 96,
    ARP_REPLY_CHECK_TIMER = 95,
    WLAN_SCAN_ENGINE_TIMER = 94,
    WLAN_BACKOFF_TIMER = 93,
    WLAN_SCAN_TIMER = 92,
    RTP_GAN_MEASUREMENT_REPORT_TIMER = 91,
    RTP_STATISTICS_REPORT_TIMER = 90,
    RTP_TIMEOUT_TIMER = 89,
    RTCP_TIMER = 88,
    ADC_TIMER_3 = 87,
    ADC_TIMER_2 = 86,
    ADC_TIMER_1 = 85,
    ADC_TIMER_0 = 84,
    PMIC_PULL_INT_TIMER = 83,
    RTCP_UMA_TIMER = 82,
    RTCP_VOIP_TIMER = 81,
    RTP_RINGBACK_TIMEOUT_TIMER = 80,
    RTSP_KEEP_ALIVE_TIMER = 79,
    RTSP_STREAMING_CHECK_TIMER = 78,
    RTP_MEDIA_END_TIMER = 77,
    RTP_MEDIA_LENGTH_TIMER = 76,
    RTCP_STREAMING_TIMER = 75,
    TUNNEL_FOCUS_DEBOUNCE_TIMER = 74,
    TUNNEL_FOCUS_TIMER = 73,
    WM_TNLCTRL_SM_TIMER_TID8 = 72,
    WM_TNLCTRL_SM_TIMER_TID7 = 71,
    WM_TNLCTRL_SM_TIMER_TID6 = 70,
    WM_TNLCTRL_SM_TIMER_TID5 = 69,
    WM_TNLCTRL_SM_TIMER_TID4 = 68,
    WM_TNLCTRL_SM_TIMER_TID3 = 67,
    WM_TNLCTRL_SM_TIMER_TID2 = 66,
    WM_TNLCTRL_SM_TIMER_TID1 = 65,
    WAF_CDMA_DEACTIVATE_GUARD_TIMER = 64,
    DNS_TIMER = 63,
    NETTP_REQUEST_TIMER = 62,
    TCP_DELAYED_ACK_TIMER = 61,
    TCP_CLOSE_TIME_WAIT_TIMER = 60,
    TCP_RETRANSMISSION_TIMER = 59,
    IPTRACK_ENTRY_AGE_TIMER = 58,
    IP_FRAG_TIMEOUT_TIMER = 57,
    TOUCHSCREEN_TIMER = 56,
    RIM_VIDEO_FRAME_REQ_TIMER = 55,
    RIM_MEDIA_SYNC_TIMER = 54,
    RIM_VIDEO_SATURATION_TIMER = 53,
    RIM_VIDEO_TICK_TIMER = 52,
    SIMCARD_PROACTIVE_POLL_TIMER = 51,
    SIMCARD_CLOCK_STOP_TIMER = 50,
    SIMCARD_TIMEOUT_TIMER = 49,
    HOOKSWITCH_GPIO_DEBOUNCE = 48,
    CODEC_RESET_TIMER = 42,
    CODEC_PENDING_OFF_TIMER = 41,
    CODEC_POLL_TIMER = 40,
    CODEC_DEBOUNCE_TIMER = 39,
    HEADSET_GPIO_DEBOUNCE_TIMER = 38,
    HOOKSWITCH_POLL_TIMER = 37,
    HOOKSWITCH_DEBOUNCE_TIMER = 36,
    MBH_TIMEOUT_TIMER = 35,
    HOOKSWITCH_CHANGED_DELAY_TIMER = 34,
    HOOKSWITCH_BIAS_EXCLUSION_TIMER = 33,
    HOOKSWITCH_EXCLUSION_TIMER = 32,
    HEADSET_DEBOUNCE_TIMER = 31,
    AUDIOLOGGING_NVRAM_TIMEOUT = 30,
    AUDIO_TUNE_TIMER = 29,
    AUDIO_HEARTBEAT_TIMER = 28,
    DTMF_TIMER = 27,
    STP_MELODY_TIMER = 26,
    UNIT_TEST_TIMER_3 = 25,
    UNIT_TEST_TIMER_2 = 24,
    UNIT_TEST_TIMER_1 = 23,
    USB_ANTIOCH_INT_N_CHECK_TIMER = 22,
    USB_INT_N_ENABLE_TIMER = 21,
    USB_CD_DEBOUNCE_TIMER = 20,
    USB_POLL_TIMER = 19,
    USB_QUINCY_TIMER = 18,
    USB_SMART_CHARGER_TIMER = 17,
    USB_DISCONNECT_TIMER = 16,
    USB_RECONNECT_TIMER = 15,
    USB_SOFTCONNECT_TIMER = 14,
    USB_INVALID_STATE_TIMER = 13,
    CB_SERIAL_NOTIFY_TIMER = 12,
    DEBUG_SERIAL_SCAN_TIMER = 11,
    DEBUG_SERIAL_NOTIFY_TIMER = 10,
    BT_SERIAL_NOTIFY_TIMER = 9,
    BT_DTR_DEBOUNCE_TIMER = 8,
    SERIAL_NOTIFY_TIMER = 7,
    SERIAL_SCAN_TIMER = 6,
    DSR_TOGGLE_TIMER = 5,
    DTR_DEBOUNCE_TIMER = 4,
    SC_WAKEUP_TIMER = 3,
    RTC_TIMER = 2,
    VOIP_ESCREEN_TIMER = 1
} TimerName;
typedef DWORD TimerHandle;
typedef BYTE OsTimerStyle_t;
typedef DWORD TaskIndex_t;
typedef union {
    struct {
        TaskIndex_t Chain;
        void *Ptr;
    } Semaphore;
    struct {
        MESSAGE *OutMsg;
        DWORD *OutFlags;
        MESSAGE *CompMsg;
        DWORD CompMask;
    } Message;
    struct {
        TaskIndex_t Chain;
        DWORD *ValPtr;
        FlagOp Op;
    } Flag;
} BlockInfo_t;
typedef struct {
    DWORD *StackBottom;
    DWORD StackSize;
    MsgQ *MsgQHead;
    MsgQ *MsgQTail;
    DWORD Block;
    BlockInfo_t BlockInfo;
    DWORD ReturnValue;
    TimerHandle SemTimer;
} Task_t;
typedef struct {
    DWORD Size;
    struct {
        TaskIndex_t Task;
        DWORD Value;
    } Pairs;
} TaskSet_t;
typedef struct {
    TaskEntry_t Entry;
    DWORD Flags;
    TaskSet_t *StopSet;
} TaskInfo_t;
typedef Task_t TaskStruc;
typedef QWORD BigInt;
typedef DWORD RimTicks;
typedef struct {
    BigInt upTime;
} ThreadProfileData;
typedef struct {
    DWORD timesCalled;
    DWORD maxTimeAtOnce;
    QWORD totalTime;
} ProfilingData;
typedef enum {
    NUM_ROLLING_BUFS = 3,
    UTC_BUF = 2,
    SYSPROF_BUF = 1,
    BATTERY_BUF = 0
} RollingBufferType;
typedef struct {
    DWORD upTime;
    DWORD totalTimeStarved;
} IncrementalThreadProfileData;
typedef struct {
    DWORD absTimeTaskStarted;
} ThreadProfileInternal;
struct EntryHookTag {
    void *hook;
    struct EntryHookTag *next;
};
typedef struct EntryHookTag EntryHook;
struct ExitHookTag {
    void *hook;
    struct ExitHookTag *next;
};
typedef struct ExitHookTag ExitHook;
struct TaskReadyHookTag {
    void *hook;
    struct TaskReadyHookTag *next;
};
typedef struct TaskReadyHookTag TaskReadyHook;
typedef struct {
    EntryHook entryHook;
    ExitHook exitHook;
    TaskReadyHook taskReadyHook;
    BOOL isActive;
} HookSet;
typedef struct OpaqueMutex *Mutex_t;
typedef enum {
    MUTEXSTYLE_RECURSIVE = 1,
    MUTEXSTYLE_DEFAULT = 0
} MutexStyle_t;
typedef struct OpaqueSemaphore *Semaphore_t;
typedef struct {
    SWORD count;
    SWORD maxCount;
} SemImpl;
typedef struct {
    WORD state;
    WORD waiters;
    TASK owner;
    BYTE style;
    BYTE count;
} MutexImpl;
typedef enum {
    NUM_KERNEL_TYPES = 3,
    KERNELTYPE_TLS = 2,
    KERNELTYPE_MUTEX = 1,
    KERNELTYPE_SEMAPHORE = 0
} KernelType;
typedef struct {
    BYTE deviceType;
    BYTE networkType;
    BYTE networkBands;
    BYTE reserved1;
    union {
        DWORD PIN;
        BYTE reserved2[16];
    } deviceId;
    DWORD ESN;
    BYTE HSN[16];
    DWORD HWID;
    union {
        BYTE IMEI[15];
        BYTE IMEISV[16];
        BYTE reserved4[16];
    } networkId;
    BYTE SecureDevice;
    BYTE DeviceCapabilities;
    BYTE reserved3;
    BYTE SecureHardware;
    QWORD MEID;
} DEVICE_INFO;
typedef enum {
    HW_CAP_NUM_ENTRIES = 33,
    HW_CAP_BLOCK_COMPACT = 32,
    HW_CAP_TRACKBALL_OPTICAL = 31,
    HW_CAP_VCLICK = 30,
    HW_CAP_CAMERA_NO_FLASH = 29,
    HW_CAP_CAMERA_AF = 28,
    HW_CAP_ACCELEROMETER = 27,
    HW_CAP_TOUCHSCREEN = 26,
    HW_CAP_STYLUS = 25,
    HW_CAP_BATTERY_DOOR_DETECT = 24,
    HW_CAP_TRACKBALL_LED = 23,
    HW_CAP_WLAN = 22,
    HW_CAP_CAMERA = 21,
    HW_CAP_SDCARD_HOT_SWAPPABLE = 20,
    HW_CAP_SDCARD = 19,
    HW_CAP_TRACKBALL = 18,
    HW_CAP_OTA_UPDATE = 17,
    HW_CAP_LIGHT_SENSOR = 16,
    HW_CAP_HEADSET_DETECT = 15,
    HW_CAP_NETWORK_TIME = 14,
    HW_CAP_RTC_BACKUP_POWER = 13,
    HW_CAP_RF_AERO = 12,
    HW_CAP_TRICOLOUR_LED = 11,
    HW_CAP_RESERVED_1 = 10,
    HW_CAP_BUZZER = 9,
    HW_CAP_BLUETOOTH = 8,
    HW_CAP_LOUD_AUDIO = 7,
    HW_CAP_GPS = 6,
    HW_CAP_SMARTCARD_READER = 5,
    HW_CAP_REMOVABLE_BATTERY = 4,
    HW_CAP_BUILTIN_HEADSET = 3,
    HW_CAP_IRDA = 2,
    HW_CAP_USB = 1,
    HW_CAP_SERIAL = 0
} DEVICE_HARDWARE_CAPABILITY;
typedef enum {
    SW_CAP_NUM_ENTRIES = 32,
    SW_CAP_SDCARD_RAMDUMP = 31,
    SW_CAP_RTN = 30,
    SW_CAP_CMPTT_SW = 29,
    SW_CAP_MUTEX = 28,
    SW_CAP_ASSD = 27,
    SW_CAP_WORKERTASK = 26,
    SW_CAP_OPENGLES = 25,
    SW_CAP_CAMERA_RESUME_ON_CAPTURE = 24,
    SW_CAP_STARTUP_SCREEN = 23,
    SW_CAP_TTS = 22,
    SW_CAP_PTX = 21,
    SW_CAP_USB_MTP = 20,
    SW_CAP_DRM = 19,
    SW_CAP_OPEN_VG = 18,
    SW_CAP_MEID = 17,
    SW_CAP_DISPLAY_ROTATION = 16,
    SW_CAP_NAND_BLOCK_FS = 15,
    SW_CAP_MULTIBUTTON_HEADSET = 14,
    SW_CAP_RTSP = 13,
    SW_CAP_RECORDING = 12,
    SW_CAP_VAD = 11,
    SW_CAP_PERFMON = 10,
    SW_CAP_USB_MASS_STORAGE = 9,
    SW_CAP_MEDIA_PLAYER = 8,
    SW_CAP_VIDEO_STREAMING = 7,
    SW_CAP_MIDI = 6,
    SW_CAP_MASTER_VOLUME_API = 5,
    SW_CAP_NO_KEY_TONE = 4,
    SW_CAP_BLOCK_ERASE_ASYNC = 3,
    SW_CAP_AUDIO_STREAMING = 2,
    SW_CAP_STREAMING = 1,
    SW_CAP_POSIX_FS = 0
} DEVICE_SOFTWARE_CAPABILITY;
typedef enum {
    SECURITY_FEATURE_SDCARD_RAMDUMP_ENABLED = 6,
    SECURITY_FEATURE_SNAPSHOT_ENABLED = 5,
    SECURITY_FEATURE_SDCARD_LOGGING_ALLOWED = 4,
    SECURITY_FEATURE_NEVER_BEEN_SIGNED = 3,
    SECURITY_FEATURE_RTAS_STP_ENABLED = 2,
    SECURITY_FEATURE_RTAS_BUGDISP_ENABLED = 1
} DEVICE_SECURITY_FEATURE;
typedef struct {
    BYTE Localization[4];
    BYTE Keyboard[4];
    BYTE KeyboardVariant[4];
    BYTE InputLanguage[8];
    BYTE FutureUse[12];
} LOCALIZATION_INFO;
typedef struct {
    DWORD EndOfPhysicalRAM;
    DWORD StartOfPhysicalRAM;
    DWORD EndOfPhysicalIRAM;
    DWORD StartOfPhysicalIRAM;
    DWORD TotalFlashSize;
} DEVICE_HARDWARE_INFO;
typedef BYTE DEVICE_RANDOM_NUMBER;
typedef struct {
    DWORD version;
    DWORD manufacturerId;
    char manufacturerName[256];
    BOOL refurbished;
    BYTE padding[4];
    QWORD refurbishedDate;
} MANUFACTURER_INFO_TYPE;
typedef struct {
    void *currentSP;
    void *stackBase;
    DWORD stackSize;
} STACK_INFO;
typedef enum {
    JVM_STATE_NUM_ENTRIES = 4,
    JVM_STATE_DOING_FULL_RESET = 3,
    JVM_STATE_DOING_FAST_RESET = 2,
    JVM_STATE_JVMERROR = 1,
    JVM_STATE_BOOTING = 0
} JVM_STATE;
typedef enum {
    MAX_VERSION_FORMAT = 6,
    VER_BCD_16 = 5,
    VER_8_8_2_14 = 4,
    VER_8_16_8 = 3,
    VER_8_8_1_15 = 2,
    VER_16_16 = 1,
    VER_8_8_8_8 = 0
} VersionFormat;
typedef enum {
    MAX_VERSION_TYPE = 11,
    NVSIG_KEY_VERSION_TYPE = 10,
    STP_KEY_VERSION_TYPE = 9,
    BUGDISP_KEY_VERSION_TYPE = 8,
    BLOCKMAP_VERSION_TYPE = 7,
    WLAN_VERSION_TYPE = 6,
    USB_DRIVER_VERSION_TYPE = 5,
    STP_PROTOCOL_VERSION_TYPE = 4,
    FAT_VERSION_TYPE = 3,
    BLOCKFS_VERSION_TYPE = 2,
    OS_API_VERSION_TYPE = 1,
    NO_VERSION_TYPE = 0
} VersionType;
typedef struct {
    WORD Version;
    WORD SupportedBands;
} HWE_FREQ;
struct HW_VERSION_CLASS_NAME {
    BYTE hwClass;
    char *name;
};
typedef struct {
    BYTE Class;
    BYTE Version;
} HW_VERSION_TAG__BOOTROM;
typedef struct {
    BYTE Class;
    BYTE Flags;
    BYTE MinVersion;
    BYTE MaxVersion;
} HW_VERSION_TAG__OS;
typedef struct {
    DWORD version;
    VersionType type;
    VersionFormat format;
    BYTE padding;
} VersionInfo;
typedef DWORD DRIVERS;
typedef DWORD PROCESSOR;
typedef DWORD SUPPORT_OPTIONS;
typedef struct {
    DWORD MetricsVersion;
    DWORD MetricsSize;
    DWORD BootromVersion;
    DWORD HardwareID;
    char DeviceString[64];
    char BuildUserName[16];
    char BuildDate[16];
    char BuildTime[12];
    DWORD IsInsecureDevice;
    HWE_FREQ FrequencyMap;
    SUPPORT_OPTIONS OptionsSupported;
    DWORD LegacyEndOfFileSystem;
    DWORD HWVersionOffset;
    DWORD NumberHWVEntries;
    DWORD MemCfgTableOffset;
    DWORD MemCfgTableSize;
    DRIVERS Drivers;
    DWORD *LDRBlockAddr;
    DWORD BootromSize;
    DWORD ConfigMemoryVersion;
    PROCESSOR Processor;
    HW_VERSION_TAG__BOOTROM HWVersion[10];
    DWORD MemCfgTable[64];
} BootromMetricsStruct;
typedef enum {
    ON_DEMAND_OK = 0,
    ON_DEMAND_COMPRESSION_ERROR = -1,
    ON_DEMAND_NOT_FOUND = -2,
    ON_DEMAND_NOT_ENOUGH_MEM = -3,
    ON_DEMAND_READ_ERROR = -4
} OnDemandLdrStatus;
typedef struct {
    DWORD MetricsVersion;
    DWORD MetricsSize;
    DWORD KernelVersion;
    DWORD HardwareID;
    char DeviceString[64];
    char BuildUserName[16];
    char BuildDate[16];
    char BuildTime[12];
} KernelMetricsDataStruct;
typedef struct {
    DWORD MetricsVersion;
    DWORD Length;
    DWORD *LoadBase;
    DWORD *LoadEnd;
    DWORD *RAMEnd;
    DWORD *IRAMEnd;
    void *EntryPoint;
    DWORD AppVersion;
    char BuildUserName[16];
    char BuildDate[12];
    char BuildTime[12];
    DWORD *APICheckSum;
    DWORD *RAMBase;
    DWORD *IRAMBase;
    DWORD *JumpTable_OneOrTwoArgs;
    DWORD *JumpTable_MoreArgs;
    DWORD AppFSVersion;
    DWORD AppLinkVersion;
    DWORD AppType;
    DWORD AppFSSize;
} AppMetricsDataStruct;
typedef struct {
    DWORD Version;
    DWORD Length;
    DWORD *LoadBasePtr;
    DWORD *LoadEndPtr;
    DWORD *RAMEnd;
    char BuildUserName[16];
    char BuildDate[12];
    char BuildTime[12];
    char DeviceString[64];
    DWORD HardwareID;
    DWORD OSVersion;
    DWORD *IRAMEnd;
    DWORD *AppStart;
    DWORD APICheckSum;
    DWORD *JumpTable_OneOrTwoArgs;
    DWORD *JumpTable_MoreArgs;
    HWE_FREQ FrequencyMap;
    DWORD MagicCookie;
    DWORD HWVersionOffset;
    DWORD NumberHWVEntries;
    KernelMetricsDataStruct *KernelMetrics;
    DWORD CompanionBinaryVersion;
    DWORD PackageVersionOffset;
    DWORD PackageVersionLength;
    DWORD FileSystemVersion;
    DWORD *ConfigurableParameterTable;
    BYTE *SVNptr;
    DWORD FatFSVersion;
    DWORD RadioCodeLinked;
    DWORD AppLinkVersion;
    DWORD *LDRBlockAddr;
    DWORD StpProtocolVersion;
    DWORD *DSPExtROMAddr;
    DWORD DSPExtROMSize;
    DWORD *OSExtendedAddr;
    DWORD VersionInfoTableOffset;
    DWORD VersionInfoTableLength;
    DWORD *RAMStart;
    HW_VERSION_TAG__OS HWVersion[20];
    char PackageVersionString[32];
    VersionInfo VersionInfoTable[11];
} MetricsDataStruct;
typedef struct {
    DWORD version;
    DWORD OSVersion;
    char BuildUserName[16];
    char BuildDate[12];
    char BuildTime[12];
} NvCalibrationOSInfo;
typedef struct {
    DWORD Version;
    DWORD Length;
    DWORD OSVersion;
    KernelMetricsDataStruct *KernelMetrics;
    BYTE *LoadBasePtr;
    BYTE *LoadEndPtr;
    DWORD *overlayTablePtr;
    BYTE *ExternalROMBasePtr;
    BYTE *ExternalROMEndPtr;
    DWORD *LDRBlockAddr;
    DWORD RadioCodeLinked;
} StrippedMetricsDataStruct;
typedef struct {
    WORD version;
    WORD length;
} GpioShadowRegsType;
typedef struct {
    WORD version;
    BYTE cookie1;
    BYTE cookie2;
    BYTE maxBadBlocks;
    BYTE numBadBlocks;
    WORD badBlocks[29];
} brBadBlockRecord;
typedef struct {
    DWORD cookie;
    WORD version;
    WORD length;
    DWORD doubleReset;
    DWORD flashTest;
    DWORD watchdogReset;
    GpioShadowRegsType GpioShadowRegs;
    DWORD numBlocksFound;
    DWORD MapBlocks[8];
    DWORD flags;
    DWORD brInitTime;
    DWORD brCryptoVerifyTime;
    DWORD badBlockRecordOffset;
    DWORD badBlockRecordSize;
    BOOL enableSecureErases;
    brBadBlockRecord badBlockRecord;
} brPersistData;
enum _MemCfgTableEntryType {
    MCT_ANY = 256,
    MCT_LAST = 256,
    MCT_EMPTY_ENTRY = 255,
    MCT_RAM_CHIP = 35,
    MCT_FAT_FS_NAND = 34,
    MCT_EFS_APPS_PARTITION = 33,
    MCT_EFS_MODEM_PARTITION = 32,
    MCT_INSTALLER_NAND = 31,
    MCT_OS_NV_NAND = 30,
    MCT_FLASH_CHIP_NAND = 29,
    MCT_FS_FIXED_NAND = 28,
    MCT_OS_FIXED_NAND = 27,
    MCT_FS_DYNAMIC_NAND = 26,
    MCT_OS_DYNAMIC_NAND = 25,
    MCT_BOOTROM_NAND = 24,
    MCT_BOOTROM_START = 23,
    MCT_FS_FIXED_MINSTART = 22,
    MCT_FS_DYNAMIC_MINSTART = 21,
    MCT_BSN_REGION = 20,
    MCT_OS_EXTENDED = 19,
    MCT_DSP_OS = 18,
    MCT_INSTALLER = 16,
    MCT_BUGDISP = 15,
    MCT_APPSTORE = 14,
    MCT_FAT_FS = 13,
    MCT_BRANDING = 12,
    MCT_HWV_ENTRY = 11,
    MCT_PASSWORD_ADDRESS = 10,
    MCT_CRC = 9,
    MCT_FS_DYNAMIC = 8,
    MCT_FS_FIXED = 7,
    MCT_QC_NV = 6,
    MCT_OS_NV = 5,
    MCT_MAPPING = 4,
    MCT_FLASH_CHIP = 3,
    MCT_OS_DYNAMIC = 2,
    MCT_OS_FIXED = 1,
    MCT_ERASED_ENTRY = 0
};
typedef enum _MemCfgTableEntryType MemCfgTableEntryType;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD ShortData;
    DWORD Data;
} MemCfgTableEntry;
typedef struct {
    DWORD MagicNumber;
    DWORD TableVersion;
} MemCfgTableHeader;
typedef struct {
    MemCfgTableHeader header;
    MemCfgTableEntry entry;
} MemCfgTable;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD StartAddress;
    DWORD EndAddress;
} MCT_OS_FIXED_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD StartAddress;
    DWORD EndAddress;
} MCT_BRANDING_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD StartAddress;
    DWORD EndAddress;
} MCT_INSTALLER_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD StartAddress;
    DWORD EndAddress;
} MCT_DSP_OS_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD StartAddress;
    DWORD EndAddress;
} MCT_OS_EXTENDED_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD StartAddress;
    DWORD EndAddress;
} MCT_BSN_REGION_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD StartAddress;
    DWORD EndAddress;
} MCT_BOOTROM_START_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD FirstBlockNum;
    DWORD LastBlockNum;
} MCT_OS_FIXED_NAND_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD FirstBlockNum;
    DWORD LastBlockNum;
} MCT_FS_FIXED_NAND_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD FirstBlockNum;
    DWORD LastBlockNum;
} MCT_INSTALLER_NAND_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD FirstBlockNum;
    DWORD LastBlockNum;
} MCT_BOOTROM_NAND_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD FirstBlockNum;
    DWORD LastBlockNum;
} MCT_OS_NV_NAND_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD FirstBlockNum;
    DWORD LastBlockNum;
} MCT_EFS_PARTITION_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD FirstBlockNum;
    DWORD LastBlockNum;
} MCT_FAT_FS_NAND_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD NumberOfBanks;
    DWORD StartAddress;
    DWORD EndAddress;
    DWORD SectorSize;
} MCT_FAT_FS_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD StartAddress;
    DWORD EndAddress;
    DWORD SectorSize;
} MCT_APPSTORE_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD StartAddress;
    DWORD EndAddress;
    DWORD SectorSize;
} MCT_BUGDISP_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD StartAddress;
} MCT_OS_DYNAMIC_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD FirstBlockNum;
} MCT_OS_DYNAMIC_NAND_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    BYTE ChipNumber;
    BYTE SubChipNumber;
    DWORD StartAddress;
    DWORD EndAddress;
} MCT_FLASH_CHIP_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD BankSize;
    DWORD StartAddress;
    DWORD EndAddress;
} MCT_RAM_CHIP_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    BYTE ChipNumber;
    BYTE SubChipNumber;
    DWORD FirstBlockNum;
    DWORD LastBlockNum;
} MCT_FLASH_CHIP_NAND_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD StartAddress;
    DWORD EndAddress;
    DWORD MappedStartAddress;
} MCT_MAPPING_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD SectorSize;
    DWORD StartAddress;
    DWORD EndAddress;
    DWORD VirtualSectorSize;
} MCT_FS_FIXED_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD SectorSize;
    DWORD StartAddress;
    DWORD EndAddress;
    DWORD VirtualSectorSize;
} MCT_OS_NV_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD SectorSize;
    DWORD StartAddress;
    DWORD EndAddress;
    DWORD VirtualSectorSize;
} MCT_QC_NV_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD SectorSize;
    DWORD EndAddress;
    DWORD VirtualSectorSize;
} MCT_FS_DYNAMIC_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD SectorSize;
    DWORD EndAddress;
    DWORD VirtualSectorSize;
    DWORD MinStartAddress;
} MCT_FS_DYNAMIC_MINSTART_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD SectorSize;
    DWORD StartAddress;
    DWORD EndAddress;
    DWORD VirtualSectorSize;
    DWORD MinStartAddress;
} MCT_FS_FIXED_MINSTART_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD LastBlockNum;
} MCT_FS_DYNAMIC_NAND_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD CRC32;
} MCT_CRC_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
    DWORD PasswordSectorAddress;
} MCT_PASSWORD_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    BYTE Class;
    BYTE Version;
} MCT_HWV_ENTRY_TYPE;
typedef struct {
    BYTE MCTType;
    BYTE Size;
    WORD Unused;
} MCT_EMPTY_TYPE;
typedef union {
    MCT_MAPPING_TYPE map;
    MCT_QC_NV_TYPE qcnv;
    MCT_CRC_TYPE crc;
    MCT_PASSWORD_TYPE pass;
    MCT_BRANDING_TYPE brand;
    MCT_FAT_FS_TYPE fat;
    MCT_APPSTORE_TYPE app;
    MCT_BUGDISP_TYPE bug;
    MCT_HWV_ENTRY_TYPE hwv;
    MCT_OS_EXTENDED_TYPE osext;
    MCT_BSN_REGION_TYPE bsnReg;
    MCT_OS_FIXED_TYPE osf;
    MCT_OS_DYNAMIC_TYPE osd;
    MCT_FLASH_CHIP_TYPE fc;
    MCT_RAM_CHIP_TYPE rc;
    MCT_FS_FIXED_TYPE fsf;
    MCT_FS_FIXED_MINSTART_TYPE fsfms;
    MCT_FS_DYNAMIC_TYPE fsd;
    MCT_FS_DYNAMIC_MINSTART_TYPE fsdms;
    MCT_OS_NV_TYPE osnv;
    MCT_INSTALLER_TYPE inst;
    MCT_OS_FIXED_NAND_TYPE osfn;
    MCT_FS_FIXED_NAND_TYPE fsfn;
    MCT_OS_DYNAMIC_NAND_TYPE osdn;
    MCT_FS_DYNAMIC_NAND_TYPE fsdn;
    MCT_FLASH_CHIP_NAND_TYPE fcn;
    MCT_OS_NV_NAND_TYPE osnvn;
    MCT_INSTALLER_NAND_TYPE instn;
    MCT_FAT_FS_NAND_TYPE fatn;
    MCT_EFS_PARTITION_TYPE efs;
} MCT_ALL_TYPES;
typedef struct {
    DWORD startTime;
    DWORD iterations;
    DWORD totalTicks;
    DWORD minTicks;
    DWORD maxTicks;
    DWORD lastTicks;
    DWORD ticksPerSec;
    WORD coreId;
} CodeProfileTime;
typedef struct {
    DWORD startTime;
    DWORD iterations;
    DWORD totalTicks;
    DWORD bytes;
    DWORD totalBytes;
    DWORD ticksPerSec;
    WORD coreId;
} CodeProfileThroughput;
struct ListElementTag {
    struct ListElementTag *next;
    struct ListElementTag *prev;
    void *object;
};
typedef struct ListElementTag ListElement;
struct LinkedListTag {
    ListElement *first;
    ListElement *last;
    DWORD count;
};
typedef struct LinkedListTag LinkedList;
typedef enum {
    OSPROF_ALL_CODEBLOCKS = 15,
    SDCARD_READ_SPEED_PROFILE = 14,
    SDCARD_WRITE_SPEED_PROFILE = 13,
    NAND_READ_PROFILE = 12,
    NAND_ERASE_PROFILE = 11,
    NAND_WRITE_PROFILE = 10,
    GNHP_BLK_POINTERFROMHANDLE = 9,
    GNHP_BLK_RELINQUISHOWNERSHIP = 8,
    GNHP_BLK_ACQUIREOWNERSHIP = 7,
    GNHP_BLK_FREE = 6,
    GNHP_BLK_REALLOC = 5,
    GNHP_BLK_MALLOC = 4,
    FLASH_READ_PROFILE = 3,
    FLASH_ERASE_PROFILE = 2,
    FLASH_WRITE_PROFILE = 1,
    OSPROF_NVRAM_EMPTY_CODEBLOCK = 0
} ProfileBlock_e;
typedef enum {
    OSPROF_BLOCK_NAME_STRING = 16,
    OSPROF_TIME_BASED_MASK = 8,
    OSPROF_MEMORY_NOT_ALLOCATED_MASK = 4,
    OSPROF_NVFLAG_ENABLE_MASK = 2,
    OSPROF_CODE_BLOCK_ACTIVE_MASK = 1
} ProfileFlags_t;
typedef enum {
    OSPROF_ERROR_CODEBLOCK_INVALID = 13,
    OSPROF_ERROR_NOT_ENABLED = 12,
    OSPROF_ERROR_MEMORY_DEALLOCATE = 11,
    OSPROF_ERROR_CODEBLOCK_RESET = 10,
    OSPROF_ERROR_EMPTY = 9,
    OSPROF_ERROR_ALLOCATE_MEMORY = 8,
    OSPROF_ERROR_PROFILING_NOT_INIT = 7,
    OSPROF_ERROR_CODEBLOCK_NOT_FOUND = 6,
    OSPROF_ERROR_ALREADY_ENABLED = 5,
    OSPROF_ERROR_EXCEEDED_LIMIT = 4,
    OSPROF_ERROR_ALREADY_EXIST = 3,
    OSPROF_ERROR_EMPTY_NAME = 2,
    OSPROF_ERROR_NAME_TOO_LONG = 1,
    OSPROF_SUCCESS = 0
} ProfileReturnCode_e;
typedef enum {
    OSPROF_TIME_CORE_ID = 5,
    OSPROF_TIME_DATA_TICKS_LAST = 4,
    OSPROF_TIME_DATA_TICKS_MAX = 3,
    OSPROF_TIME_DATA_TICKS_MIN = 2,
    OSPROF_TIME_DATA_TICKS_TOTAL = 1,
    OSPROF_TIME_DATA_ITER = 0
} ProfileTimeData_e;
typedef enum {
    OSPROF_THRU_CORE_ID = 4,
    OSPROF_THRU_BYTES_TOTAL = 3,
    OSPROF_THRU_BYTES_CUR = 2,
    OSPROF_THRU_TICKS_TOTAL = 1,
    OSPROF_THRU_DATA_ITER = 0
} ProfileThruData_e;
typedef struct {
    union {
        ProfileBlock_e blockEnum;
        char blockName[30];
    } BlockName;
    BOOL isString;
} ProfileBlockName;
typedef struct {
    ProfileBlockName block;
    QWORD timeStamp;
    union {
        void *codeProfileStaticPtr;
        void **codeProfileAllocSysPtr;
    } codeProfilePtr;
    ProfileFlags_t flags;
    ProfileReturnCode_e returnFlag;
} ProfileBlockInfo;
typedef struct {
    ProfileBlockName block;
    QWORD timeStamp;
    DWORD data[6];
    BOOL blockType;
} OsProfileNvRamData;
typedef enum {
    CORE_CLK_624MHZ = 624000000,
    CORE_CLK_532MHZ = 532000000,
    CORE_CLK_514MHZ = 514000000,
    CORE_CLK_416MHZ = 416000000,
    CORE_CLK_399MHZ = 399000000,
    CORE_CLK_385_5MHZ = 385500000,
    CORE_CLK_312MHZ = 312000000,
    CORE_CLK_250MHZ = 250000000,
    CORE_CLK_208MHZ = 208000000,
    CORE_CLK_156MHZ = 156000000,
    CORE_CLK_104MHZ = 104000000,
    CORE_CLK_69MHZ = 69000000,
    CORE_CLK_60MHZ = 60000000,
    CORE_CLK_52MHZ = 52000000,
    CORE_CLK_34MHZ = 34000000,
    CORE_CLK_NONE = 0
} CoreFrequence;
typedef DWORD ResetSoftOvr;
typedef enum {
    RESET_TYPE_HARD = 2,
    RESET_TYPE_SOFT = 1,
    RESET_TYPE_UNKNOWN = 0
} ResetType;
typedef enum {
    RESET_POWER_KEPT_UNEXPECTED = 3,
    RESET_POWER_KEPT = 2,
    RESET_POWER_LOST = 1,
    RESET_POWER_UNKNOWN = 0
} ResetPower;
typedef enum {
    PM_NUM_INTERVALS = 5,
    PM_BATTERY_CHECK_INTERVAL = 4,
    PM_USER_INTERVAL = 3,
    PM_UPTIME_INTERVAL = 2,
    PM_BATTERY_UPDATE_INTERVAL = 1
} PmProfileInterval;
typedef enum {
    PM_NUM_RATIOS = 15,
    PM_FREQ_DSP_2 = 14,
    PM_FREQ_DSP_1 = 13,
    PM_DSP_L1_RATIO = 12,
    PM_WIFI_ACTIVE_RATIO = 11,
    PM_CLK13M_REQ_RATIO = 10,
    PM_FREQ_APPS_2 = 9,
    PM_FREQ_APPS_1 = 8,
    PM_DSP_L2_RATIO = 7,
    PM_WIFI_RATIO = 6,
    PM_GPS_RATIO = 5,
    PM_AUDIO_RATIO = 4,
    PM_POTENTIAL_L2_RATIO = 3,
    PM_L2_RATIO = 2,
    PM_L1_RATIO = 1,
    PM_LCD_RATIO = 0
} PmProfileRatio;
typedef enum {
    PM_NUM_DYNAMIC_FIELDS = 12,
    PM_DDR_OVERTEMP = 11,
    PM_CHARGE_RATE = 10,
    PM_WLAN_TX_POWER = 9,
    PM_BT_TX_POWER = 8,
    PM_RADIO_TX_POWER = 7,
    PM_GPS_TEMPERATURE = 6,
    PM_PA_TEMPERATURE = 5,
    PM_GPS_LONGITUDE = 4,
    PM_GPS_LATITUDE = 3,
    PM_NETWORK_MODE = 2,
    PM_NETWORK_SERVICE = 1,
    PM_ACTIVE_WAF = 0
} PmProfileDynamicField;
typedef enum {
    PM_NUM_CORES = 2,
    PM_DSP_CORE = 1,
    PM_APPS_CORE = 0
} PmProfileCore;
typedef enum {
    PM_CORE_STAGE_ALL = 3,
    PM_CORE_STAGE_L2D2 = 2,
    PM_CORE_STAGE_C1L1 = 1,
    PM_CORE_STAGE_C0 = 0
} PmProfileCoreStage;
typedef struct {
    QWORD startTime;
    QWORD sleepTicks[15];
    BYTE lastIntervalRatio[15];
} PmProfileIntervalData;
typedef struct {
    QWORD lastSleepTime;
} PmProfileRatioData;
typedef struct {
    BYTE SignersName[32];
    DWORD SignerID;
    DWORD SignatureLength;
    BYTE Signature[128];
    DWORD SignatureStructLength;
    DWORD SignatureStructVersion;
    DWORD MagicCookie;
} OSSignatureStruct;
typedef struct {
    OSSignatureStruct Signature;
    DWORD CRC32;
} OSTrailerStruct;
typedef struct {
    DWORD Version;
    DWORD NumberOfBlocks;
    DWORD BlockSize;
    DWORD OptimalWriteSize;
    DWORD MinimumWriteSize;
} BlockInfoStruct;
typedef enum {
    BFS_ERASE_RESUME_ADDR_ERROR = 9,
    BFS_ERASE_SUSPENDED = 8,
    BFS_BAD_OS_END = 7,
    BFS_ERASE_FAIL = 6,
    BFS_ERASE_NOT_ALIGNED = 5,
    BFS_ERASE_OUT_OF_FS = 4,
    BFS_WRITE_FAIL = 3,
    BFS_WRITE_OUT_OF_BLOCK = 2,
    BFS_WRITE_OUT_OF_FS = 1,
    BFS_OK = 0
} BFS_STATUS;
typedef unsigned char DisplayId_t;
typedef enum {
    TVOUT_DISPLAY = -3,
    AUXILLARY_DISPLAY = -2,
    PRIMARY_DISPLAY = -1
} DisplayType;
typedef enum {
    DEFAULT_IMAGE_ID = 129,
    ALL_IMAGES_ID = 128,
    NUM_THEMEABLE_IMAGES = 9,
    CUSTOM_ICON_IMAGE_ID = 8,
    TX_RACH_ICON_IMAGE_ID = 7,
    CAP_ICON_IMAGE_ID = 6,
    ALT_ICON_IMAGE_ID = 5,
    NUM_ICON_IMAGE_ID = 4,
    TXRX_ICON_IMAGE_ID = 3,
    RX_ICON_IMAGE_ID = 2,
    TX_ICON_IMAGE_ID = 1,
    HOURGLASS_IMAGE_ID = 0
} ThemeableImageId;
typedef enum {
    LCD_SLEEP_MODE = 2,
    PARTIAL_COLOUR_MODE = 1,
    PARTIAL_DISPLAY_MODE = 0
} PowerSavingModeType;
typedef enum {
    OVL_ICON_BUILTIN_NUM = 4,
    OVL_ICON_BUILTIN_CHARGER = 3,
    OVL_ICON_BUILTIN_BLUETOOTH = 2,
    OVL_ICON_BUILTIN_BATTERY_LEVEL = 1,
    OVL_ICON_BUILTIN_UNKNOWN = 0
} OvlIconBuiltIn;
typedef enum {
    OVL_ICON_BUILTIN_ERR_NUM = 3,
    OVL_ICON_BUILTIN_ERROR = 2,
    OVL_ICON_BUILTIN_NOT_SUPPORTED = 1,
    OVL_ICON_BUILTIN_SUCCESS = 0
} OvlIconBuiltInErr;
typedef struct {
    WORD LcdType;
    WORD contrastRange;
    WORD width;
    WORD height;
    WORD depth;
    WORD reserved;
    DWORD frontBuffer;
    DWORD widthInMicrons;
    DWORD heightInMicrons;
} LcdConfig;
typedef struct {
    BOOL partialDisplaySupported;
    BOOL topLineFixed;
    BYTE verticalResolution;
    BYTE horizontalResolution;
    BYTE outOfAreaColourDepth;
    BYTE reserved;
} PartialDisplayFeatures;
typedef struct {
    BOOL partialColourSupported;
    BYTE partialColourDepth;
    BYTE reserved;
    BYTE reserved2;
    BYTE reserved3;
} PartialColourFeatures;
typedef struct {
    PartialDisplayFeatures partialDisplayFeatures;
    PartialColourFeatures partialColourFeatures;
} LcdPowerSavingFeatures;
typedef enum {
    ORIENTATION_ERROR = 4,
    WEST = 3,
    SOUTH = 2,
    EAST = 1,
    NORTH = 0
} displayOrientation;
typedef enum {
    DISPLAY_CTRL_ENABLE_ALL = 3,
    DISPLAY_CTRL_ENABLE_APPS = 2,
    DISPLAY_CTRL_ENABLE_OS = 1,
    DISPLAY_CTRL_NONE = 0
} displayControl;
typedef enum {
    NUM_ICON_POSITIONS = 2,
    UPPER_LEFT = 1,
    UPPER_RIGHT = 0
} IconPosition;
typedef enum {
    NUM_ICON_TYPES = 2,
    RADIOSTAT = 1,
    KEYSTAT = 0
} IconType;
typedef struct {
    BYTE DataIsValid;
    BYTE LocksActivated;
    BYTE LocksEnabled;
    BYTE NumNetworks;
    BYTE NumNetworkSubsets;
    BYTE NumServiceProviders;
    BYTE NumCorporates;
    BYTE NumSims;
    BYTE Password[80];
    BYTE Retries[5];
    BYTE NumHomeNetworks;
    WORD MepLength;
    BYTE LockData[3000];
} GsmMepData;
typedef struct {
    BYTE dummyPlaceHolderSoCompilerWontComplain;
} CdmaMepData;
typedef union {
    GsmMepData gsmMepData;
    CdmaMepData cdmaMepData;
} RimMepData;
typedef struct {
    WORD mcc;
    WORD mnc;
} Ncg;
typedef struct {
    Ncg networkId;
    BYTE networkSubsetId;
    BYTE _padding;
    WORD _padding2;
} Nscg;
typedef struct {
    Ncg networkId;
    BYTE serviceProviderId;
    BYTE _padding;
    WORD _padding2;
} Spcg;
typedef struct {
    Ncg networkId;
    BYTE serviceProviderId;
    BYTE corporateId;
    WORD _padding;
} Ccg;
typedef struct {
    Ncg networkId;
    BYTE networkSubsetId;
    BYTE _padding;
    WORD _padding2;
    BYTE simId[4];
} Pcg;
typedef enum {
    NVRAM_BITFLAGS_OVERRIDE_JVM_BLOCK = 27,
    NVRAM_BITFLAGS_RAM_DUMP_ENABLED = 26,
    NVRAM_BITFLAGS_BATTERY_CHARGING_SCREEN_ENABLED = 25,
    NVRAM_BITFLAGS_IS_QC_NV_INVALID = 24,
    NVRAM_BITFLAGS_REQUIRE_POWER_KEY_HOLD_5_SECS = 23,
    NVRAM_BITFLAGS_FORCE_POWER_OFF_AFTER_BATTERY_INSERTION = 22,
    NVRAM_BITFLAGS_GPS_EE_CLEAR = 21,
    NVRAM_BITFLAGS_GPS_EGYPT_LEGAL = 20,
    NVRAM_BITFLAGS_GPS_USE_ALT_FREQ = 19,
    NVRAM_BITFLAGS_GPS_DISABLED = 18,
    NVRAM_BITFLAGS_LOG_MEMTYPE_SDCARD_NOT_MMC = 17,
    NVRAM_BITFLAGS_RUN_NAND_FLASH_TEST = 16,
    NVRAM_BITFLAGS_IN_PRODUCTION = 15,
    NVRAM_BITFLAGS_EFS_CACHE_FLUSH_INCOMPLETE = 14,
    NVRAM_BITFLAGS_PATRIOT_FLASHSTRAP_VER7 = 13,
    NVRAM_BITFLAGS_BLOCKMAP_SECURE_ERASE = 12,
    NVRAM_BITFLAGS_RAM_CORRUPTED = 11,
    NVRAM_BITFLAGS_AUTO_MOVE_SD_LOGS_ENABLED = 10,
    NVRAM_BITFLAGS_AUTO_SAVE_SD_RESET_LOG_ENABLED = 9,
    NVRAM_BITFLAGS_SOC_NO_CATFAIL_ON_SOCKET_FAILURE = 8,
    NVRAM_BITFLAGS_FORCE_STP_NO_RTAS = 7,
    NVRAM_BITFLAGS_FORCE_BUGDISP_NO_RTAS = 6,
    NVRAM_BITFLAGS_FORCE_BUGDISP_ENCRYPT = 5,
    NVRAM_BITFLAGS_GPS_PUSH_FREQ_AIDING = 4,
    NVRAM_BITFLAGS_SD_BUGDISP_LOG_ENABLED = 3,
    NVRAM_BITFLAGS_GPS_FIRMWARE_UPDATE_DISABLED = 2,
    NVRAM_BITFLAGS_NO_RADIO_CAL_SECTOR = 1,
    NVRAM_BITFLAGS_LOUD_AUDIO_ENABLED = 0
} NvramBitFlag;
typedef enum {
    NVRAM_BITFLAGS_FORCE_STP_NO_RTAS_MFI_USED = 3,
    NVRAM_BITFLAGS_FORCE_STP_NO_RTAS_MFI = 2,
    NVRAM_PERSISTENT_BITFLAGS_REFURBISHED = 1,
    NVRAM_PERSISTENT_BITFLAGS_EDW_WIPE_MEMORY = 0
} NvramPersistentBitFlag;
typedef WORD DeviceProfileTable;
typedef BYTE LEGACY_DEVICE_RANDOM_NUMBER;
typedef struct {
    SWORD sScale256;
    SWORD sDcOffset;
    SWORD sBacklightAdjust;
    SWORD sTempAdjust256;
    SWORD sFuture1;
    SWORD sFuture2;
    BYTE cType;
    BYTE cFuture0;
    BYTE cFuture1;
    BYTE cFuture2;
} LcdCalibration;
typedef struct {
    DWORD MagicKey;
    DWORD Version;
    DWORD Length;
    DWORD CRC;
    DWORD PIN;
    LcdCalibration LcdCal;
    DWORD JvmStart;
    DWORD CalSectorChecksum;
    DWORD CalTestStatus;
    LOCALIZATION_INFO LocalInfo;
    RimMepData MepData;
    LEGACY_DEVICE_RANDOM_NUMBER DevRandomNumber;
    DeviceProfileTable DevProfileTable;
    BYTE IdenRadioBsn[16];
    BYTE IdenIMEI[16];
} OSStoreStruct;
typedef struct {
    unsigned int magicCookie;
    unsigned int length;
    unsigned int crc;
    unsigned short vendorId;
    unsigned short slack;
    unsigned int version;
    BYTE reserved[8];
} BRANDING_BLOB_HEADER;
typedef struct {
    DWORD OSMagicKey;
    BRANDING_BLOB_HEADER JVMStuff;
} BRANDING_SECTOR;
typedef struct {
    DWORD MagicKey;
    DWORD Data[0];
} BrandingStruct;
typedef BYTE PartNumber;
typedef union {
    PartNumber OldFormat[16];
    BYTE NewFormat[512];
    DWORD Signature;
} PNEntry;
typedef struct {
    DWORD OldNumEntries;
    PNEntry Entry;
    DWORD NumEntries;
    WORD Index;
    WORD padding;
} DEVICE_SW_PART_LIST;
typedef enum {
    NUM_SD_TYPES = 3,
    SDIO_CARD = 2,
    MMC_CARD = 1,
    SDMEM_CARD = 0
} SDCardType;
typedef enum {
    NUM_SD_PORTS = 1,
    SD_PORT0 = 0
} SDPort;
typedef enum {
    NUM_SD_BUSWIDTHS = 3,
    SD_BUSWIDTH_8BIT = 2,
    SD_BUSWIDTH_4BIT = 1,
    SD_BUSWIDTH_1BIT = 0
} SDBusWidth;
typedef enum {
    NUM_MMC_BOOT_PARTITIONS = 3,
    MMC_BOOT_PARTITION1 = 2,
    MMC_BOOT_PARTITION0 = 1,
    SDMMC_USER_PARTITION = 0
} SDMMCPartitionType;
struct CIDRegisterType {
    BYTE MID;
    WORD OID;
    BYTE PNM[5];
    BYTE PRV;
    DWORD PSN;
    WORD MDT;
};
typedef struct CIDRegisterType CIDRegister;
struct CSDRegisterType {
    BYTE CSD_STRUCTURE;
    BYTE SPEC_VERSION;
    BYTE TAAC;
    BYTE NSAC;
    BYTE TRAN_SPEED;
    BOOL READ_BL_PARTIAL;
    BOOL WRITE_BLK_MISALIGN;
    BOOL READ_BLK_MISALIGN;
    BOOL DSR_IMP;
    DWORD C_SIZE;
    WORD CCC;
    BYTE READ_BL_LEN;
    BYTE VDD_R_CURR_MIN;
    BYTE VDD_R_CURR_MAX;
    BYTE VDD_W_CURR_MIN;
    BYTE VDD_W_CURR_MAX;
    BYTE C_SIZE_MULT;
    BOOL ERASE_BLK_EN;
    BOOL WP_GRP_ENABLE;
    BYTE ERASE_SECTOR_SIZE;
    BYTE WP_GRP_SIZE;
    BYTE R2W_FACTOR;
    BYTE WRITE_BL_LEN;
    BOOL WRITE_BL_PARTIAL;
    BOOL FILE_FORMAT_GRP;
    BOOL COPY;
    BOOL PERM_WRITE_PROTECT;
    BOOL TMP_WRITE_PROTECT;
    BYTE FILE_FORMAT;
    BYTE ERASE_GRP_SIZE;
    BYTE ERASE_GRP_MULT;
};
typedef struct CSDRegisterType CSDRegister;
struct SCRRegisterType {
    enum SdSpecType SD_SPEC_VERSION_1_0;
    enum SdSpecType SD_SPEC_VERSION_1_1;
    enum SdSpecType SD_SPEC_VERSION_2_0;
    enum SdSecurityType SD_NO_SECURITY;
    enum SdSecurityType SD_SECURITY_1_0;
    enum SdSecurityType SD_SECURITY_2_0;
    DWORD ManufacturerData;
    BYTE SD_BUS_WIDTHS;
    BYTE DATA_STAT_AFTER_ERASE;
};
typedef struct SCRRegisterType SCRRegister;
struct SDIODescriptorType {
    BOOL async;
    BOOL useDMA;
    DWORD addr;
    BYTE *data;
    DWORD length;
    BYTE func;
    BYTE mode;
    BYTE opcode;
    BYTE cmd;
    BOOL write;
    void *CompletionFunction;
    void *CompletionData;
};
typedef struct SDIODescriptorType SDIODescriptor;
typedef DWORD SDMMC_FEATURES;
typedef enum {
    RIM_NUM_AUDIO_LOG_EVENTS = 59,
    AudioLoggingModeUnsupported = 58,
    AudioLoggingModeVoicePttHandsfree = 57,
    AudioLoggingModeVideoPlaybackBluetoothA2DPMono = 56,
    AudioLoggingModeVideoPlaybackBluetoothA2DPStereo = 55,
    AudioLoggingModeVideoPlaybackHeadphones = 54,
    AudioLoggingModeVideoPlaybackHeadset = 53,
    AudioLoggingModeVideoPlaybackHandsfree = 52,
    AudioLoggingModeVideoPlaybackHandset = 51,
    AudioLoggingHookswitchPressButton5 = 50,
    AudioLoggingHookswitchPressButton4 = 49,
    AudioLoggingHookswitchPressButton3 = 48,
    AudioLoggingHookswitchPressButton2 = 47,
    AudioLoggingHookswitchPressButton1 = 46,
    AudioLoggingHookswitchPressButton0 = 45,
    AudioLoggingModeVoiceRecordingHeadphones = 44,
    AudioLoggingModeVoiceRecordingBluetoothAudioProcessing = 43,
    AudioLoggingModeVoiceRecordingBluetooth = 42,
    AudioLoggingModeVoiceRecordingHeadset = 41,
    AudioLoggingModeVoiceRecordingHandsfree = 40,
    AudioLoggingModeVoiceRecordingHandset = 39,
    AudioLoggingModeVoiceHeadphones = 38,
    AudioLoggingModeVADHeadphones = 37,
    AudioLoggingModeMmHeadphones = 36,
    AudioLoggingModeMmBluetoothA2DPStereo = 35,
    AudioLoggingModeMmBluetoothA2DPMono = 34,
    AudioLoggingModeMmHandset = 33,
    AudioLoggingModeMmHeadset = 32,
    AudioLoggingModeMmHandsfree = 31,
    AudioLoggingModeAlertHeadphones = 30,
    AudioLoggingModeCPBluetoothHandsfree = 29,
    AudioLoggingModeCPBluetoothHandset = 28,
    AudioLoggingModeCPHeadsetHandsfree = 27,
    AudioLoggingModeCPHeadsetHandset = 26,
    AudioLoggingModeCPHandsetBluetooth = 25,
    AudioLoggingModeCPHandsetHeadset = 24,
    AudioLoggingModeAlertBluetoothA2DPStereo = 23,
    AudioLoggingModeAlertBluetoothA2DPMono = 22,
    AudioLoggingModeVADBluetoothAudioProcessing = 21,
    AudioLoggingModeVADBluetooth = 20,
    AudioLoggingModeVADHandsfree = 19,
    AudioLoggingModeVADHeadset = 18,
    AudioLoggingModeTtyIntHear = 17,
    AudioLoggingModeTtyIntTalk = 16,
    AudioLoggingModeTtyIntFull = 15,
    AudioLoggingModeTtyExtHear = 14,
    AudioLoggingModeTtyExtTalk = 13,
    AudioLoggingModeTtyExtFull = 12,
    AudioLoggingModeVoiceTelecoil = 11,
    AudioLoggingModeVoiceBluetoothAudioProcessing = 10,
    AudioLoggingModeVoiceBluetooth = 9,
    AudioLoggingModeVoiceHandset = 8,
    AudioLoggingModeVoiceHeadset = 7,
    AudioLoggingModeVoiceHandsfree = 6,
    AudioLoggingModeAlertBluetoothHandsfree = 5,
    AudioLoggingModeAlertHeadsetHandsfree = 4,
    AudioLoggingModeAlertHandset = 3,
    AudioLoggingModeAlertHeadset = 2,
    AudioLoggingModeAlertHandsfree = 1,
    AudioLoggingHSinserts = 0
} logEvents_t;
typedef struct {
    DWORD rangeStart;
    DWORD rangeEnd;
    DWORD osTypeBitMask;
} OSRangeAndType;
typedef struct {
    DWORD osTypes;
    DWORD hwIDOverride;
} HwIdOverrideType;
typedef WORD CmdCode;
typedef WORD CmdLength;
typedef WORD CmdChecksum;
enum CalSignalTypeTag {
    SIG_RIM_CAL_UNSUPPORTED_COMMAND_CNF = 65535,
    SIG_RIM_CAL_UNSUPPORTED_COMMAND_REQ = 65534,
    STP_MFG_PERSISTENT_DATA_CNF = 65489,
    STP_MFG_PERSISTENT_DATA_REQ = 65488,
    STP_HW_ID_OVERRIDE_CNF = 65475,
    STP_HW_ID_OVERRIDE_REQ = 65474,
    STP_GET_MAX_BRANDING_SIZE_CNF = 65441,
    STP_GET_MAX_BRANDING_SIZE_REQ = 65440,
    STP_IN_PRODUCTION_FLAG_CNF = 65465,
    STP_IN_PRODUCTION_FLAG_REQ = 65464,
    STP_REFURBISHED_FLAG_CNF = 65463,
    STP_REFURBISHED_FLAG_REQ = 65462,
    STP_NVRAM_COND_WRITE_PROTECT_CNF = 65449,
    STP_NVRAM_COND_WRITE_PROTECT_REQ = 65448,
    STP_SMARTCARD_TEST_CNF = 65437,
    STP_SMARTCARD_TEST_REQ = 65436,
    SIG_RIM_GET_REQUIRED_SIGNATURES_CNF = 65435,
    SIG_RIM_GET_REQUIRED_SIGNATURES_REQ = 65434,
    SIG_RIM_WIPE_NVRAM_SIGNATURES_CNF = 65433,
    SIG_RIM_WIPE_NVRAM_SIGNATURES_REQ = 65432,
    SIG_RIM_VERIFY_NVRAM_SIGNATURE_CNF = 65431,
    SIG_RIM_VERIFY_NVRAM_SIGNATURE_REQ = 65430,
    SIG_RIM_STORE_NVRAM_SIGNATURE_CNF = 65429,
    SIG_RIM_STORE_NVRAM_SIGNATURE_REQ = 65428,
    SIG_RIM_REQUEST_NVRAM_SIGNATURE_CNF = 65427,
    SIG_RIM_REQUEST_NVRAM_SIGNATURE_REQ = 65426,
    SIG_RIM_GET_STP_COMMAND_VERSION_CNF = 65425,
    SIG_RIM_GET_STP_COMMAND_VERSION_REQ = 65424,
    STP_BUGDISP_CNF = 65423,
    STP_BUGDISP_REQ = 65422,
    SIG_RIM_DELETE_AUDIO_TRIMMING_CNF = 65415,
    SIG_RIM_DELETE_AUDIO_TRIMMING_REQ = 65414,
    SIG_RIM_GET_AUDIO_TRIMMING_CNF = 65413,
    SIG_RIM_GET_AUDIO_TRIMMING_REQ = 65412,
    SIG_RIM_SET_AUDIO_TRIMMING_CNF = 65411,
    SIG_RIM_SET_AUDIO_TRIMMING_REQ = 65410,
    SIG_RIM_GET_INTERACTIVE_TEST_RESULTS_CNF = 65407,
    SIG_RIM_GET_INTERACTIVE_TEST_RESULTS_REQ = 65406,
    SIG_RIM_GET_METRICS_DATA_CNF = 65399,
    SIG_RIM_GET_METRICS_DATA_REQ = 65398,
    SIG_RIM_AUDIO_MUTE_HEADSET_CNF = 65397,
    SIG_RIM_AUDIO_MUTE_HEADSET_REQ = 65396,
    SIG_RIM_CAL_SET_DEFAULT_RADIO_CNF = 65395,
    SIG_RIM_CAL_SET_DEFAULT_RADIO_REQ = 65394,
    SIG_RIM_SVP_ACCESS_CNF = 65393,
    SIG_RIM_SVP_ACCESS_REQ = 65392,
    SIG_RIM_AUDIO_DELETE_AVP_CNF = 65391,
    SIG_RIM_AUDIO_DELETE_AVP_REQ = 65390,
    SIG_RIM_AUDIO_ACCESS_AVP_CNF = 65389,
    SIG_RIM_AUDIO_ACCESS_AVP_REQ = 65388,
    SIG_RIM_CAL_GET_NO_BAT_N_CNF = 65383,
    SIG_RIM_CAL_GET_NO_BAT_N_REQ = 65382,
    SIG_RIM_CAL_NVRAM_STORE_CRYPTOBATT_CHALLENGE_CNF = 65381,
    SIG_RIM_CAL_NVRAM_STORE_CRYPTOBATT_CHALLENGE_REQ = 65380,
    SIG_RIM_CAL_NVRAM_STORE_OS_ID_CNF = 65379,
    SIG_RIM_CAL_NVRAM_STORE_OS_ID_REQ = 65378,
    SIG_RIM_WP_VERIFY_BYTE_CNF = 65375,
    SIG_RIM_WP_VERIFY_BYTE_REQ = 65374,
    SIG_RIM_CAL_GET_DEVICE_FEATURE_CNF = 65373,
    SIG_RIM_CAL_GET_DEVICE_FEATURE_REQ = 65372,
    SIG_RIM_CAL_NVRAM_DELETE_CAL_CNF = 65371,
    SIG_RIM_CAL_NVRAM_DELETE_CAL_REQ = 65370,
    SIG_RIM_CAL_HWV_TABLE_ACCESS_CNF = 65369,
    SIG_RIM_CAL_HWV_TABLE_ACCESS_REQ = 65368,
    SIG_RIM_CAL_ACCESS_TEST_OP_NAME_CNF = 65367,
    SIG_RIM_CAL_ACCESS_TEST_OP_NAME_REQ = 65366,
    SIG_RIM_CAL_SET_RS232_CNF = 65365,
    SIG_RIM_CAL_SET_RS232_REQ = 65364,
    SIG_RIM_CAL_SET_CUSTOM_INFO_CNF = 65363,
    SIG_RIM_CAL_SET_CUSTOM_INFO_REQ = 65362,
    SIG_RIM_CAL_GET_CUSTOM_INFO_CNF = 65361,
    SIG_RIM_CAL_GET_CUSTOM_INFO_REQ = 65360,
    SIG_RIM_CAL_ECHO_STRING_CNF = 65359,
    SIG_RIM_CAL_ECHO_STRING_REQ = 65358,
    SIG_RIM_CAL_GET_HW_VERSION_CNF = 65357,
    SIG_RIM_CAL_GET_HW_VERSION_REQ = 65356,
    SIG_RIM_CAL_ACCESS_DEVICE_MODE_CNF = 65347,
    SIG_RIM_CAL_ACCESS_DEVICE_MODE_REQ = 65346,
    SIG_RIM_CAL_SUPPORTED_FEATURE_CNF = 65345,
    SIG_RIM_CAL_SUPPORTED_FEATURE_REQ = 65344,
    STP_READ_ADC_VALUE_CNF = 65343,
    STP_READ_ADC_VALUE_REQ = 65342,
    SIG_RIM_CAL_ACCESS_DEVICE_PROFILE_CNF = 65341,
    SIG_RIM_CAL_ACCESS_DEVICE_PROFILE_REQ = 65340,
    SIG_RIM_CAL_ACCESS_SW_PART_LIST_CNF = 65337,
    SIG_RIM_CAL_ACCESS_SW_PART_LIST_REQ = 65336,
    SIG_RIM_CAL_ACCESS_DEVICE_RANDOM_NUMBER_CNF = 65335,
    SIG_RIM_CAL_ACCESS_DEVICE_RANDOM_NUMBER_REQ = 65334,
    SIG_RIM_CAL_RADIO_ON_OFF_CNF = 65333,
    SIG_RIM_CAL_RADIO_ON_OFF_REQ = 65332,
    SIG_RIM_CAL_ACCESS_LOCALIZATION_INFO_CNF = 65331,
    SIG_RIM_CAL_ACCESS_LOCALIZATION_INFO_REQ = 65330,
    SIG_RIM_CAL_SET_MEP_DATA_CNF = 65327,
    SIG_RIM_CAL_SET_MEP_DATA_REQ = 65326,
    SIG_RIM_CAL_GET_MEP_DATA_CNF = 65325,
    SIG_RIM_CAL_GET_MEP_DATA_REQ = 65324,
    SIG_RIM_CAL_ENABLE_POWER_SAVING_CNF = 65315,
    SIG_RIM_CAL_ENABLE_POWER_SAVING_REQ = 65314,
    SIG_RIM_CAL_GET_COVERAGE_INFO_CNF = 65313,
    SIG_RIM_CAL_GET_COVERAGE_INFO_REQ = 65312,
    SIG_RIM_CAL_ACCESS_EXT_CAL_TEST_STATUS_CNF = 65311,
    SIG_RIM_CAL_ACCESS_EXT_CAL_TEST_STATUS_REQ = 65310,
    SIG_RIM_CAL_ACCESS_JVM_START_STATUS_CNF = 65309,
    SIG_RIM_CAL_ACCESS_JVM_START_STATUS_REQ = 65308,
    SIG_RIM_CAL_SET_SERIAL_MODE_CNF = 65305,
    SIG_RIM_CAL_SET_SERIAL_MODE_REQ = 65304,
    SIG_RIM_CAL_GET_PROTOCOL_VERSION_CNF = 65303,
    SIG_RIM_CAL_GET_PROTOCOL_VERSION_REQ = 65302,
    SIG_RIM_CAL_RESET_DEVICE_CNF = 65301,
    SIG_RIM_CAL_RESET_DEVICE_REQ = 65300,
    SIG_RIM_CAL_ACCESS_AUDIO_VOLUME_CNF = 65299,
    SIG_RIM_CAL_ACCESS_AUDIO_VOLUME_REQ = 65298,
    SIG_RIM_CAL_STOP_CALL_CNF = 65297,
    SIG_RIM_CAL_STOP_CALL_REQ = 65296,
    SIG_RIM_CAL_START_CALL_CNF = 65293,
    SIG_RIM_CAL_START_CALL_REQ = 65292,
    SIG_RIM_CAL_INIT_CNF = 65289,
    SIG_RIM_CAL_INIT_REQ = 65288,
    STP_ACCESS_ID_EXTERNAL_CNF = 65171,
    STP_ACCESS_ID_EXTERNAL_REQ = 65170,
    SIG_RIM_FT_VERIFY_JTAG_DISCONNECTED_CNF = 65163,
    SIG_RIM_FT_VERIFY_JTAG_DISCONNECTED_REQ = 65162,
    STP_DC_VERIFY_MEMORY_CNF = 65155,
    STP_DC_VERIFY_MEMORY_REQ = 65154,
    SIG_RIM_DC_ACCESS_ID_CNF = 65153,
    SIG_RIM_DC_ACCESS_ID_REQ = 65152,
    SIG_RIM_FT_GET_JVM_REPORTED_STATE_CNF = 65129,
    SIG_RIM_FT_GET_JVM_REPORTED_STATE_REQ = 65128,
    SIG_RIM_FT_VERIFY_ALL_COMMANDS_CNF = 65121,
    SIG_RIM_FT_VERIFY_ALL_COMMANDS_REQ = 65120,
    SIG_RIM_FT_INTERAC_TEST_SEL_CNF = 65111,
    SIG_RIM_FT_INTERAC_TEST_SEL_REQ = 65110,
    SIG_RIM_FT_MFG_ERROR_LIST_CNF = 65109,
    SIG_RIM_FT_MFG_ERROR_LIST_REQ = 65108,
    SIG_RIM_FT_GET_BATTERY_STATUS_CNF = 65107,
    SIG_RIM_FT_GET_BATTERY_STATUS_REQ = 65106,
    SIG_RIM_FT_POWER_OFF_CNF = 65105,
    SIG_RIM_FT_POWER_OFF_REQ = 65104,
    SIG_RIM_FT_LCD_AUTO_DETECT_CNF = 65095,
    SIG_RIM_FT_LCD_AUTO_DETECT_REQ = 65094,
    SIG_RIM_FT_GET_UTC_CNF = 65085,
    SIG_RIM_FT_GET_UTC_REQ = 65084,
    SIG_RIM_FT_SET_UTC_CNF = 65083,
    SIG_RIM_FT_SET_UTC_REQ = 65082,
    SIG_RIM_FT_GET_BATTERY_ID_CNF = 65069,
    SIG_RIM_FT_GET_BATTERY_ID_REQ = 65068,
    SIG_RIM_FT_SET_AUDIO_PATH_CNF = 65065,
    SIG_RIM_FT_SET_AUDIO_PATH_REQ = 65064,
    SIG_RIM_FT_INIT_CONSOLE_CNF = 65063,
    SIG_RIM_FT_INIT_CONSOLE_REQ = 65062,
    SIG_RIM_FT_GET_TEMPERATURE_CNF = 65061,
    SIG_RIM_FT_GET_TEMPERATURE_REQ = 65060,
    SIG_RIM_FT_GET_BATTERY_LEVEL_CNF = 65059,
    SIG_RIM_FT_GET_BATTERY_LEVEL_REQ = 65058,
    SIG_RIM_FT_GET_HEADSET_STATUS_CNF = 65053,
    SIG_RIM_FT_GET_HEADSET_STATUS_REQ = 65052,
    SIG_RIM_FT_GET_SIM_STATUS_CNF = 65051,
    SIG_RIM_FT_GET_SIM_STATUS_REQ = 65050,
    SIG_RIM_FT_GET_KEYS_CNF = 65049,
    SIG_RIM_FT_GET_KEYS_REQ = 65048,
    STP_SENSOR_GET_VALUE_CNF = 65043,
    STP_SENSOR_GET_VALUE_REQ = 65042,
    SIG_RIM_FT_SET_LED_CNF = 65041,
    SIG_RIM_FT_SET_LED_REQ = 65040,
    SIG_RIM_CAL_WIPE_CAL_DATA_CNF = 64803,
    SIG_RIM_CAL_WIPE_CAL_DATA_REQ = 64802,
    SIG_RIM_CAL_SET_BAND_MODE_CNF = 64801,
    SIG_RIM_CAL_SET_BAND_MODE_REQ = 64800,
    SIG_RIM_CAL_SET_RAMP_SCALE_CNF = 64799,
    SIG_RIM_CAL_SET_RAMP_SCALE_REQ = 64798,
    SIG_RIM_FT_NVRAM_BIT_FLAG_CNF = 64797,
    SIG_RIM_FT_NVRAM_BIT_FLAG_REQ = 64796,
    SIG_RIM_FT2_READ_FROM_BUFFER_CNF = 62487,
    SIG_RIM_FT2_READ_FROM_BUFFER_REQ = 62486,
    SIG_RIM_FT2_WRITE_TO_BUFFER_CNF = 62485,
    SIG_RIM_FT2_WRITE_TO_BUFFER_REQ = 62484,
    SIG_RIM_FT2_MEMCPY_CNF = 62483,
    SIG_RIM_FT2_MEMCPY_REQ = 62482,
    SIG_RIM_FT2_MEMSET_CNF = 62481,
    SIG_RIM_FT2_MEMSET_REQ = 62480,
    SIG_RIM_FT2_FREE_CNF = 62479,
    SIG_RIM_FT2_FREE_REQ = 62478,
    SIG_RIM_FT2_MALLOC_CNF = 62477,
    SIG_RIM_FT2_MALLOC_REQ = 62476,
    STP_USB_GET_FEATURES_CNF = 57875,
    STP_USB_GET_FEATURES_REQ = 57874,
    STP_USB_SOFT_RECONNECT_CNF = 57873,
    STP_USB_SOFT_RECONNECT_REQ = 57872
};
typedef enum CalSignalTypeTag CalSignalType;
struct StpSerialBusTestReqTag {
    DWORD deviceType;
    DWORD testType;
    DWORD inputBuf[100];
};
typedef struct StpSerialBusTestReqTag StpSerialBusTestReq;
struct StpSerialBusTestCnfTag {
    DWORD success;
    DWORD dataValid;
    DWORD outBuf[100];
};
typedef struct StpSerialBusTestCnfTag StpSerialBusTestCnf;
struct RimCalSupportedFeatureReqTag {
    DWORD featureCode;
};
typedef struct RimCalSupportedFeatureReqTag RimCalSupportedFeatureReq;
struct RimCalSupportedFeatureCnfTag {
    DWORD featureCode;
    BYTE supported;
    BYTE _padding[3];
};
typedef struct RimCalSupportedFeatureCnfTag RimCalSupportedFeatureCnf;
struct RimCalChangeBaudRateReqTag {
    DWORD baudRate;
};
typedef struct RimCalChangeBaudRateReqTag RimCalChangeBaudRateReq;
struct RimCalGetTaskIdCnfTag {
    WORD taskId;
    WORD _padding;
};
typedef struct RimCalGetTaskIdCnfTag RimCalGetTaskIdCnf;
enum VolumeModeTag {
    DTMF_VOLUME = 1,
    SPEECH_VOLUME = 0
};
typedef enum VolumeModeTag VolumeMode;
struct RimCalAccessAudioVolumeReqTag {
    BYTE volume;
    BYTE mode;
    BYTE set;
    BYTE _padding;
};
typedef struct RimCalAccessAudioVolumeReqTag RimCalAccessAudioVolumeReq;
struct RimCalSetAudioVolumeCnfTag {
    BYTE volume;
    BYTE mode;
    BYTE success;
    BYTE _padding;
};
typedef struct RimCalSetAudioVolumeCnfTag RimCalAccessAudioVolumeCnf;
struct RimCalProtocolVersionCnfTag {
    DWORD version;
};
typedef struct RimCalProtocolVersionCnfTag RimCalGetProtocolVersionCnf;
struct RimCalSetSerialModeReqTag {
    BYTE mode;
    BYTE _padding[3];
};
typedef struct RimCalSetSerialModeReqTag RimCalSetSerialModeReq;
struct CalEmptySignalTag {
    DWORD _padding;
};
typedef struct CalEmptySignalTag CalEmptySignal;
struct RimSTPDefaultSignalTag {
    DWORD value;
};
typedef struct RimSTPDefaultSignalTag DefaultSignal;
struct RimSTPDefaultSignalInt16Tag {
    WORD value1;
    WORD value2;
};
typedef struct RimSTPDefaultSignalInt16Tag DefaultSignalInt16;
struct RimSTPDefaultSignalInt8Tag {
    BYTE value1;
    BYTE value2;
    BYTE value3;
    BYTE value4;
};
typedef struct RimSTPDefaultSignalInt8Tag DefaultSignalInt8;
struct RimSTPDefaultSignalSignedTag {
    SDWORD value;
};
typedef struct RimSTPDefaultSignalSignedTag DefaultSignalSigned;
struct RimSTPDefaultSignalSignedInt16Tag {
    SWORD value1;
    SWORD value2;
};
typedef struct RimSTPDefaultSignalSignedInt16Tag DefaultSignalSignedInt16;
struct RimSTPDefaultSignalSignedInt8Tag {
    SBYTE value1;
    SBYTE value2;
    SBYTE value3;
    SBYTE value4;
};
typedef struct RimSTPDefaultSignalSignedInt8Tag DefaultSignalSignedInt8;
struct SuccessCnfSignalTag {
    BYTE success;
    BYTE _padding;
    WORD _padding2;
};
typedef struct SuccessCnfSignalTag SuccessCnfSignal;
struct RimSTPResultCnfSignalTag {
    DWORD result;
};
typedef struct RimSTPResultCnfSignalTag ResultCnfSignal;
struct RimSTPBoolFeatureSignalTag {
    BYTE set_get;
    BYTE argument;
    BYTE success;
    BYTE padding;
};
typedef struct RimSTPBoolFeatureSignalTag RimSTPBoolFeatureReq;
struct RimGetStpCommandVersionReqTag {
    DWORD commandId;
};
typedef struct RimGetStpCommandVersionReqTag RimGetStpCommandVersionReq;
struct RimGetStpCommandVersionCnfTag {
    DWORD version;
    BYTE versionValid;
    BYTE _padding[3];
};
typedef struct RimGetStpCommandVersionCnfTag RimGetStpCommandVersionCnf;
struct RimCalAccessJvmStartStatusReqTag {
    BYTE start;
    BYTE set;
    BYTE resetOnCablePull;
    BYTE _padding;
};
typedef struct RimCalAccessJvmStartStatusReqTag RimCalAccessJvmStartStatusReq;
struct RimCalAccessJvmStartStatusCnfTag {
    BYTE start;
    BYTE success;
    WORD _padding2;
};
typedef struct RimCalAccessJvmStartStatusCnfTag RimCalAccessJvmStartStatusCnf;
struct RimCalAccessCalTestStatusReqTag {
    BYTE set;
    BYTE type;
    BYTE completed;
    BYTE _padding;
};
typedef struct RimCalAccessCalTestStatusReqTag RimCalAccessCalTestStatusReq;
struct RimCalAccessCalTestStatusCnfTag {
    BYTE type;
    BYTE completed;
    BYTE success;
    BYTE _padding;
};
typedef struct RimCalAccessCalTestStatusCnfTag RimCalAccessCalTestStatusCnf;
struct RimCalAccessCalSectorChecksumReqTag {
    BYTE set;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimCalAccessCalSectorChecksumReqTag RimCalAccessCalSectorChecksumReq;
struct RimCalAccessCalSectorChecksumCnfTag {
    DWORD checksum;
    BYTE success;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimCalAccessCalSectorChecksumCnfTag RimCalAccessCalSectorChecksumCnf;
struct RimCalAccessExtCalTestStatusReqTag {
    BYTE set;
    BYTE type;
    WORD stationID;
    BYTE passed;
    BYTE _padding;
};
typedef struct RimCalAccessExtCalTestStatusReqTag RimCalAccessExtCalTestStatusReq;
struct RimCalAccessExtCalTestStatusCnfTag {
    BYTE success;
    BYTE type;
    WORD stationID;
    BYTE passed;
    BYTE _padding;
};
typedef struct RimCalAccessExtCalTestStatusCnfTag RimCalAccessExtCalTestStatusCnf;
struct RimAccessInteractiveTestStatusReqTag {
    BYTE erase;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimAccessInteractiveTestStatusReqTag RimAccessInteractiveTestStatusReq;
struct RimAccessInteractiveTestStatusCnfTag {
    BYTE success;
    BYTE passed;
    WORD numAttempts;
    DWORD results;
};
typedef struct RimAccessInteractiveTestStatusCnfTag RimAccessInteractiveTestStatusCnf;
struct RimCalAccessTestOpNameReqTag {
    BYTE set;
    BYTE type;
    BYTE opName[10];
};
typedef struct RimCalAccessTestOpNameReqTag RimCalAccessTestOpNameReq;
struct RimCalAccessTestOpNameCnfTag {
    BYTE success;
    BYTE type;
    BYTE opName[10];
};
typedef struct RimCalAccessTestOpNameCnfTag RimCalAccessTestOpNameCnf;
struct RimSTPHardwareIdOverrideReqTag {
    BYTE set;
    BYTE _padding[3];
    DWORD osTypes;
    DWORD hwIDOverride;
};
typedef struct RimSTPHardwareIdOverrideReqTag STPHardwareIdOverrideReq;
struct RimSTPHardwareIdOverrideCnfTag {
    BYTE recordValid;
    BYTE _padding[3];
    DWORD osTypes;
    DWORD hwIDOverride;
};
typedef struct RimSTPHardwareIdOverrideCnfTag STPHardwareIdOverrideCnf;
struct StatusRecordTag {
    BYTE opName[10];
    WORD stationID;
};
typedef struct StatusRecordTag StatusRecord;
struct CalTestStatusTag {
    DWORD obsolete_CalTestStatus;
    StatusRecord record[30];
};
typedef struct CalTestStatusTag CalTestStatus;
struct RimFtInteracTestSelReqTag {
    WORD set;
    WORD currTestTypes[4];
};
typedef struct RimFtInteracTestSelReqTag RimFtInteracTestSelReq;
struct RimFtInteracTestSelCnfTag {
    WORD success;
    WORD currTestTypes[4];
};
typedef struct RimFtInteracTestSelCnfTag RimFtInteracTestSelCnf;
struct RimFtStubSTPReqTag {
    BYTE buffer[3000];
    DWORD size;
};
typedef struct RimFtStubSTPReqTag RimFtStubSTPReq;
struct RimFtStubSTPCnfTag {
    BYTE buffer[3000];
    DWORD size;
    WORD success;
    BYTE _padding[2];
};
typedef struct RimFtStubSTPCnfTag RimFtStubSTPCnf;
struct RimSTPLCDDriverReqTag {
    BYTE displayId;
    BYTE padding[3];
};
typedef struct RimSTPLCDDriverReqTag RimSTPLCDDriverReq;
struct RimSTPLCDDriverCnfTag {
    BYTE oldLcdId;
    BYTE success;
    BYTE svpType;
    BYTE padding;
    DWORD rimLcdId;
};
typedef struct RimSTPLCDDriverCnfTag RimSTPLCDDriverCnf;
struct RimCalGetMepDataCnfTag {
    BYTE success;
    BYTE _padding;
    WORD _padding2;
    RimMepData mepData;
};
typedef struct RimCalGetMepDataCnfTag RimCalGetMepDataCnf;
struct RimCalSetMepDataReqTag {
    RimMepData mepData;
};
typedef struct RimCalSetMepDataReqTag RimCalSetMepDataReq;
struct RimCalAccessLocalizationInfoReqTag {
    BYTE set;
    BYTE _padding;
    WORD _padding2;
    LOCALIZATION_INFO localInfo;
};
typedef struct RimCalAccessLocalizationInfoReqTag RimCalAccessLocalizationInfoReq;
struct RimCalAccessLocalizationInfoCnfTag {
    BYTE success;
    BYTE _padding;
    WORD _padding2;
    LOCALIZATION_INFO localInfo;
};
typedef struct RimCalAccessLocalizationInfoCnfTag RimCalAccessLocalizationInfoCnf;
struct RimCalDeactivateMepLockReqTag {
    BYTE mepLock;
    BYTE commandRef;
    WORD _padding;
    BYTE password[16];
};
typedef struct RimCalDeactivateMepLockReqTag RimCalDeactivateMepLockReq;
struct RimCalDeactivateMepLockCnfTag {
    DWORD status;
    BYTE mepStatus[5];
    BYTE pwRetries[5];
    WORD _padding;
};
typedef struct RimCalDeactivateMepLockCnfTag RimCalDeactivateMepLockCnf;
struct RimCalRadioOnOffReqTag {
    BYTE on;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimCalRadioOnOffReqTag RimCalRadioOnOffReq;
struct RimCalInitReqTag {
    BYTE mode;
    BYTE radio;
    BYTE Padding[2];
};
typedef struct RimCalInitReqTag RimCalInitReq;
typedef enum {
    RADIO_CMD_CERBERUS = 2,
    RADIO_CMD_ORPHEUS = 1,
    RADIO_CMD_ALL = 0
} RimRadioCmdEnum;
struct RimCalDeviceRandomNumberReqTag {
    BYTE set;
    BYTE _padding[3];
    DEVICE_RANDOM_NUMBER randomNumber;
};
typedef struct RimCalDeviceRandomNumberReqTag RimCalAccessDeviceRandomNumberReq;
struct RimCalAccessDeviceRandomNumberCnfTag {
    BYTE success;
    BYTE _padding[3];
    DEVICE_RANDOM_NUMBER randomNumber;
};
typedef struct RimCalAccessDeviceRandomNumberCnfTag RimCalAccessDeviceRandomNumberCnf;
enum SwPartListCommandTag {
    REQUEST_VERSION = 5,
    REMOVE_PART_NUMBER = 4,
    INSERT_PART_NUMBER = 3,
    ERASE_PART_LIST = 2,
    WRITE_PART_LIST = 1,
    READ_PART_LIST = 0
};
typedef enum SwPartListCommandTag SwPartListCommand;
struct RimCalAccessSwPartListReqTag {
    BYTE command;
    BYTE _padding[3];
    DEVICE_SW_PART_LIST swPartList;
};
typedef struct RimCalAccessSwPartListReqTag RimCalAccessSwPartListReq;
struct RimCalAccessSwPartListCnfTag {
    BYTE success;
    BYTE _padding[3];
    DEVICE_SW_PART_LIST swPartList;
};
typedef struct RimCalAccessSwPartListCnfTag RimCalAccessSwPartListCnf;
struct RimCalAccessBrandingInfoReqTag {
    BYTE set;
    BYTE chunkCount;
    BYTE chunkTotal;
    BYTE _padding;
    BYTE brandingInfo[0];
};
typedef struct RimCalAccessBrandingInfoReqTag RimCalAccessBrandingInfoReq;
struct RimCalAccessBrandingInfoCnfTag {
    BYTE success;
    BYTE _padding[3];
    BYTE brandingInfo[0];
};
typedef struct RimCalAccessBrandingInfoCnfTag RimCalAccessBrandingInfoCnf;
enum STPGenericNvRamCommandTag {
    GET_DATA_SIZE = 2,
    WRITE_DATA = 1,
    READ_DATA = 0
};
typedef enum STPGenericNvRamCommandTag STPGenericNvRamCommand;
struct STPGenericNvRamDataReqTag {
    BYTE command;
    BYTE packetCount;
    BYTE packetTotal;
    BYTE _padding;
    BYTE packetData[3072];
};
typedef struct STPGenericNvRamDataReqTag STPGenericNvRamDataReq;
struct STPGenericNvRamDataCnfTag {
    BYTE success;
    BYTE packetCount;
    BYTE _padding[2];
    DWORD dataSize;
    BYTE packetData[3072];
};
typedef struct STPGenericNvRamDataCnfTag STPGenericNvRamDataCnf;
struct RimCalAccessOMADMInfoReqTag {
    BYTE set;
    BYTE _padding[3];
    DWORD length;
    BYTE OMADMInfo[128];
};
typedef struct RimCalAccessOMADMInfoReqTag RimCalAccessOMADMInfoReq;
struct RimCalAccessOMADMInfoCnfTag {
    BYTE success;
    BYTE _padding[3];
    DWORD recordLength;
    BYTE OMADMInfo[128];
};
typedef struct RimCalAccessOMADMInfoCnfTag RimCalAccessOMADMInfoCnf;
struct RimCalReadAccelZeroGRawDataTag {
    BYTE success;
    BYTE _padding;
    SWORD raw[3];
};
typedef struct RimCalReadAccelZeroGRawDataTag RimCalReadAccelZeroGRawData;
struct RimAccessNotSupportedOSListReqTag {
    BYTE set;
    BYTE _padding[3];
    OSRangeAndType notSupportedOS[10];
};
typedef struct RimAccessNotSupportedOSListReqTag RimAccessNotSupportedOSListReq;
struct RimAccessNotSupportedOSListCnfTag {
    BYTE success;
    BYTE _padding[3];
    OSRangeAndType notSupportedOS[10];
};
typedef struct RimAccessNotSupportedOSListCnfTag RimAccessNotSupportedOSListCnf;
enum DeviceProfileCommandTag {
    SEARCH_DEVICE_PROFILE = 2,
    SET_DEVICE_PROFILE = 1,
    GET_DEVICE_PROFILE = 0
};
typedef enum DeviceProfileCommandTag DeviceProfileCommand;
struct RimCalAccessDeviceReqTag {
    BYTE command;
    BYTE searchBits;
    WORD searchMask;
    WORD deviceProfile[64];
};
typedef struct RimCalAccessDeviceReqTag RimCalAccessDeviceProfileReq;
struct RimCalAccessDeviceProfileCnfTag {
    BYTE success;
    BYTE searchBits;
    WORD searchResult;
    WORD deviceProfile[64];
};
typedef struct RimCalAccessDeviceProfileCnfTag RimCalAccessDeviceProfileCnf;
typedef enum {
    POWER_ICON_OFF = 0
} PowerSavingMode;
struct RimCalEnablePowerSavingReqTag {
    BYTE mode;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimCalEnablePowerSavingReqTag RimCalEnablePowerSavingReq;
struct RimCalSelectNetworkReqTag {
    BYTE manualMode;
    BYTE _padding;
    BYTE _padding2[2];
    WORD mnc;
    WORD mcc;
};
typedef struct RimCalSelectNetworkReqTag RimCalSelectNetworkReq;
struct RimCalSelectNetworkCnfTag {
    WORD mnc;
    WORD mcc;
};
typedef struct RimCalSelectNetworkCnfTag RimCalSelectNetworkCnf;
enum DeviceModeTag {
    DEVELOPER_MODE = 1,
    PRODUCTION_MODE = 0
};
typedef enum DeviceModeTag DeviceMode;
struct RimCalAccessDeviceModeReqTag {
    BYTE set;
    BYTE mode;
    BYTE _padding[2];
};
typedef struct RimCalAccessDeviceModeReqTag RimCalAccessDeviceModeReq;
struct RimCalAccessDeviceModeCnfTag {
    BYTE success;
    BYTE mode;
    BYTE _padding[2];
};
typedef struct RimCalAccessDeviceModeCnfTag RimCalAccessDeviceModeCnf;
enum ChargingRateTag {
    CHARGING_1350mA = 12,
    CHARGING_1500mA = 11,
    CHARGING_USB_LO = 10,
    CHARGING_USB_HI = 9,
    CHARGING_CHRG_LO = 8,
    CHARGING_CHRG_HI = 7,
    CHARGING_455mA = 6,
    CHARGING_353mA = 5,
    CHARGING_102mA = 4,
    CHARGING_750mA = 3,
    CHARGING_450mA = 2,
    CHARGING_85mA = 1,
    CHARGING_DEFAULT = 0
};
typedef enum ChargingRateTag ChargingRate;
enum SetChargingStatusTag {
    SETCHARGING_UNSUPPORTED_RATE = 2,
    SETCHARGING_FAILED = 1,
    SETCHARGING_SUCCESS = 0
};
typedef enum SetChargingStatusTag SetChargingStatus;
struct RimCalSetChargingReqTag {
    BYTE on;
    BYTE rate;
    BYTE _padding[2];
};
typedef struct RimCalSetChargingReqTag RimCalSetChargingReq;
struct RimCalSetChargingCnfTag {
    BYTE status;
    BYTE _padding[3];
};
typedef struct RimCalSetChargingCnfTag RimCalSetChargingCnf;
enum ChargingSourceTag {
    CHARGING_SOURCE_CONTACTS = 2,
    CHARGING_SOURCE_USB = 1,
    CHARGING_SOURCE_NONE = 0
};
typedef enum ChargingSourceTag ChargingSource;
struct RimCalGetChargingSourceCnfTag {
    BYTE source;
    BYTE _padding[3];
};
typedef struct RimCalGetChargingSourceCnfTag RimCalGetChargingSourceCnf;
enum ChargingStatusTag {
    CHARGING_STATUS_PRE = 3,
    CHARGING_STATUS_FAST = 2,
    CHARGING_STATUS_DONE = 1,
    CHARGING_STATUS_FAULT = 0
};
typedef enum ChargingStatusTag ChargingStatus;
struct RimCalGetChargingStatusCnfTag {
    BYTE status;
    BYTE _padding[3];
};
typedef struct RimCalGetChargingStatusCnfTag RimCalGetChargingStatusCnf;
enum CheckCryptoBatteryStatusTag {
    CBAUTH_BUSY = 2,
    CBAUTH_FAILED = 1,
    CBAUTH_SUCCESS = 0
};
typedef enum CheckCryptoBatteryStatusTag TestCryptoBatteryStatus;
struct RimCalCheckCryptoBatteryCnfTag {
    BYTE status;
    BYTE _padding[3];
    SDWORD id;
};
typedef struct RimCalCheckCryptoBatteryCnfTag RimCalCheckCryptoBatteryCnf;
enum ScTestStateTag {
    SCTEST_PASSED = 2,
    SCTEST_STARTED = 1,
    SCTEST_OFF = 0
};
typedef enum ScTestStateTag ScTestState;
struct StpReadAdcValueReqTag {
    BYTE adcValueType;
    BYTE _padding[3];
};
typedef struct StpReadAdcValueReqTag StpReadAdcValueReq;
struct StpReadAdcValueCnfTag {
    WORD adcValue;
    BYTE success;
    BYTE _padding;
};
typedef struct StpReadAdcValueCnfTag StpReadAdcValueCnf;
struct RimCalSetRs232CnfSignalTag {
    BYTE success;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimCalSetRs232CnfSignalTag RimCalSetRs232CnfSignal;
enum RefCalStatusTag {
    NO_EXT_REF_APPLIED = 2,
    REF_CAL_PASS = 1,
    REF_CAL_FAIL = 0
};
typedef enum RefCalStatusTag RefCalStatus;
struct RimCalIntRefVoltageReqTag {
    BYTE calWord;
    BYTE applyCalWord;
    WORD _padding;
};
typedef struct RimCalIntRefVoltageReqTag RimCalIntRefVoltageReq;
struct RimCalIntRefVoltageCnfTag {
    BYTE status;
    BYTE calWord;
    WORD _padding;
};
typedef struct RimCalIntRefVoltageCnfTag RimCalIntRefVoltageCnf;
enum NvControlTag {
    NV_CONT_EXT_DATA = 3,
    NV_CONT_GET_POINTER = 2,
    NV_CONT_USE_POINTER = 1,
    NV_CONT_USE_DATA = 0
};
typedef enum NvControlTag NvControl;
enum NvStatusTag {
    NVRAM_DEFAULT_CAL = 9,
    NVSTATUS_LAST = 8,
    NVRAM_NOT_PRESENT = 7,
    NVRAM_FULL = 6,
    NVRAM_DATA_CORRUPT = 5,
    NVRAM_REC_NOT_FOUND = 4,
    NVRAM_READ_FAILED = 3,
    NVRAM_WRITE_FAILED = 2,
    NVRAM_BAD = 1,
    NVRAM_OK = 0
};
typedef enum NvStatusTag NvStatus;
struct NvDataTag {
    WORD numBytes;
    WORD _padding;
    BYTE *dataBuffer_p;
    BYTE data[400];
};
typedef struct NvDataTag NvData;
struct NvDataReqTag {
    WORD numBytes;
    WORD _padding;
    BYTE *dataBuffer_p;
};
typedef struct NvDataReqTag NvDataReq;
struct RimCalNvramDeleteCalReqTag {
    BYTE calDataId;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimCalNvramDeleteCalReqTag RimCalNvramDeleteCalReq;
struct RimCalNvramDeleteCalCnfTag {
    BYTE status;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimCalNvramDeleteCalCnfTag RimCalNvramDeleteCalCnf;
struct RimCalNvramEraseCalReqTag {
    BYTE taskId;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimCalNvramEraseCalReqTag RimCalNvramEraseCalReq;
struct RimCalNvramEraseCalCnfTag {
    BYTE status;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimCalNvramEraseCalCnfTag RimCalNvramEraseCalCnf;
struct RimCalNvramReadCalReqTag {
    BYTE taskId;
    BYTE nvControl;
    BYTE calDataId;
    BYTE _padding;
    NvDataReq nvData;
};
typedef struct RimCalNvramReadCalReqTag RimCalNvramReadCalReq;
struct RimCalNvramReadCalCnfTag {
    BYTE nvControl;
    BYTE status;
    BYTE calDataId;
    BYTE calItemEmpty;
    NvData nvData;
};
typedef struct RimCalNvramReadCalCnfTag RimCalNvramReadCalCnf;
struct RimCalNvramWriteCalReqTag {
    BYTE taskId;
    BYTE nvControl;
    BYTE calDataId;
    BYTE _padding;
    NvData nvData;
};
typedef struct RimCalNvramWriteCalReqTag RimCalNvramWriteCalReq;
struct RimCalNvramWriteCalCnfTag {
    BYTE status;
    BYTE calDataId;
    WORD _padding;
};
typedef struct RimCalNvramWriteCalCnfTag RimCalNvramWriteCalCnf;
struct RimCalWriteCryptoBattChallengeReqTag {
    BYTE challenge[4];
    BYTE response[4];
    BYTE challenge2[4];
    BYTE response2[4];
    BYTE newFormat;
    BYTE padding[3];
};
typedef struct RimCalWriteCryptoBattChallengeReqTag RimCalWriteCryptoBattChallengeReq;
struct OldCryptoPairTag {
    BYTE challenge[4];
    BYTE response[4];
};
typedef struct OldCryptoPairTag OldCryptoPair;
struct NewCryptoPairTag {
    BYTE challenge[8];
    BYTE response[8];
};
typedef struct NewCryptoPairTag NewCryptoPair;
struct StpCryptoBattSendChallengeReqTag {
    BYTE challenge[8];
    DWORD length;
};
typedef struct StpCryptoBattSendChallengeReqTag StpCryptoBattSendChallengeReq;
struct StpCryptoBattFetchResponseCnfTag {
    BYTE success;
    BYTE response[8];
    BYTE activeMachine;
    BYTE padding[2];
};
typedef struct StpCryptoBattFetchResponseCnfTag StpCryptoBattFetchResponseCnf;
struct RimFtInitLcdReqTag {
    BYTE displayId;
    BYTE padding[3];
};
typedef struct RimFtInitLcdReqTag RimFtInitLcdReq;
struct RimFtInitLcdCnfTag {
    BYTE connected;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimFtInitLcdCnfTag RimFtInitLcdCnf;
enum LcdCalibCommandTag {
    WRITE_LCD_CALIBRATION = 2,
    READ_LCD_CALIBRATION = 1,
    USE_LCD_CALIBRATION = 0
};
typedef enum LcdCalibCommandTag LcdCalibCommand;
struct RimFtAccessLcdCalibReqTag {
    LcdCalibration lcdCalibration;
    BYTE command;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimFtAccessLcdCalibReqTag RimFtAccessLcdCalibReq;
struct RimFtAccessLcdCalibCnfTag {
    LcdCalibration lcdCalibration;
    BYTE success;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimFtAccessLcdCalibCnfTag RimFtAccessLcdCalibCnf;
struct RimFtSetLcdColourReqTag {
    BYTE red;
    BYTE green;
    BYTE blue;
    BYTE displayId;
};
typedef struct RimFtSetLcdColourReqTag RimFtSetLcdColourReq;
struct RimFtGetLcdConfigReqTag {
    BYTE displayId;
    BYTE padding[3];
};
typedef struct RimFtGetLcdConfigReqTag RimFtGetLcdConfigReq;
struct RimFtGetLcdConfigCnfTag {
    LcdConfig lcdConfig;
};
typedef struct RimFtGetLcdConfigCnfTag RimFtGetLcdConfigCnf;
struct RimFtDrawLineReqTag {
    DWORD mode;
    SWORD x1;
    SWORD y1;
    SWORD x2;
    SWORD y2;
    BYTE displayId;
    BYTE padding[3];
};
typedef struct RimFtDrawLineReqTag RimFtDrawLineReq;
struct RimFtDrawBoxReqTag {
    SWORD x1;
    SWORD y1;
    WORD width;
    WORD height;
    BYTE mode;
    BYTE displayId;
    BYTE padding[2];
};
typedef struct RimFtDrawBoxReqTag RimFtDrawBoxReq;
struct RimFtDrawTextReqTag {
    SWORD x;
    SWORD y;
    WORD length;
    BYTE displayId;
    BYTE _padding;
    BYTE text[100];
};
typedef struct RimFtDrawTextReqTag RimFtDrawTextReq;
struct RimFtTileBitmapReqTag {
    SWORD x;
    SWORD y;
    WORD width;
    WORD height;
    WORD numTiles;
    BYTE displayId;
    BYTE _padding;
    BYTE bitmap[160];
};
typedef struct RimFtTileBitmapReqTag RimFtTileBitmapReq;
typedef BYTE CalBacklightTypes;
struct StpSetBacklightReqTag {
    BYTE brightness;
    BYTE mode;
    BYTE bkltDomain;
    BYTE _padding;
    DWORD bkltType;
};
typedef struct StpSetBacklightReqTag StpSetBacklightReq;
struct RimFtSetBacklightCnfTag {
    BYTE success;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimFtSetBacklightCnfTag RimFtSetBacklightCnf;
struct StpSetBacklightMaxBrightnessReqTag {
    BYTE superbright;
    BYTE bkltDomain;
    WORD _padding;
    DWORD bkltType;
};
typedef struct StpSetBacklightMaxBrightnessReqTag StpSetBacklightMaxBrightnessReq;
struct RimFtBacklightConfigReqTag {
    BYTE backLightType;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimFtBacklightConfigReqTag RimFtBacklightConfigReq;
struct RimFtBacklightConfigCnfTag {
    BYTE success;
    BYTE _padding;
    WORD _padding2;
    DWORD maxBrightness;
    DWORD calibratedBrightness;
    DWORD calibratedTimeout;
};
typedef struct RimFtBacklightConfigCnfTag RimFtBacklightConfigCnf;
enum AutomaticBacklightModeTag {
    AUTOMATIC_BACKLIGHT_OFF = 1,
    AUTOMATIC_BACKLIGHT_ON = 0
};
typedef enum AutomaticBacklightModeTag AutomaticBacklightMode;
struct RimFtAutomaticBacklightReqTag {
    BYTE sensorMode;
    BYTE set;
    WORD _padding2;
};
typedef struct RimFtAutomaticBacklightReqTag RimFtAutomaticBacklightModeReq;
struct RimFtAutomaticBacklightModeCnfTag {
    BYTE success;
    BYTE sensorMode;
    WORD _padding2;
};
typedef struct RimFtAutomaticBacklightModeCnfTag RimFtAutomaticBacklightModeCnf;
struct RimFtFunlightBrightnessReqTag {
    BYTE set;
    BYTE ledType;
    BYTE brightnessPercent;
    BYTE _padding;
};
typedef struct RimFtFunlightBrightnessReqTag RimFtFunlightBrightnessReq;
struct RimFtFunlightBrightnessCnfTag {
    BYTE success;
    BYTE brightnessPercentRead;
    WORD _padding2;
};
typedef struct RimFtFunlightBrightnessCnfTag RimFtFunlightBrightnessCnf;
struct RimFtSetKbdBkltCurrReqTag {
    BYTE mAmpCurrent;
    BYTE _padding1;
    WORD _padding2;
};
typedef struct RimFtSetKbdBkltCurrReqTag RimFtSetKbdBkltCurrReq;
struct RimFtSetKbdBkltCurrCnfTag {
    BYTE success;
    BYTE _padding1;
    WORD _padding2;
};
typedef struct RimFtSetKbdBkltCurrCnfTag RimFtSetKbdBkltCurrCnf;
struct RimFtToggleLcdReqTag {
    WORD delay1;
    WORD delay2;
    WORD brightness;
    BYTE displayId;
    BYTE _padding;
};
typedef struct RimFtToggleLcdReqTag RimFtSetToggleLcdReq;
struct RimFtToggleLcdCnfTag {
    BYTE success;
    BYTE _padding1;
    WORD _padding2;
};
typedef struct RimFtToggleLcdCnfTag RimFtSetToggleLcdCnf;
struct RimFtBacklightPwmReqTag {
    BYTE set;
    BYTE backLightType;
    WORD pwmValue;
    WORD turnBacklightOn;
    WORD _padding;
};
typedef struct RimFtBacklightPwmReqTag RimFtBacklightPwmReq;
struct RimFtBacklightPwmCnfTag {
    BYTE success;
    BYTE _padding1;
    WORD pwmValue;
    WORD pwmMaximum;
    WORD _padding2;
};
typedef struct RimFtBacklightPwmCnfTag RimFtBacklightPwmCnf;
enum LcdMaxTrafficPatternsTag {
    LCD_MAX_TRAFFIC_CHECKERBOARD = 2,
    LCD_MAX_TRAFFIC_STATUS = 1,
    LCD_MAX_TRAFFIC_OFF = 0
};
typedef enum LcdMaxTrafficPatternsTag LcdMaxTrafficPatterns;
struct RimFtToggleLcdMaxTrafficReqTag {
    BYTE command;
    BYTE displayId;
    WORD _padding2;
};
typedef struct RimFtToggleLcdMaxTrafficReqTag RimFtToggleLcdMaxTrafficReq;
struct RimFtToggleLcdMaxTrafficCnfTag {
    BYTE success;
    BYTE status;
    WORD _padding2;
};
typedef struct RimFtToggleLcdMaxTrafficCnfTag RimFtToggleLcdMaxTrafficCnf;
struct VerifyAllCommandBMSKTag {
    QWORD commonSTPBmsk;
    QWORD osSTPBmsk;
    union {
        QWORD gprsSTPBmsk;
        QWORD cdmaSTPBmsk;
        QWORD orpheusSTPBmsk;
        QWORD denaliSTPBmsk;
        QWORD baryonSTPBmsk;
        QWORD data;
    } radioSTPBmsk;
};
typedef struct VerifyAllCommandBMSKTag VerifyAllCommandBMSK;
enum CommonSTPCommandStatusBMSKTag {
    JTAG_VERIFY_STATUS_BMSK = 2,
    WP_VERIFY_STATUS_BMSK = 1
};
typedef enum CommonSTPCommandStatusBMSKTag CommonSTPCommandStatusBMSK;
struct RimFtVerifyAllCommandsReqTag {
    BYTE setOfCommands;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimFtVerifyAllCommandsReqTag RimFtVerifyAllCommandsReq;
struct RimFtVerifyAllCommandsCnfTag {
    BYTE success;
    BYTE _padding[7];
    VerifyAllCommandBMSK failureBMSK;
};
typedef struct RimFtVerifyAllCommandsCnfTag RimFtVerifyAllCommandsCnf;
struct RimFtClearDisplayReqTag {
    BYTE displayId;
    BYTE padding[3];
};
typedef struct RimFtClearDisplayReqTag RimFtClearDisplayReq;
enum LEDColourTag {
    LED_WHITE = 4,
    LED_BLUE = 3,
    LED_GREEN = 2,
    LED_RED = 1
};
typedef enum LEDColourTag LEDColour;
struct RimFtSetLEDReqTag {
    BYTE state;
    BYTE LEDColour;
    WORD _padding2;
};
typedef struct RimFtSetLEDReqTag RimFtSetLEDReq;
struct RimFtSetLEDCnfTag {
    DWORD _padding;
};
typedef struct RimFtSetLEDCnfTag RimFtSetLEDCnf;
struct StpSensorGetValueReqTag {
    BYTE sensorId;
    BYTE _padding[3];
};
typedef struct StpSensorGetValueReqTag StpSensorGetValueReq;
struct StpSensorGetValueCnfTag {
    DWORD value;
    BYTE success;
    BYTE _padding[3];
};
typedef struct StpSensorGetValueCnfTag StpSensorGetValueCnf;
struct RimFtSetBuzzerReqTag {
    WORD frequency;
    WORD duration;
    WORD duty_cycle;
    WORD volume;
};
typedef struct RimFtSetBuzzerReqTag RimFtSetBuzzerReq;
struct RimFtSetVibratorReqTag {
    WORD duration;
    WORD duty_cycle;
};
typedef struct RimFtSetVibratorReqTag RimFtSetVibratorReq;
struct RimFtToggleVibratorReqTag {
    DWORD turnOn;
};
typedef struct RimFtToggleVibratorReqTag RimFtToggleVibratorReq;
struct RimFtGetSIMStatusCnfTag {
    BYTE inserted;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimFtGetSIMStatusCnfTag RimFtGetSIMStatusCnf;
enum ToneModeTag {
    TONE_OFF = 1,
    TONE_ON = 0
};
typedef enum ToneModeTag ToneMode;
struct RimFtSetToneReqTag {
    BYTE tone;
    BYTE volume;
    BYTE mode;
    BYTE dtmf;
    DWORD _padding;
};
typedef struct RimFtSetToneReqTag RimFtSetToneReq;
enum HeadsetMuteTag {
    MUTE_ALL = 3,
    MUTE_NONE = 2,
    MUTE_RIGHT = 1,
    MUTE_LEFT = 0
};
typedef enum HeadsetMuteTag HeadsetMute;
struct RimAudioMuteHeadsetReqTag {
    BYTE headsetMuteMode;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimAudioMuteHeadsetReqTag RimAudioMuteHeadsetReq;
struct RimAudioMuteHeadsetCnfTag {
    DWORD success;
};
typedef struct RimAudioMuteHeadsetCnfTag RimAudioMuteHeadsetCnf;
struct RimFtSetSingleToneReqTag {
    WORD frequency;
    BYTE volume;
    BYTE mode;
};
typedef struct RimFtSetSingleToneReqTag RimFtSetSingleToneReq;
struct RimFtSetAudioPathReqTag {
    BYTE inPort;
    BYTE outPort;
    BYTE _padding[2];
};
typedef struct RimFtSetAudioPathReqTag RimFtSetAudioPathReq;
struct RimFtSetAudioPathCnfTag {
    BYTE success;
    BYTE _padding[3];
};
typedef struct RimFtSetAudioPathCnfTag RimFtSetAudioPathCnf;
enum AudioLoopBackTestStatusTag {
    AUDIO_LOOPBACK_TEST_FAIL = 2,
    AUDIO_LOOPBACK_TEST_PASS = 1,
    AUDIO_LOOPBACK_TEST_UNSUPPORTED = 0
};
typedef enum AudioLoopBackTestStatusTag AudioLoopBackTestStatus;
enum AudioLoopBackModeTag {
    AUDIO_LOOPBACK_DEEP_DISABLE = 7,
    AUDIO_LOOPBACK_DEEP_ENABLE = 6,
    AUDIO_LOOPBACK_PATRIOT_DISABLE = 5,
    AUDIO_LOOPBACK_PATRIOT_ENABLE = 4,
    AUDIO_LOOPBACK_TI_TEST = 3,
    AUDIO_LOOPBACK_BT_TEST = 2,
    AUDIO_LOOPBACK_DISABLE = 1,
    AUDIO_LOOPBACK_ENABLE = 0
};
typedef enum AudioLoopBackModeTag AudioLoopBackMode;
struct RimFtAccessAudioLoopBackReqTag {
    BYTE loopBackMode;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimFtAccessAudioLoopBackReqTag RimFtAccessAudioLoopBackReq;
struct RimFtGetHeadsetStatusCnfTag {
    BYTE inserted;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimFtGetHeadsetStatusCnfTag RimFtGetHeadsetStatusCnf;
enum AudioShortDetTag {
    AUDIO_SHORT_DET_ENABLE_LOW = 2,
    AUDIO_SHORT_DET_ENABLE_HIGH = 1,
    AUDIO_SHORT_DET_DISABLE = 0
};
typedef enum AudioShortDetTag AudioShortDet;
struct RimFtGetBatteryLevelReqTag {
    BYTE getVoltageLevel;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimFtGetBatteryLevelReqTag RimFtGetBatteryLevelReq;
struct RimFtGetBatteryLevelCnfTag {
    DWORD level;
};
typedef struct RimFtGetBatteryLevelCnfTag RimFtGetBatteryLevelCnf;
struct RimFtGetBatteryIdCnfTag {
    BYTE id;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimFtGetBatteryIdCnfTag RimFtGetBatteryIdCnf;
struct RimFtGetBatteryStatusCnfTag {
    DWORD status;
};
typedef struct RimFtGetBatteryStatusCnfTag RimFtGetBatteryStatusCnf;
struct RimFtGetTemperatureCnfTag {
    BYTE status;
    BYTE padding[3];
    DWORD temperature;
};
typedef struct RimFtGetTemperatureCnfTag RimFtGetTemperatureCnf;
struct RimFtInitConsoleReqTag {
    BYTE closeConsole;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimFtInitConsoleReqTag RimFtInitConsoleReq;
struct RimFtVadGetDetectCnfTag {
    BYTE inserted;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimFtVadGetDetectCnfTag RimFtVadGetDetectCnf;
struct RimFtLcdAutoDetectReqTag {
    BYTE set_get;
    BYTE argument;
    BYTE extraPadding[2];
    BYTE displayId;
    BYTE padding[3];
};
typedef struct RimFtLcdAutoDetectReqTag RimFtLcdAutoDetectReq;
struct RimFtGetKeysReqTag {
    BYTE noPaddingInCnf;
    BYTE _padding[3];
};
typedef struct RimFtGetKeysReqTag RimFtGetKeysReq;
struct RimFtGetKeysCnfTag {
    WORD numKeys;
    WORD padding;
    WORD buffer[200];
};
typedef struct RimFtGetKeysCnfTag RimFtGetKeysCnf;
struct MfgErrorStorageTag {
    WORD mfgErrorsArray[10];
    BYTE mfgErrorString[64];
};
typedef struct MfgErrorStorageTag MfgErrorStorage;
struct RimFtMfgErrorReqTag {
    WORD set;
    WORD numOfErrors;
    MfgErrorStorage mfgErrors;
};
typedef struct RimFtMfgErrorReqTag RimFtMfgErrorReq;
struct RimFtMfgErrorCnfTag {
    WORD success;
    WORD _padding;
    MfgErrorStorage mfgErrors;
};
typedef struct RimFtMfgErrorCnfTag RimFtMfgErrorCnf;
struct RimFtJvmReportedStateReqTag {
    DWORD property;
};
typedef struct RimFtJvmReportedStateReqTag RimFtJvmReportedStateReq;
struct RimFtJvmReportedStateCnfTag {
    BYTE success;
    BYTE _padding[3];
    DWORD value;
};
typedef struct RimFtJvmReportedStateCnfTag RimFtJvmReportedStateCnf;
struct RimDcAccessIDReqTag {
    union {
        BYTE id1[16];
        DWORD id2;
    } id;
    BYTE command;
    BYTE id_type;
    WORD _padding;
};
typedef struct RimDcAccessIDReqTag RimDcAccessIDReq;
struct RimDcAccessIDCnfTag {
    union {
        BYTE id1[16];
        DWORD id2;
    } id;
    BYTE status;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimDcAccessIDCnfTag RimDcAccessIDCnf;
struct RimIdenRalpHexReqTag {
    BYTE len;
    BYTE ralpCmd[170];
};
typedef struct RimIdenRalpHexReqTag RimIdenRalpHexReq;
struct STPIdenBerbugTag {
    WORD length;
    BYTE data[512];
    WORD _padding2;
};
typedef struct STPIdenBerbugTag STPIdenBerbug;
typedef enum {
    VERIFY_HMC_SHORT = 5,
    VERIFY_HMC = 4,
    COMPLETE_TEST = 3,
    RESET_VALUES = 2,
    RELAXED_TEST = 1,
    STRICT_TEST = 0
} MemoryTestTypes;
typedef enum {
    SDCARDTEST_CONNECTION_FAIL = 22,
    SDCARDTEST_ALREADY_OPENED = 21,
    SDCARDTEST_FORMAT_FAIL = 20,
    FLASHTEST_SPANSION_STOPPED = 19,
    FLASHTEST_SPANSION_RUNNING = 18,
    FLASHTEST_SPANSION_READ_PASS = 17,
    FLASHTEST_SPANSION_READ_FAIL = 16,
    MEMORYTEST_BAD_WIDTH = 15,
    MEMORYTEST_INSUFFICIENT_MEM = 14,
    SDCARDTEST_ERASE_FAIL = 13,
    SDCARDTEST_VERIFY_FAIL = 12,
    SDCARDTEST_READ_FAIL = 11,
    SDCARDTEST_WRITE_FAIL = 10,
    SDCARDTEST_FAIL_TO_OPEN = 9,
    FLASHCONFIGURE_FAIL = 8,
    MEMORYTEST_ILLEGAL_PARAM = 7,
    FLASHTEST_UNAVAILABLE_ID = 6,
    FLASHTEST_ID_NOT_READY = 5,
    FLASHTEST_FAIL = 4,
    RAMTEST_RAM_IS_BAD = 3,
    RAMTEST_JVMSTATUS_SET = 2,
    RAMCONFIGURE_FAIL = 1,
    MEMORYTEST_SUCCESS = 0
} MemoryTestStatus;
typedef enum {
    NOMINAL_VCORE = 2,
    INCREASE_VCORE = 1,
    REDUCE_VCORE = 0
} VoltageTypes;
typedef enum {
    BUFFER_4CELL_2PROG = 4,
    BUFFER_4CELL_1PROG = 3,
    BUFFER_4CELL = 2,
    BUFFER_3CELL = 1,
    BUFFER_2CELL = 0,
    BUFFER_1CELL = 7,
    BUFFER = 6,
    NO_DELAY = 5
} DelayTypes;
struct RimDcVerifyMemoryReqTag {
    BYTE memoryType;
    BYTE startTest;
    BYTE delay;
    BYTE _padding1;
    DWORD typeOfTest;
    VoltageTypes coreVoltage;
};
typedef struct RimDcVerifyMemoryReqTag RimDcVerifyMemoryReq;
struct RimDcVerifyMemoryCnfTag {
    DWORD status;
    DWORD SDPinFailures;
};
typedef struct RimDcVerifyMemoryCnfTag RimDcVerifyMemoryCnf;
struct RimDcSpansionFlashTestReqTag {
    BYTE startTest;
    BYTE queryStatus;
    WORD _padding1;
};
typedef struct RimDcSpansionFlashTestReqTag RimDcSpansionFlashTestReq;
struct RimDcSpansionFlashTestCnfTag {
    DWORD status;
    DWORD numFailures;
};
typedef struct RimDcSpansionFlashTestCnfTag RimDcSpansionFlashTestCnf;
struct RimBluetoothOnOffReqTag {
    BYTE on;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimBluetoothOnOffReqTag RimBluetoothOnOffReq;
struct RimBluetoothOnOffCnfTag {
    BYTE success;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimBluetoothOnOffCnfTag RimBluetoothOnOffCnf;
typedef enum {
    BT_STP_RADIO_STATE_READY = 4,
    BT_STP_RADIO_STATE_INITIALIZING = 3,
    BT_STP_RADIO_STATE_RESETTING = 2,
    BT_STP_RADIO_STATE_SHUTTING_DOWN = 1,
    BT_STP_RADIO_STATE_SHUTDOWN = 0
} RimBluetoothRadioStatus;
struct RimBluetoothRadioStatusReqTag {
    DWORD _padding;
};
typedef struct RimBluetoothRadioStatusReqTag RimBluetoothRadioStatusReq;
struct RimBluetoothRadioStatusCnfTag {
    DWORD status;
};
typedef struct RimBluetoothRadioStatusCnfTag RimBluetoothRadioStatusCnf;
struct RimBluetoothSetSlaveModeReqTag {
    DWORD _padding;
};
typedef struct RimBluetoothSetSlaveModeReqTag RimBluetoothSetSlaveModeReq;
struct RimBluetoothSetSlaveModeCnfTag {
    BYTE success;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimBluetoothSetSlaveModeCnfTag RimBluetoothSetSlaveModeCnf;
struct RimBluetoothGetSlaveModeReqTag {
    DWORD _padding;
};
typedef struct RimBluetoothGetSlaveModeReqTag RimBluetoothGetSlaveModeReq;
struct RimBluetoothGetSlaveModeCnfTag {
    BYTE on;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimBluetoothGetSlaveModeCnfTag RimBluetoothGetSlaveModeCnf;
struct RimBluetoothSetTestModeReqTag {
    DWORD _padding;
};
typedef struct RimBluetoothSetTestModeReqTag RimBluetoothSetTestModeReq;
struct RimBluetoothSetTestModeCnfTag {
    BYTE success;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimBluetoothSetTestModeCnfTag RimBluetoothSetTestModeCnf;
struct RimBluetoothGetTestModeReqTag {
    DWORD _padding;
};
typedef struct RimBluetoothGetTestModeReqTag RimBluetoothGetTestModeReq;
struct RimBluetoothGetTestModeCnfTag {
    BYTE on;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimBluetoothGetTestModeCnfTag RimBluetoothGetTestModeCnf;
struct BCCMDPDUTag {
    WORD type;
    WORD length;
    WORD sequenceNumber;
    WORD varid;
    WORD status;
    WORD buffer[21];
};
typedef struct BCCMDPDUTag BCCMDPDU;
struct RimBluetoothBCCMDReqTag {
    BCCMDPDU bccmdPDU;
};
typedef struct RimBluetoothBCCMDReqTag RimBluetoothBCCMDReq;
struct RimBluetoothBCCMDCnfTag {
    BCCMDPDU bccmdPDU;
    BYTE success;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimBluetoothBCCMDCnfTag RimBluetoothBCCMDCnf;
struct RimBluetoothHCIReqTag {
    WORD hciCommand;
    BYTE length;
    BYTE event;
    BYTE parms[24];
};
typedef struct RimBluetoothHCIReqTag RimBluetoothHCIReq;
struct RimBluetoothHCICnfTag {
    BYTE success;
    BYTE event;
    BYTE length;
    BYTE _padding;
    BYTE parms[24];
};
typedef struct RimBluetoothHCICnfTag RimBluetoothHCICnf;
struct RimBluetoothCheckHardwareVersionCnfTag {
    BYTE success;
    BYTE correctVersion;
    WORD _padding2;
};
typedef struct RimBluetoothCheckHardwareVersionCnfTag RimBluetoothCheckHardwareVersionCnf;
struct RimWlanHReadReqTag {
    WORD reg;
    WORD _padding;
};
typedef struct RimWlanHReadReqTag RimWlanHReadReq;
struct RimWlanHReadCnfTag {
    WORD reg;
    WORD result;
};
typedef struct RimWlanHReadCnfTag RimWlanHReadCnf;
struct RimWlanHWriteReqTag {
    WORD reg;
    WORD value;
};
typedef struct RimWlanHWriteReqTag RimWlanHWriteReq;
struct RimWlanHWriteCnfTag {
    WORD reg;
    WORD _padding;
};
typedef struct RimWlanHWriteCnfTag RimWlanHWriteCnf;
struct RimWlanWfaTestEngineReqTag {
    BYTE pWfaTlv[8192];
};
typedef struct RimWlanWfaTestEngineReqTag RimWlanWfaTestEngineReq;
struct RimWlanWfaTestEngineCnfTag {
    BYTE pWfaTlv[8192];
};
typedef struct RimWlanWfaTestEngineCnfTag RimWlanWfaTestEngineCnf;
struct RimWlanIoctlBatchReadReqTag {
    WORD size;
    WORD reg;
    WORD _padding;
    WORD _padding2;
};
typedef struct RimWlanIoctlBatchReadReqTag RimWlanIoctlBatchReadReq;
struct RimWlanIoctlBatchReadCnfTag {
    WORD size;
    WORD reg;
    WORD buf[1024];
};
typedef struct RimWlanIoctlBatchReadCnfTag RimWlanIoctlBatchReadCnf;
struct RimWlanIoctlBatchWriteReqTag {
    WORD size;
    WORD reg;
    WORD buf[1024];
};
typedef struct RimWlanIoctlBatchWriteReqTag RimWlanIoctlBatchWriteReq;
struct RimWlanIoctlBatchWriteCnfTag {
    WORD size;
    WORD reg;
};
typedef struct RimWlanIoctlBatchWriteCnfTag RimWlanIoctlBatchWriteCnf;
struct RimWlanDoCommandReqTag {
    WORD delay;
    WORD _padding;
    WORD params[8];
};
typedef struct RimWlanDoCommandReqTag RimWlanDoCommandReq;
struct RimWlanDoCommandCnfTag {
    WORD success;
    WORD _padding;
    WORD params[8];
};
typedef struct RimWlanDoCommandCnfTag RimWlanDoCommandCnf;
struct WlanArtDevNumReqTag {
    DWORD devNum;
};
typedef struct WlanArtDevNumReqTag WlanArtDevNumReq;
struct WlanArtSetupDeviceReqTag {
    DWORD whichDevice;
};
typedef struct WlanArtSetupDeviceReqTag WlanArtSetupDeviceReq;
struct WlanArtSubDevInfoTag {
    char regFilename[128];
    char libRevStr[128];
    DWORD aRevID;
    DWORD hwDevID;
    DWORD swDevID;
    DWORD bbRevID;
    DWORD macRev;
    DWORD subSystemID;
    DWORD defaultConfig;
};
typedef struct WlanArtSubDevInfoTag WlanArtSubDevInfo;
struct WlanArtCfgReadReqTag {
    DWORD devNum;
    DWORD regOffset;
};
typedef struct WlanArtCfgReadReqTag WlanArtCfgReadReq;
struct WlanArtCheckLibErrorReqTag {
    DWORD devNum;
    BYTE printError;
    BYTE _padding[3];
};
typedef struct WlanArtCheckLibErrorReqTag WlanArtCheckLibErrorReq;
struct WlanArtResetDeviceReqTag {
    DWORD devNum;
    BYTE mac[6];
    BYTE bss[6];
    DWORD freq;
    DWORD turbo;
};
typedef struct WlanArtResetDeviceReqTag WlanArtResetDeviceReq;
struct WlanArtEepromReadReqTag {
    DWORD devNum;
    DWORD eepromOffset;
};
typedef struct WlanArtEepromReadReqTag WlanArtEepromReadReq;
struct WlanArtEepromWriteReqTag {
    DWORD devNum;
    DWORD eepromOffset;
    DWORD eepromValue;
};
typedef struct WlanArtEepromWriteReqTag WlanArtEepromWriteReq;
struct WlanArtEepromReadBlockReqTag {
    DWORD devNum;
    DWORD startOffset;
    DWORD length;
};
typedef struct WlanArtEepromReadBlockReqTag WlanArtEepromReadBlockReq;
struct WlanArtEepromReadBlockCnfTag {
    DWORD length;
    DWORD buf[512];
};
typedef struct WlanArtEepromReadBlockCnfTag WlanArtEepromReadBlockCnf;
struct WlanArtEepromWriteBlockReqTag {
    DWORD devNum;
    DWORD startOffset;
    DWORD length;
    DWORD buf[512];
};
typedef struct WlanArtEepromWriteBlockReqTag WlanArtEepromWriteBlockReq;
struct WlanArtParseModeInfoTag {
    char fieldName[70];
    char value11aStr[30];
    char value11aTurboStr[30];
    char value11bStr[30];
    char value11gStr[30];
    char value11gTurboStr[30];
};
typedef struct WlanArtParseModeInfoTag WlanArtParseModeInfo;
struct WlanArtParseFieldInfoTag {
    char fieldName[70];
    char valueString[30];
};
typedef struct WlanArtParseFieldInfoTag WlanArtParseFieldInfo;
struct WlanArtGetFieldForModeReqTag {
    DWORD devNum;
    DWORD mode;
    DWORD turbo;
    char fieldName[256];
};
typedef struct WlanArtGetFieldForModeReqTag WlanArtGetFieldForModeReq;
struct WlanArtChangeMultipleFieldsAllModesReqTag {
    DWORD devNum;
    DWORD numFields;
    WlanArtParseModeInfo fieldsToChange[10];
};
typedef struct WlanArtChangeMultipleFieldsAllModesReqTag WlanArtChangeMultipleFieldsAllModesReq;
struct WlanArtChangeMultipleFieldsReqTag {
    DWORD devNum;
    WlanArtParseFieldInfo fieldsToChange[10];
    DWORD numFields;
};
typedef struct WlanArtChangeMultipleFieldsReqTag WlanArtChangeMultipleFieldsReq;
struct WlanArtGetMacAddrReqTag {
    DWORD devNum;
    WORD wmac;
    WORD instNo;
};
typedef struct WlanArtGetMacAddrReqTag WlanArtGetMacAddrReq;
struct WlanArtGetMacAddrCnfTag {
    WORD result;
    BYTE macAddr[6];
};
typedef struct WlanArtGetMacAddrCnfTag WlanArtGetMacAddrCnf;
struct WlanArtGetFieldReqTag {
    DWORD devNum;
    char fieldName[256];
};
typedef struct WlanArtGetFieldReqTag WlanArtGetFieldReq;
struct WlanArtGetFieldCnfTag {
    DWORD baseValue;
    DWORD turboValue;
};
typedef struct WlanArtGetFieldCnfTag WlanArtGetFieldCnf;
struct WlanArtAccessFieldReqTag {
    DWORD devNum;
    char fieldName[256];
    DWORD newValue;
};
typedef struct WlanArtAccessFieldReqTag WlanArtAccessFieldReq;
struct WlanArtEnableHwCalReqTag {
    DWORD devNum;
    DWORD calFlag;
};
typedef struct WlanArtEnableHwCalReqTag WlanArtEnableHwCalReq;
struct WlanArtSetResetParamsReqTag {
    DWORD devNum;
    BYTE eePromLoad;
    BYTE eePromHeaderLoad;
    BYTE mode;
    BYTE _padding;
    WORD initCodeFlag;
    WORD _padding2;
};
typedef struct WlanArtSetResetParamsReqTag WlanArtSetResetParamsReq;
struct WlanArtSupplyFalseDetectbackoffCnfTag {
    DWORD backoffValues[3];
};
typedef struct WlanArtSupplyFalseDetectbackoffCnfTag SupplyFalseDetectbackoffCnf;
struct WlanArtGetXpdgainForPowerReqTag {
    DWORD devNum;
    WORD power;
    WORD _padding;
};
typedef struct WlanArtGetXpdgainForPowerReqTag WlanArtGetXpdgainForPowerReq;
struct WlanArtGetPowerIndexReqTag {
    DWORD devNum;
    DWORD power;
};
typedef struct WlanArtGetPowerIndexReqTag WlanArtGetPowerIndexReq;
struct WlanArtGetArtAniLevelReqTag {
    DWORD devNum;
    DWORD artAniType;
};
typedef struct WlanArtGetArtAniLevelReqTag WlanArtGetArtAniLevelReq;
struct WlanArtSetArtAniLevelReqTag {
    DWORD devNum;
    DWORD artAniType;
    DWORD artAniLevel;
};
typedef struct WlanArtSetArtAniLevelReqTag WlanArtSetArtAniLevelReq;
struct WlanArtCtlPwrRangeTag {
    DWORD lowChannel;
    DWORD highChannel;
    long twicePower;
};
typedef struct WlanArtCtlPwrRangeTag WlanArtCtlPwrRange;
struct WlanArtCtlPowerInfoTag {
    WlanArtCtlPwrRange ctlPowerChannelRangeOfdm[8];
    WlanArtCtlPwrRange ctlPowerChannelRangeCck[8];
    long               powerOfdm;
    long               powerCck;
    DWORD channelApplied;
    DWORD structureFilled;
};
typedef struct WlanArtCtlPowerInfoTag WlanArtCtlPowerInfo;
struct WlanArtGetCtlPowerInfoCnfTag {
    BYTE result;
    BYTE _padding[3];
    WlanArtCtlPowerInfo returnStruct;
};
typedef struct WlanArtGetCtlPowerInfoCnfTag WlanArtCtlPowerInfoCnf;
struct WlanArtGetMaxLinPowerCnfTag {
    double result;
};
typedef struct WlanArtGetMaxLinPowerCnfTag WlanArtGetMaxLinPowerCnf;
struct WlanArtGetEARCalAtChannelReqTag {
    DWORD devNum;
    BYTE atCal;
    BYTE _padding;
    WORD channel;
    DWORD word[4];
    WORD xpd_mask;
    WORD _padding2;
    DWORD version_mask;
};
typedef struct WlanArtGetEARCalAtChannelReqTag WlanArtGetEARCalAtChannelReq;
struct WlanArtTestLibReqTag {
    DWORD devNum;
    DWORD timeout;
};
typedef struct WlanArtTestLibReqTag WlanArtTestLibReq;
struct WlanArtRegReadReqTag {
    DWORD devNum;
    DWORD regOffset;
};
typedef struct WlanArtRegReadReqTag WlanArtRegReadReq;
struct WlanArtRegWriteReqTag {
    DWORD devNum;
    DWORD regOffset;
    DWORD regValue;
};
typedef struct WlanArtRegWriteReqTag WlanArtRegWriteReq;
struct WlanArtForcePowerTxMaxReqTag {
    DWORD devNum;
    WORD ratesPower[40];
};
typedef struct WlanArtForcePowerTxMaxReqTag WlanArtForcePowerTxMaxReq;
struct WlanArtForceSinglePowerTxMaxReqTag {
    DWORD devNum;
    WORD powerValue;
    WORD _padding;
};
typedef struct WlanArtForceSinglePowerTxMaxReqTag WlanArtForceSinglePowerTxMaxReq;
struct WlanArtForceSinglePCDACTableReqTag {
    DWORD devNum;
    WORD pcdac;
    WORD _padding;
};
typedef struct WlanArtForceSinglePCDACTableReqTag WlanArtForceSinglePCDACTableReq;
struct WlanArtForceSinglePCDACTableGriffinReqTag {
    DWORD devNum;
    WORD pcdac;
    WORD offset;
};
typedef struct WlanArtForceSinglePCDACTableGriffinReqTag WlanArtForceSinglePCDACTableGriffinReq;
struct WlanArtForcePCDACTableReqTag {
    DWORD devNum;
    WORD pcdac[128];
};
typedef struct WlanArtForcePCDACTableReqTag WlanArtForcePCDACTableReq;
struct WlanArtGetMaxPowerForRateReqTag {
    DWORD devNum;
    WORD freq;
    WORD rate;
};
typedef struct WlanArtGetMaxPowerForRateReqTag WlanArtGetMaxPowerForRateReq;
struct WlanArtGetPcdacForPowerReqTag {
    DWORD devNum;
    WORD freq;
    WORD power;
};
typedef struct WlanArtGetPcdacForPowerReqTag WlanArtGetPcdacForPowerReq;
struct WlanArtTxContBeginReqTag {
    DWORD devNum;
    DWORD type;
    DWORD typeOption1;
    DWORD typeOption2;
    DWORD antenna;
};
typedef struct WlanArtTxContBeginReqTag WlanArtTxContBeginReq;
struct WlanArtTxContFrameBeginReqTag {
    DWORD devNum;
    DWORD length;
    DWORD ifswait;
    DWORD typeOption1;
    DWORD typeOption2;
    DWORD antenna;
    BYTE performStabilizePower;
    BYTE _padding[3];
    DWORD numDescriptors;
    BYTE dest[6];
    BYTE _padding2[2];
};
typedef struct WlanArtTxContFrameBeginReqTag WlanArtTxContFrameBeginReq;
struct WlanArtTxStatsTag {
    DWORD goodPackets;
    DWORD underruns;
    DWORD ackSigStrengthMin;
    DWORD ackSigStrengthMax;
    DWORD ackSigStrengthAvg;
    DWORD throughput;
    DWORD excessiveRetries;
    DWORD shortRetry1;
    DWORD shortRetry2;
    DWORD shortRetry3;
    DWORD shortRetry4;
    DWORD shortRetry5;
    DWORD shortRetry6to10;
    DWORD shortRetry11to15;
    DWORD longRetry1;
    DWORD longRetry2;
    DWORD longRetry3;
    DWORD longRetry4;
    DWORD longRetry5;
    DWORD longRetry6to10;
    DWORD longRetry11to15;
    DWORD newThroughput;
    DWORD startTime;
    DWORD endTime;
    DWORD firstPktGood;
};
typedef struct WlanArtTxStatsTag WlanArtTxStats;
struct WlanArtRxStatsTag {
    DWORD goodPackets;
    long DataSigStrengthMin;
    long DataSigStrengthMax;
    long DataSigStrengthAvg;
    DWORD crcPackets;
    DWORD singleDups;
    DWORD multipleDups;
    DWORD bitMiscompares;
    DWORD bitErrorCompares;
    long ppmMin;
    long ppmMax;
    long ppmAvg;
    DWORD decrypErrors;
};
typedef struct WlanArtRxStatsTag WlanArtRxStats;
struct WlanArtGetStatsReqTag {
    DWORD devNum;
    DWORD rateInMb;
    DWORD remote;
};
typedef struct WlanArtGetStatsReqTag WlanArtGetStatsReq;
struct WlanArtSetSingleTransmitPowerReqTag {
    DWORD devNum;
    BYTE pcdac;
    BYTE _padding[3];
};
typedef struct WlanArtSetSingleTransmitPowerReqTag WlanArtSetSingleTransmitPowerReq;
struct WlanArtCheckPromReqTag {
    DWORD devNum;
    DWORD enablePrint;
};
typedef struct WlanArtCheckPromReqTag WlanArtCheckPromReq;
struct WlanArtChangeChannelReqTag {
    DWORD devNum;
    DWORD freq;
};
typedef struct WlanArtChangeChannelReqTag WlanArtChangeChannelReq;
struct WlanArtTxDataSetupReqTag {
    DWORD devNum;
    DWORD rateMask;
    BYTE dest[6];
    WORD _padding;
    DWORD numDescPerRate;
    DWORD dataBodyLength;
    BYTE dataPattern[256];
    DWORD dataPatternLength;
    DWORD retries;
    DWORD antenna;
    DWORD broadcast;
};
typedef struct WlanArtTxDataSetupReqTag WlanArtTxDataSetupReq;
struct WlanArtTxDataBeginReqTag {
    DWORD devNum;
    DWORD timeout;
    DWORD remoteStats;
};
typedef struct WlanArtTxDataBeginReqTag WlanArtTxDataBeginReq;
struct WlanArtRxDataSetupReqTag {
    DWORD devNum;
    DWORD numDesc;
    DWORD dataBodyLength;
    DWORD enablePPM;
};
typedef struct WlanArtRxDataSetupReqTag WlanArtRxDataSetupReq;
struct WlanArtCleanupTxRxMemoryReqTag {
    DWORD devNum;
    DWORD flags;
};
typedef struct WlanArtCleanupTxRxMemoryReqTag WlanArtCleanupTxRxMemoryReq;
struct WlanArtRxDataBeginReqTag {
    DWORD devNum;
    DWORD waitTime;
    DWORD timeout;
    DWORD remoteStats;
    DWORD enableCompare;
    BYTE dataPattern[256];
    DWORD dataPatternLength;
};
typedef struct WlanArtRxDataBeginReqTag WlanArtRxDataBeginReq;
struct WlanArtRxGetDataReqTag {
    DWORD devNum;
    DWORD bufferNum;
};
typedef struct WlanArtRxGetDataReqTag WlanArtRxGetDataReq;
struct WlanArtRxGetDataCnfTag {
    BYTE returnBuffer[256];
};
typedef struct WlanArtRxGetDataCnfTag WlanArtRxGetDataCnf;
struct WlanArtRxDataCompleteReqTag {
    DWORD devNum;
    DWORD waitTime;
    DWORD timeout;
    DWORD remoteStats;
    DWORD enableCompare;
    BYTE dataPattern[256];
    DWORD dataPatternLength;
};
typedef struct WlanArtRxDataCompleteReqTag WlanArtRxDataCompleteReq;
struct WlanArtTxrxDataBeginReqTag {
    DWORD devNum;
    DWORD waitTime;
    DWORD timeout;
    DWORD remoteStats;
    DWORD enableCompare;
    BYTE dataPattern[256];
    DWORD dataPatternLength;
};
typedef struct WlanArtTxrxDataBeginReqTag WlanArtTxrxDataBeginReq;
struct WlanArtRxStatsSnapshotTag {
    DWORD goodPackets;
    DWORD DataSigStrength;
    DWORD dataRate;
    DWORD bodySize;
    DWORD crcPackets;
    DWORD decrypErrors;
};
typedef struct WlanArtRxStatsSnapshotTag WlanArtRxStatsSnapshot;
struct RxLastDescStatsSnapshotCnfTag {
    BYTE result;
    BYTE _padding[3];
    WlanArtRxStatsSnapshot rxStats;
};
typedef struct RxLastDescStatsSnapshotCnfTag WlanArtRxLastDescStatsSnapshotCnf;
struct WlanArtSetAntennaReqTag {
    DWORD devNum;
    DWORD antenna;
};
typedef struct WlanArtSetAntennaReqTag WlanArtSetAntennaReq;
struct WlanArtForwardToTargetCnfTag {
    BYTE success;
    BYTE tag;
    WORD length;
    BYTE result;
    BYTE _padding;
};
typedef struct WlanArtForwardToTargetCnfTag WlanArtForwardToTargetCnf;
struct WlanArtSdioTestReqTag {
    DWORD devNum;
    DWORD iterations;
    DWORD offset;
    DWORD offset2;
    DWORD value;
    DWORD value2;
};
typedef struct WlanArtSdioTestReqTag WlanArtSdioTestReq;
struct RimWlanStoreTiCalibrationReqTag {
    unsigned short version;
    unsigned short length;
    unsigned int _reserved1;
    unsigned int _reserved2;
    unsigned char data[1024];
};
typedef struct RimWlanStoreTiCalibrationReqTag RimWlanStoreTiCalibrationReq;
struct RimWlanStoreTiCalibrationCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanStoreTiCalibrationCnfTag RimWlanStoreTiCalibrationCnf;
struct RimWlanReadTiCalibrationReqTag {
    DWORD _reserved;
};
typedef struct RimWlanReadTiCalibrationReqTag RimWlanReadTiCalibrationReq;
struct RimWlanReadTiCalibrationCnfTag {
    WORD success;
    WORD _reserved;
    WORD version;
    WORD length;
    unsigned char data[1024];
};
typedef struct RimWlanReadTiCalibrationCnfTag RimWlanReadTiCalibrationCnf;
typedef enum {
    WLAN_WL6_CAL_AREA_INI = 1,
    WLAN_WL6_CAL_AREA_NVS = 0
} WlanWl6CalibrationAreaEnum;
struct StpWlanWl6WriteNvsReqTag {
    WORD area;
    WORD length;
    BYTE buffer[2048];
};
typedef struct StpWlanWl6WriteNvsReqTag StpWlanWl6WriteNvsReq;
struct StpWlanWl6ReadNvsCnfTag {
    WORD success;
    WORD length;
    BYTE buffer[2048];
};
typedef struct StpWlanWl6ReadNvsCnfTag StpWlanWl6ReadNvsCnf;
struct StpWlanWl6UpdtRefPointReqTag {
    DWORD subBand;
    DWORD refPDVal;
    DWORD refPower;
};
typedef struct StpWlanWl6UpdtRefPointReqTag StpWlanWl6UpdtRefPointReq;
struct StpWlanWl6TestCmdFccReqTag {
    DWORD channel;
    DWORD bitRate;
    DWORD txpower;
};
typedef struct StpWlanWl6TestCmdFccReqTag StpWlanWl6TestCmdFccReq;
struct RimWlanWippBridgeTiReqTag {
    DWORD _reserved;
};
typedef struct RimWlanWippBridgeTiReqTag RimWlanWippBridgeTiReq;
struct RimWlanWippBridgeTiCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanWippBridgeTiCnfTag RimWlanWippBridgeTiCnf;
struct RimWlanReadRSSIReqTag {
    char ssid[16];
    BYTE channel;
    BYTE _padding[3];
};
typedef struct RimWlanReadRSSIReqTag RimWlanReadRSSIReq;
struct RimWlanReadRSSICnfTag {
    WORD success;
    SWORD rssi;
    BYTE bssid[6];
    WORD _padding;
};
typedef struct RimWlanReadRSSICnfTag RimWlanReadRSSICnf;
struct RimWlanProbeRequestSendReqTag {
    WORD reqCount;
    WORD reqChannel;
};
typedef struct RimWlanProbeRequestSendReqTag RimWlanProbeRequestSendReq;
struct RimWlanUnregProbeRequestSendReqTag {
    WORD reqCount;
    WORD reqChannel;
    BYTE reqRate;
    BYTE pwrDbm;
    WORD _reserved_1;
    DWORD _reserved_2;
};
typedef struct RimWlanUnregProbeRequestSendReqTag RimWlanUnregProbeRequestSendReq;
struct RimWlanUnregProbeRequestLoopReqTag {
    WORD reqCount;
    WORD reqChannel;
    BYTE reqRate;
    BYTE numIterations;
    WORD iterationDelay;
};
typedef struct RimWlanUnregProbeRequestLoopReqTag RimWlanUnregProbeRequestLoopReq;
struct RimWlanTxGetPowerDbmReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTxGetPowerDbmReqTag RimWlanTxGetPowerDbmReq;
struct RimWlanTxGetPowerDbmCnfTag {
    BYTE success;
    BYTE pwrDbm;
    WORD _reserved;
};
typedef struct RimWlanTxGetPowerDbmCnfTag RimWlanTxGetPowerDbmCnf;
struct RimWlanTxSetPowerDbmReqTag {
    BYTE pwrDbm;
    BYTE _reserved1;
    WORD _reserved2;
};
typedef struct RimWlanTxSetPowerDbmReqTag RimWlanTxSetPowerDbmReq;
struct StpWlanNvsGetChangedTableCountCnfTag {
    BYTE success;
    BYTE changedTableCount;
    WORD _reserved;
};
typedef struct StpWlanNvsGetChangedTableCountCnfTag StpWlanNvsGetChangedTableCountCnf;
struct StpWlanNvsGetChangedTableDiffReqTag {
    BYTE table;
    BYTE _reserved1;
    WORD _reserved2;
};
typedef struct StpWlanNvsGetChangedTableDiffReqTag StpWlanNvsGetChangedTableDiffReq;
struct StpWlanNvsGetChangedTableDiffCnfTag {
    BYTE success;
    BYTE size;
    WORD offset;
    BYTE diff[100];
};
typedef struct StpWlanNvsGetChangedTableDiffCnfTag StpWlanNvsGetChangedTableDiffCnf;
struct RimWlanTiPltInitReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltInitReqTag RimWlanTiPltInitReq;
struct RimWlanTiPltInitCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltInitCnfTag RimWlanTiPltInitCnf;
struct RimWlanTiPltRadioOnReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltRadioOnReqTag RimWlanTiPltRadioOnReq;
struct RimWlanTiPltRadioOnCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltRadioOnCnfTag RimWlanTiPltRadioOnCnf;
struct RimWlanTiPltRadioOffReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltRadioOffReqTag RimWlanTiPltRadioOffReq;
struct RimWlanTiPltRadioOffCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltRadioOffCnfTag RimWlanTiPltRadioOffCnf;
struct RimWlanTiPltRadioGetStateReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltRadioGetStateReqTag RimWlanTiPltRadioGetStateReq;
struct RimWlanTiPltRadioGetStateCnfTag {
    WORD success;
    BYTE radioState;
    BYTE _padding;
};
typedef struct RimWlanTiPltRadioGetStateCnfTag RimWlanTiPltRadioGetStateCnf;
struct RimWlanTiPltRadioResetReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltRadioResetReqTag RimWlanTiPltRadioResetReq;
struct RimWlanTiPltRadioResetCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltRadioResetCnfTag RimWlanTiPltRadioResetCnf;
struct RimWlanTiPltRadioModeSwitchReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltRadioModeSwitchReqTag RimWlanTiPltRadioModeSwitchReq;
struct RimWlanTiPltRadioModeSwitchCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltRadioModeSwitchCnfTag RimWlanTiPltRadioModeSwitchCnf;
struct RimWlanTiPltTxSetPowerLevelReqTag {
    DWORD powerLevel;
};
typedef struct RimWlanTiPltTxSetPowerLevelReqTag RimWlanTiPltTxSetPowerLevelReq;
struct RimWlanTiPltTxSetPowerLevelCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltTxSetPowerLevelCnfTag RimWlanTiPltTxSetPowerLevelCnf;
struct RimWlanTiPltTxGetPowerLevelReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltTxGetPowerLevelReqTag RimWlanTiPltTxGetPowerLevelReq;
struct RimWlanTiPltTxGetPowerLevelCnfTag {
    WORD success;
    WORD _padding;
    DWORD powerLevel;
};
typedef struct RimWlanTiPltTxGetPowerLevelCnfTag RimWlanTiPltTxGetPowerLevelCnf;
struct RimWlanTiPltTxGetGainReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltTxGetGainReqTag RimWlanTiPltTxGetGainReq;
struct RimWlanTiPltTxGetGainCnfTag {
    WORD success;
    WORD _padding;
    DWORD gain;
    DWORD upperGain;
    DWORD lowerGain;
};
typedef struct RimWlanTiPltTxGetGainCnfTag RimWlanTiPltTxGetGainCnf;
struct RimWlanTiPltTxAdjustGainReqTag {
    SDWORD gainAdjust;
};
typedef struct RimWlanTiPltTxAdjustGainReqTag RimWlanTiPltTxAdjustGainReq;
struct RimWlanTiPltTxAdjustGainCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltTxAdjustGainCnfTag RimWlanTiPltTxAdjustGainCnf;
struct RimWlanTiPltTxDisableReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltTxDisableReqTag RimWlanTiPltTxDisableReq;
struct RimWlanTiPltTxDisableCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltTxDisableCnfTag RimWlanTiPltTxDisableCnf;
struct RimWlanTiPltTxCalStartReqTag {
    BYTE refTxPower;
    BYTE _padding;
    WORD _reserved;
};
typedef struct RimWlanTiPltTxCalStartReqTag RimWlanTiPltTxCalStartReq;
struct RimWlanTiPltTxCalStartCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltTxCalStartCnfTag RimWlanTiPltTxCalStartCnf;
struct RimWlanTiPltTxCalStopReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltTxCalStopReqTag RimWlanTiPltTxCalStopReq;
struct RimWlanTiPltTxCalStopCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltTxCalStopCnfTag RimWlanTiPltTxCalStopCnf;
struct RimWlanTiPltTxCarrierWaveReqTag {
    DWORD channel;
    DWORD band;
};
typedef struct RimWlanTiPltTxCarrierWaveReqTag RimWlanTiPltTxCarrierWaveReq;
struct RimWlanTiPltTxCarrierWaveCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltTxCarrierWaveCnfTag RimWlanTiPltTxCarrierWaveCnf;
struct RimWlanTiPltTxContinuousTransReqTag {
    DWORD channel;
    DWORD bitRate;
};
typedef struct RimWlanTiPltTxContinuousTransReqTag RimWlanTiPltTxContinuousTransReq;
struct RimWlanTiPltTxContinuousTransCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltTxContinuousTransCnfTag RimWlanTiPltTxContinuousTransCnf;
struct RimWlanTiPltTxContArbReqTag {
    WORD channel;
    WORD bitRate;
    WORD interPacketDelay;
    WORD numOfFrames;
    WORD packetLength;
    BYTE seqNumMode;
    BYTE preamble;
};
typedef struct RimWlanTiPltTxContArbReqTag RimWlanTiPltTxContArbReq;
struct RimWlanTiPltRxCalReqTag {
    DWORD expectedRssi;
    DWORD sampleInterval;
    BYTE channel;
    BYTE band;
    WORD sampleSize;
};
typedef struct RimWlanTiPltRxCalReqTag RimWlanTiPltRxCalReq;
struct RimWlanTiPltRxCalCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltRxCalCnfTag RimWlanTiPltRxCalCnf;
struct RimWlanTiPltRadioTuneReqTag {
    DWORD channel;
};
typedef struct RimWlanTiPltRadioTuneReqTag RimWlanTiPltRadioTuneReq;
struct RimWlanTiPltRadioTuneCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltRadioTuneCnfTag RimWlanTiPltRadioTuneCnf;
struct RimWlanTiPltRxTxCalNvsUpdateBufferReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltRxTxCalNvsUpdateBufferReqTag RimWlanTiPltRxTxCalNvsUpdateBufferReq;
struct RimWlanTiPltRxTxCalNvsUpdateBufferCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltRxTxCalNvsUpdateBufferCnfTag RimWlanTiPltRxTxCalNvsUpdateBufferCnf;
struct RimWlanTiPltRxPerStartReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltRxPerStartReqTag RimWlanTiPltRxPerStartReq;
struct RimWlanTiPltRxPerStartCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltRxPerStartCnfTag RimWlanTiPltRxPerStartCnf;
struct RimWlanTiPltRxPerStopReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltRxPerStopReqTag RimWlanTiPltRxPerStopReq;
struct RimWlanTiPltRxPerStopCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltRxPerStopCnfTag RimWlanTiPltRxPerStopCnf;
struct RimWlanTiPltRxPerClearReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltRxPerClearReqTag RimWlanTiPltRxPerClearReq;
struct RimWlanTiPltRxPerClearCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltRxPerClearCnfTag RimWlanTiPltRxPerClearCnf;
struct RimWlanTiPltRxPerGetResultsReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltRxPerGetResultsReqTag RimWlanTiPltRxPerGetResultsReq;
struct RimWlanTiPltRxPerGetResultsCnfTag {
    WORD success;
    WORD _padding;
    WORD errorCount;
    WORD totalFrameCount;
};
typedef struct RimWlanTiPltRxPerGetResultsCnfTag RimWlanTiPltRxPerGetResultsCnf;
struct RimWlanTiPltGetRssiReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltGetRssiReqTag RimWlanTiPltGetRssiReq;
struct RimWlanTiPltGetRssiCnfTag {
    WORD success;
    WORD _padding;
    DWORD rssiValue;
};
typedef struct RimWlanTiPltGetRssiCnfTag RimWlanTiPltGetRssiCnf;
struct RimWlanTiPltReadMibReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltReadMibReqTag RimWlanTiPltReadMibReq;
struct RimWlanTiPltReadMibCnfTag {
    WORD success;
    WORD _padding;
    DWORD mibElement;
    DWORD length;
    DWORD data;
};
typedef struct RimWlanTiPltReadMibCnfTag RimWlanTiPltReadMibCnf;
struct RimWlanTiPltWriteMibReqTag {
    DWORD mibElement;
    DWORD length;
    DWORD data;
};
typedef struct RimWlanTiPltWriteMibReqTag RimWlanTiPltWriteMibReq;
struct RimWlanTiPltWriteMibCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimWlanTiPltWriteMibCnfTag RimWlanTiPltWriteMibCnf;
struct RimWlanTiPltGetSnrReqTag {
    DWORD _reserved;
};
typedef struct RimWlanTiPltGetSnrReqTag RimWlanTiPltGetSnrReq;
struct RimWlanTiPltGetSnrCnfTag {
    WORD success;
    WORD _padding;
    DWORD snrValue;
};
typedef struct RimWlanTiPltGetSnrCnfTag RimWlanTiPltGetSnrCnf;
struct RimFtUtcTag {
    TIME time;
    BYTE success;
    BYTE _paddiing;
};
typedef struct RimFtUtcTag RimFTUtcAccess;
enum RimSTPHWVAccessTag {
    STP_HWV_APPEND = 2,
    STP_HWV_READ = 1,
    STP_HWV_ADD = 0
};
typedef enum RimSTPHWVAccessTag RimSTPHWVTableAccess;
struct RimHWVTableAccessTag {
    BYTE AccessType;
    BYTE HWVTableClass;
    BYTE HWVTableData;
    BYTE _padding2;
    BYTE success;
    BYTE _padding[3];
};
typedef struct RimHWVTableAccessTag RimHWVTableAccess;
struct RimSTPDeviceFeatureTag {
    DEVICE_HARDWARE_CAPABILITY eFeature;
};
typedef struct RimSTPDeviceFeatureTag RimCalDeviceFeatureReq;
struct RimSTPBacklightCalTag {
    DWORD brightness;
    BYTE read_write;
    BYTE backlight_type;
    BYTE success;
    BYTE _padding;
};
typedef struct RimSTPBacklightCalTag RimSTPBacklightCal;
struct RimSTPBacklightTimeoutCalTag {
    DWORD timeout;
    BYTE read_write;
    BYTE backlight_type;
    BYTE success;
    BYTE _padding;
};
typedef struct RimSTPBacklightTimeoutCalTag RimSTPBacklightTimeoutCal;
typedef enum {
    BKLT_STP_OP_BSBT_SET = 14,
    BKLT_STP_OP_BSBT_LIST = 13,
    BKLT_STP_OP_BSBT_COMMIT = 12,
    BKLT_STP_OP_BSBT_CLEAR_ALL = 11,
    BKLT_STP_OP_BSBT_CLEAR = 10,
    BKLT_STP_OP_BSBT_CANCEL = 9,
    BKLT_STP_OP_BSBT_BEGIN = 8,
    BKLT_STP_OP_BSBT_ADJUST = 7,
    BKLT_STP_OP_DELETE_NVRAM = 6,
    BKLT_STP_OP_END_TUNING = 5,
    BKLT_STP_OP_SET_TUNING_POINT_ENABLED = 4,
    BKLT_STP_OP_BEGIN_TUNING_POINT = 3,
    BKLT_STP_OP_SET_TUNING_POINT = 2,
    BKLT_STP_OP_GET_TUNING_POINT = 1,
    BKLT_STP_OP_UNKNOWN = 0
} BkltStpOperation_t;
struct STPBacklightAccessReqTag {
    BYTE operation;
    BYTE _padding0[3];
    DWORD backlightDomain;
    DWORD backlightType;
    DWORD bkltValue;
    BYTE calibrationPoint;
    BYTE _padding1[3];
};
typedef struct STPBacklightAccessReqTag STPBacklightAccessReq;
struct RimSTPBacklightAccessCnfTag {
    BYTE success;
    BYTE _padding[3];
    DWORD bkltValue;
};
typedef struct RimSTPBacklightAccessCnfTag RimSTPBacklightAccessCnf;
struct RimCalWordDataCnfTag {
    DWORD data;
};
typedef struct RimCalWordDataCnfTag RimCalGetWordCnf;
struct RimCalGetNoBatNCnfTag {
    WORD line_state;
    WORD status;
};
typedef struct RimCalGetNoBatNCnfTag RimCalGetNoBatNCnf;
typedef enum {
    OS_HW_VERSION = 1,
    BOOTROM_HW_VERSION = 0
} HwVersionType;
typedef enum {
    HWV_OLD_METRICS_DATA = 2,
    HWV_UNKNOWN_TYPE = 1,
    HWV_SUCCESS = 0
} HwVersionStatus;
struct RimCalGetHwVersionReqTag {
    BYTE hw_version_type;
    BYTE _padding;
    WORD _padding2;
};
typedef struct RimCalGetHwVersionReqTag RimCalGetHwVersionReq;
struct RimCalGetHwVersionCnfTag {
    BYTE status;
    BYTE _padding;
    WORD num_entries;
    union {
        HW_VERSION_TAG__BOOTROM bootrom[10];
        HW_VERSION_TAG__OS os[20];
    } hwv;
};
typedef struct RimCalGetHwVersionCnfTag RimCalGetHwVersionCnf;
struct RimCalStartCallReqTag {
    char phoneNumber[32];
};
typedef struct RimCalStartCallReqTag RimCalStartCallReq;
struct RimCalStartCallCnfTag {
    SWORD callIdentifier;
    BYTE success;
    BYTE _padding;
};
typedef struct RimCalStartCallCnfTag RimCalStartCallCnf;
struct RimCalStopCallReqTag {
    SWORD callIdentifier;
    WORD _padding;
};
typedef struct RimCalStopCallReqTag RimCalStopCallReq;
struct RimCalUnsupportedCommandCnfTag {
    WORD errorType;
    WORD commandCode;
    BYTE securityGroupRequiredIdx;
    BYTE _padding[3];
};
typedef struct RimCalUnsupportedCommandCnfTag RimCalUnsupportedCommandCnf;
typedef enum {
    CAL_NETWORK_MODE_INVALID = 255,
    CAL_NETWORK_MODE_WCDMA = 7,
    CAL_NETWORK_MODE_CDMA_EVDO = 6,
    CAL_NETWORK_MODE_GSM = 5,
    CAL_NETWORK_MODE_CDMA_ONLY = 4,
    CAL_NETWORK_MODE_EVDO_ONLY = 3,
    CAL_NETWORK_MODE_CDMA_EVDO_HYBRID_OFF = 2,
    CAL_NETWORK_MODE_GLOBAL = 1
} CalNetworkModePref;
struct RimCalGetNetworkModePrefReqTag {
    DWORD _padding0;
};
typedef struct RimCalGetNetworkModePrefReqTag RimCalGetNetworkModePrefReq;
struct RimCalGetNetworkModePrefCnfTag {
    BYTE mode;
    BYTE success;
    WORD _padding1;
};
typedef struct RimCalGetNetworkModePrefCnfTag RimCalGetNetworkModePrefCnf;
struct RimCalSetNetworkModePrefReqTag {
    BYTE mode;
    BYTE _padding0;
    WORD _padding1;
};
typedef struct RimCalSetNetworkModePrefReqTag RimCalSetNetworkModePrefReq;
struct RimCalSetNetworkModePrefCnfTag {
    BYTE success;
    BYTE _padding0;
    WORD _padding1;
};
typedef struct RimCalSetNetworkModePrefCnfTag RimCalSetNetworkModePrefCnf;
struct RimCalAccessFtmDmssModeReqTag {
    BYTE set;
    BYTE mode;
    WORD _padding;
};
typedef struct RimCalAccessFtmDmssModeReqTag RimCalAccessFtmDmssModeReq;
struct RimCalAccessFtmDmssModeCnfTag {
    BYTE mode;
    BYTE success;
    WORD _padding;
};
typedef struct RimCalAccessFtmDmssModeCnfTag RimCalAccessFtmDmssModeCnf;
struct RimCalAnswerCallReqTag {
    SWORD callIdentifier;
    WORD _padding;
};
typedef struct RimCalAnswerCallReqTag RimCalAnswerCallReq;
struct RimCalAnswerCallCnfTag {
    SWORD callIdentifier;
    BYTE success;
    BYTE _padding;
};
typedef struct RimCalAnswerCallCnfTag RimCalAnswerCallCnf;
struct RimCalGetEsnCnfTag {
    DWORD esn;
    BYTE success;
    BYTE _padding;
    WORD _padding1;
};
typedef struct RimCalGetEsnCnfTag RimCalGetEsnCnf;
struct RimCalSetEsnReqTag {
    DWORD esn;
};
typedef struct RimCalSetEsnReqTag RimCalSetEsnReq;
struct RimCalGetRssiCnfTag {
    WORD rssi;
    WORD fractional;
};
typedef struct RimCalGetRssiCnfTag RimCalGetRssiCnf;
struct RimCalGetRadioOnOffReqTag {
    DWORD _padding;
};
typedef struct RimCalGetRadioOnOffReqTag RimCalGetRadioOnOffReq;
struct RimCalGetRadioOnOffCnfTag {
    BYTE on;
    BYTE _padding[3];
};
typedef struct RimCalGetRadioOnOffCnfTag RimCalGetRadioOnOffCnf;
typedef enum {
    NETWORK_NAME_OVERRIDE = 1,
    RADIO_FEATURES = 0
} CustomInfoID;
struct RimCalGetCustomInfoReqTag {
    BYTE id;
    BYTE index;
    BYTE _padding[2];
};
typedef struct RimCalGetCustomInfoReqTag RimCalGetCustomInfoReq;
struct RimCalGetCustomInfoCnfTag {
    BYTE id;
    BYTE success;
    BYTE _padding[2];
    BYTE data[3000];
};
typedef struct RimCalGetCustomInfoCnfTag RimCalGetCustomInfoCnf;
struct RimCalSetCustomInfoReqTag {
    BYTE id;
    BYTE _padding[3];
    BYTE data[3000];
};
typedef struct RimCalSetCustomInfoReqTag RimCalSetCustomInfoReq;
struct RimCalSetCustomInfoCnfTag {
    BYTE id;
    BYTE success;
    BYTE _padding[2];
};
typedef struct RimCalSetCustomInfoCnfTag RimCalSetCustomInfoCnf;
struct RimCalAudioAccessAvpReqTag {
    BYTE set;
    BYTE chunkCount;
    BYTE chunkTotal;
    BYTE _padding;
    WORD length;
    BYTE _padding2[2];
    BYTE data[3072];
};
typedef struct RimCalAudioAccessAvpReqTag RimCalAudioAccessAvpReq;
struct RimCalAudioAccessAvpCnfTag {
    BYTE success;
    BYTE chunkTotal;
    WORD length;
    BYTE data[3072];
};
typedef struct RimCalAudioAccessAvpCnfTag RimCalAudioAccessAvpCnf;
struct RimSetAudioTrimmingReqTag {
    BYTE mic_mVrms;
    BYTE mic_delta;
    BYTE receiver_mVrms;
    BYTE receiver_delta;
};
typedef struct RimSetAudioTrimmingReqTag RimSetAudioTrimmingReq;
struct RimGetAudioTrimmingCnfTag {
    BYTE success;
    BYTE mic_mVrms;
    BYTE mic_delta;
    BYTE receiver_mVrms;
    BYTE receiver_delta;
    BYTE _padding[3];
};
typedef struct RimGetAudioTrimmingCnfTag RimGetAudioTrimmingCnf;
struct STPAccessVClickReqTag {
    BYTE command;
    BYTE subCommand;
    BYTE set;
    BYTE _padding;
    SDWORD value;
};
typedef struct STPAccessVClickReqTag STPAccessVClickReq;
struct STPAccessVClickCnfTag {
    BYTE result;
    BYTE _padding[3];
    SDWORD value;
};
typedef struct STPAccessVClickCnfTag STPAccessVClickCnf;
struct RimCalAccessSvpReqTag {
    BYTE operation;
    BYTE location;
    BYTE chunkCount;
    BYTE chunkTotal;
    WORD chunkSize;
    WORD partType;
    DWORD mfgLoadingId;
    BYTE data[3072];
};
typedef struct RimCalAccessSvpReqTag RimCalAccessSvpReq;
struct RimCalAccessSvpCnfTag {
    BYTE success;
    BYTE chunkTotal;
    WORD chunkSize;
    DWORD mfgLoadingId;
    BYTE data[3072];
};
typedef struct RimCalAccessSvpCnfTag RimCalAccessSvpCnf;
struct RimCalWipeCalDataReqTag {
    DWORD reserved1;
    DWORD reserved2;
    DWORD reserved3;
    DWORD reserved4;
};
typedef struct RimCalWipeCalDataReqTag RimCalWipeCalDataReq;
struct RimCalWipeCalDataCnfTag {
    BYTE success;
    BYTE padding[3];
};
typedef struct RimCalWipeCalDataCnfTag RimCalWipeCalDataCnf;
struct StpToggleViewfinderReqTag {
    BYTE viewfinderEnable;
    BYTE _padding[3];
};
typedef struct StpToggleViewfinderReqTag StpToggleViewfinderReq;
struct RimFtCamTakePictureReqTag {
    BYTE displayId;
    BYTE padding[3];
};
typedef struct RimFtCamTakePictureReqTag RimFtCamTakePictureReq;
struct RimFtCamTakePictureCnfTag {
    WORD success;
    WORD wide;
    WORD high;
    WORD _padding;
};
typedef struct RimFtCamTakePictureCnfTag RimFtCamTakePictureCnf;
struct RimFtCamGetPictureReqTag {
    DWORD offset;
};
typedef struct RimFtCamGetPictureReqTag RimFtCamGetPictureReq;
struct RimFtCamGetPictureCnfTag {
    WORD dataSize;
    WORD success;
    BYTE picBuff[3000];
};
typedef struct RimFtCamGetPictureCnfTag RimFtCamGetPictureCnf;
struct StpCamGetIdCnfTag {
    BOOL success;
    char idString[64];
    BYTE regValue;
    BYTE _padding[3];
};
typedef struct StpCamGetIdCnfTag StpCamGetIdCnf;
struct RimFtSetFlashTrchReqTag {
    BYTE ledEnable;
    BYTE trchMode;
    WORD _padding;
};
typedef struct RimFtSetFlashTrchReqTag RimFtSetFlashTrchReq;
struct RimFtSetFlashTrchCnfTag {
    WORD success;
    WORD _padding;
};
typedef struct RimFtSetFlashTrchCnfTag RimFtSetFlashTrchCnf;
typedef enum {
    FLASH_LED_ADC_OVER_4100 = 7,
    FLASH_LED_ADC_3950_TO_4100 = 6,
    FLASH_LED_ADC_3800_TO_3950 = 5,
    FLASH_LED_ADC_3650_TO_3800 = 4,
    FLASH_LED_ADC_3500_TO_3650 = 3,
    FLASH_LED_ADC_3350_TO_3500 = 2,
    FLASH_LED_ADC_3200_TO_3350 = 1,
    FLASH_LED_ADC_UNDER_3200 = 0
} RimFlashTrchAdcRange;
struct RimFtGetFlashTrchStatCnfTag {
    BYTE ledFailure;
    BYTE overtemp;
    BYTE adcReading;
    BYTE _padding;
};
typedef struct RimFtGetFlashTrchStatCnfTag RimFtGetFlashTrchStatCnf;
struct _CamPixelStats {
    BYTE redAvg;
    BYTE greenAvg;
    BYTE blueAvg;
    BYTE redMax;
    BYTE greenMax;
    BYTE blueMax;
    BYTE redMin;
    BYTE greenMin;
    BYTE blueMin;
};
typedef struct _CamPixelStats CamPixelStats;
struct RimFtGetRGBAvgCnfTag {
    BYTE success;
    CamPixelStats pixelStats;
    WORD _padding;
};
typedef struct RimFtGetRGBAvgCnfTag RimFtGetRGBAvgCnf;
struct RimFtGetRGBAvgFlashOnReqTag {
    BYTE displayId;
    BYTE padding[3];
};
typedef struct RimFtGetRGBAvgFlashOnReqTag RimFtGetRGBAvgFlashOnReq;
struct RimFtGetRGBAvgFlashOnCnfTag {
    BYTE success;
    CamPixelStats pixelStats;
    WORD current;
    BYTE overtemp;
    BYTE adcReading;
    BYTE ledFailure;
    BYTE _padding;
};
typedef struct RimFtGetRGBAvgFlashOnCnfTag RimFtGetRGBAvgFlashOnCnf;
typedef enum {
    AUTOFOCUS_INFINITY = 1,
    AUTOFOCUS_MACRO = 0
} AutofocusPositionTypes;
struct StpCamSetAutofocusReqTag {
    BYTE afEnable;
    BYTE mode;
    WORD _padding;
};
typedef struct StpCamSetAutofocusReqTag StpCamSetAutofocusReq;
struct RimUsbMsFeatureReqTag {
    DWORD flagSetMask;
    DWORD flagSetValues;
};
typedef struct RimUsbMsFeatureReqTag RimUsbMsFeatureReq;
struct RimUsbMsFeatureCnfTag {
    DWORD errorcode;
    DWORD flagCurValues;
};
typedef struct RimUsbMsFeatureCnfTag RimUsbMsFeatureCnf;
typedef enum {
    MMC_NUM_PARTITIONS = 2,
    MMC_PARTITION_SECONDARY = 1,
    MMC_PARTITION_PRIMARY = 0
} RimUsbMsMMCPartitionNumber;
typedef enum {
    USB_FEATURE_VSP = 8,
    USB_FEATURE_MTP = 4,
    USB_FEATURE_MS = 2,
    USB_FEATURE_BB = 1
} RimUsbFeature;
struct RimUsbSwitchUsbCoreReqTag {
    DWORD usbCore;
};
typedef struct RimUsbSwitchUsbCoreReqTag RimUsbSwitchCoreReq;
struct RimUsbAntiochCrcTestTag {
    BYTE buffer[2044];
};
typedef struct RimUsbAntiochCrcTestTag RimUsbAntiochCrcTestReq;
struct RimSDCardMfgInfoReqTag {
    SDCardType type;
    SDPort port;
};
typedef struct RimSDCardMfgInfoReqTag RimSDCardMfgInfoReq;
struct RimSDCardMfgInfoCnfTag {
    WORD success;
    BYTE SDSpecVersion;
    BYTE SDSecurityVersion;
    BYTE revisionMajor;
    BYTE revisionMinor;
    BYTE manufacturerID;
    char productName[5];
    DWORD numSectors;
    DWORD mfgSpecificData;
    DWORD serialNum;
    WORD applicationID;
    WORD mfgYear;
    BYTE mfgMonth;
    BYTE _padding[3];
    DWORD sectorSize;
};
typedef struct RimSDCardMfgInfoCnfTag RimSDCardMfgInfoCnf;
typedef enum {
    NUM_FAT_FS_IMAGE_COMMANDS = 8,
    FAT_FS_IMAGE_GET_FS_HASH = 7,
    FAT_FS_IMAGE_WIPE_MEDIUM = 6,
    FAT_FS_IMAGE_RESIZE_MEDIUM = 5,
    FAT_FS_IMAGE_READ = 4,
    FAT_FS_IMAGE_WRITE = 3,
    FAT_FS_IMAGE_CLOSE = 2,
    FAT_FS_IMAGE_OPEN = 1
} FATFSImageCommand;
typedef enum {
    NUM_FAT_FS_IMAGE_STATUS = 2,
    FAT_FS_IMAGE_STATUS_FAILED = 1,
    FAT_FS_IMAGE_STATUS_OK = 0
} FATFSImageStatus;
typedef enum {
    NUM_MEDIUM_TYPES = 4,
    MEDIUM_TYPE_NAND = 3,
    MEDIUM_TYPE_SDCARD = 2,
    MEDIUM_TYPE_MMC = 1
} FATFSImageMediumType;
typedef enum {
    NUM_PARTITIONS = 3,
    PARTITION_TWO = 2,
    PARTITION_ONE = 1,
    PARTITION_NONE = 0
} FATFSImagePartition;
struct RimFATFSImageReqTag {
    DWORD command;
    WORD mediumType;
    WORD partition;
    DWORD startSectorNum;
    DWORD numSectors;
    BYTE data[15872];
};
typedef struct RimFATFSImageReqTag RimFATFSImageReq;
struct RimFATFSImageCnfTag {
    DWORD status;
    DWORD numSectors;
    BYTE data[15872];
};
typedef struct RimFATFSImageCnfTag RimFATFSImageCnf;
typedef enum {
    SDMMC_CMD_FAKE_SDCARD_PRESENCE = 0
} SDMMCSubCommand;
typedef enum {
    SDMMC_PARAM_FAKE_SDCARD_REMOVE = 1,
    SDMMC_PARAM_FAKE_SDCARD_INSERT = 0
} SDMMCSubCommandParam;
typedef enum {
    SDMMC_RET_CMD_UNSUPPORTED = 3,
    SDMMC_RET_INVALID_PARAMETER = 2,
    SDMMC_RET_SUCCESS = 1,
    SDMMC_RET_FAILURE = 0
} SDMMCSubCommandReturn;
typedef enum {
    GPSSTPCMD_QC_STANDALONE_GET_RESULT = 131074,
    GPSSTPCMD_QC_STANDALONE_STOP = 131073,
    GPSSTPCMD_QC_STANDALONE_START = 131072,
    GPSSTPCMD_SIRF_TESTMODE4_GET_RESULT = 65538,
    GPSSTPCMD_SIRF_TESTMODE4_STOP = 65537,
    GPSSTPCMD_SIRF_TESTMODE4_START = 65536,
    GPSSTPCMD_GET_FIRMWARE_VERSION_STRING = 0
} GpsStpSubCommand;
typedef enum {
    GPSSTPERROR_TEST_NO_RESULT_AVAILABLE = 65538,
    GPSSTPERROR_TEST_IN_PROGRESS = 65537,
    GPSSTPERROR_TEST_NOT_STARTED = 65536,
    GPSSTPERROR_INVALID_GPS_RESPONSE = 3,
    GPSSTPERROR_INVALID_PARAMETERS = 2,
    GPSSTPERROR_FAILURE = 1,
    GPSSTPERROR_SUCCESS = 0
} GpsStpErrorCode;
typedef struct {
    char string[128];
} GpsStpFirmwareVersionStringCnf;
typedef struct {
    DWORD svid;
    DWORD duration;
} GpsStpSirfTestMode4StartReq;
typedef struct {
    DWORD svid;
    DWORD period;
    DWORD bitSyncTime1;
    DWORD bitCount1;
    DWORD poorStatus1;
    DWORD goodStatus1;
    DWORD parityErrorCount1;
    DWORD lostVCOCount1;
    DWORD frameSyncTime1;
    DWORD cNoMean;
    DWORD cNoSigma;
    DWORD clockDrift;
    DWORD clockOffset;
    DWORD bad1KhzBitCount1;
    DWORD absI20ms2;
    DWORD absQ1ms2;
    DWORD phaseLockIndicator;
    DWORD rtcFrequency;
    DWORD eclkRatio;
    DWORD tSyncBitState;
    DWORD agc;
    DWORD reserved;
} GpsStpSirfTestMode4GetResultCnf;
typedef struct {
    DWORD svid;
    DWORD numResults;
    DWORD cNoMin;
    DWORD cNoMax;
} GpsStpQcStandaloneGetResultCnf;
typedef struct {
    DWORD subCommand;
    union {
        GpsStpSirfTestMode4StartReq sirfTestMode4Start;
        DefaultSignal qcStandaloneStart;
    } data;
} RimFtGpsStpReq;
typedef struct {
    DWORD subCommand;
    DWORD errorCode;
    union {
        GpsStpSirfTestMode4GetResultCnf sirfTestMode4GetResult;
        GpsStpQcStandaloneGetResultCnf qcStandaloneGetResult;
        GpsStpFirmwareVersionStringCnf firmwareVersionString;
    } data;
} RimFtGpsStpCnf;
typedef enum {
    NUM_SUPPORTED_FEATURES = 4,
    EXT_AUDIO_CAL_TABLES = 3,
    EXT_CAL_TEST_STATUS = 2,
    BRANDING_FILE_CHUNK_ACCESS = 1,
    CAL_NVRAM_ITEM_EMPTY = 0
} SupportedFeatureList;
enum SerialModeTag {
    ECHO_MODE = 1,
    STP_MODE = 0
};
typedef enum SerialModeTag SerialMode;
enum AudioPortTag {
    INT_TELECOIL = 8,
    BT_MIC = 7,
    BT_SPK = 6,
    HEADSET_MIC = 5,
    HEADSET_SPK = 4,
    EXT_MIC = 3,
    EXT_SPK = 2,
    INT_MIC = 1,
    INT_SPK = 0
};
typedef enum AudioPortTag AudioPort;
enum CalDataIdtag {
    CAL_LAST_ENTRY = 41,
    CAL_CFBATTERYTEMP = 40,
    CAL_CFTCXOTEMP = 39,
    CAL_CFCHARGERTEMP = 38,
    CAL_CFVAMPADCVALUE = 29,
    CAL_CF1_2VINTREFCALWORD = 23
};
typedef enum CalDataIdtag CalDataId;
enum AdcValueTypeTag {
    ADC_INVALID = 255,
    STPADC_DEPRECATED_2 = 24,
    STPADC_DEPRECATED_1 = 23,
    STPADC_LIGHTSENSOR_EXTERNAL = 22,
    STPADC_BATID = 21,
    STPADC_GPS_TEMP = 20,
    STPADC_CHARGER_TEMP = 19,
    STPADC_VSYS = 18,
    STPADC_VRTC = 17,
    STPADC_LIGHTSENSOR = 16,
    STPADC_RADIO_TEMP = 15,
    ADC_MIC_BT = 14,
    ADC_MIC_HEADSET = 13,
    ADC_EL_AUDIO_DET = 12,
    ADC_EL_PA_V_SENS = 11,
    ADC_EL_PA_I_SENS = 10,
    ADC_EL_BATT_ID1 = 9,
    ADC_EL_THERM2 = 8,
    ADC_EL_CHG_MON = 7,
    ADC_EL_THERM = 6,
    ADC_EL_VBATT = 5,
    ADC_EL_HEADSET_SW = 4,
    ADC_EL_HEADSET_DET = 3,
    ADC_MIC = 2,
    ADC_TEMP = 1,
    ADC_VAMP = 0
};
typedef enum AdcValueTypeTag AdcValueType;
typedef enum {
    FORMAT_MMC_SEC = 16,
    FORMAT_MMC_PRI = 15,
    VERIFY_MMC_ND = 14,
    VERIFY_SD_CONNECTION = 13,
    VERIFY_SD_CARD_ND = 12,
    FORMAT_SD_CARD = 11,
    VERIFY_SD_CARD = 10,
    INIT_AUDIO_VIB_DRIVER = 9,
    READ_CONTROL_SIGNALS = 8,
    CLR_CONTROL_SIGNALS = 7,
    SET_CONTROL_SIGNALS = 6,
    WRITE_ID = 5,
    READ_ID = 4,
    VERIFY_RAM = 3,
    VERIFY_FLASH = 2,
    CAL_SET = 1,
    CAL_ON = 1,
    CAL_CLR = 0,
    CAL_OFF = 0
} DcCommand;
typedef enum {
    MEID = 23,
    BARCODE_ID = 22,
    OS_METRICS_VERSION = 21,
    RADIOCODE_LINKED_ID = 20,
    WLAN_MAC = 19,
    BLUETOOTH_MAC = 18,
    BOOTROM_ID = 17,
    HW_STRING = 16,
    IMEI_BARYON_GW = 15,
    HW_BOARD_REV = 14,
    SIM_ID_BARYON = 13,
    PATRIOT_BINARY_VER = 12,
    MSN_BARYON = 11,
    BSN_BARYON_RADIO = 10,
    SIM_IMSI = 9,
    SIM_ICCID = 8,
    HW_FREQ_MAP = 7,
    HW_PLATFORM_ID = 6,
    OS_VERSION_ID = 5,
    BBPIN = 4,
    IMEI = 3,
    BSN = 2
} DcIdType;
typedef enum {
    ID_NOT_READY = 5,
    UNAVAILABLE_ID = 4,
    UNKNOWN_ID_TYPE = 3,
    UNKNOWN_ACCESS_TYPE = 2,
    DC_FAIL = 1,
    DC_PASS = 0
} DcErrorCode;
struct RimFtNvramBitFlagReqTag {
    DWORD flagType;
    WORD writeFlag;
    WORD setStatus;
};
typedef struct RimFtNvramBitFlagReqTag RimFtNvramBitFlagReq;
struct RimFtNvramBitFlagCnfTag {
    WORD flagState;
    WORD failed;
};
typedef struct RimFtNvramBitFlagCnfTag RimFtNvramBitFlagCnf;
typedef enum {
    IDEN_CRYSTAL_SCAN = 4,
    DEVICE_CONFIG = 3,
    FUNCTIONAL_TEST = 2,
    FINAL_TEST = 1,
    BOARD_LEVEL_CAL = 0
} CalTestType;
enum MetricsTypeTag {
    APP_METRICS = 5,
    DSPOS_KERNEL_METRICS = 4,
    DSPOS_METRICS = 3,
    OS_KERNEL_METRICS = 2,
    OS_METRICS = 1,
    BOOTROM_METRICS = 0
};
typedef enum MetricsTypeTag MetricsType;
struct RimGetMetricsReqTag {
    BYTE type;
    BYTE _padding[3];
};
typedef struct RimGetMetricsReqTag RimGetMetricsReq;
struct RimGetMetricsCnfTag {
    WORD success;
    WORD size;
    union {
        BootromMetricsStruct brMetrics;
        MetricsDataStruct osMetrics;
        StrippedMetricsDataStruct dsposMetrics;
        KernelMetricsDataStruct kernelMetrics;
        AppMetricsDataStruct appMetrics;
    } metricsdata;
};
typedef struct RimGetMetricsCnfTag RimGetMetricsCnf;
struct RimCalGetCoverageInfoCnfTag {
    BYTE voiceCoverage;
    BYTE dataCoverage;
    BYTE emergencyOnlyService;
    BYTE _padding;
};
typedef struct RimCalGetCoverageInfoCnfTag RimCalGetCoverageInfoCnf;
enum CommandErrorTypeTag {
    RTAS_PERMISSION_DENIED = 2,
    INVALID_ARGUMENT = 1,
    COMMAND_UNSUPPORTED = 0
};
typedef enum CommandErrorTypeTag CommandErrorType;
struct RimFt2GetDisplayIdReqTag {
    DWORD displayType;
};
typedef struct RimFt2GetDisplayIdReqTag RimFt2GetDisplayIdReq;
struct RimFt2GetDisplayIdCnfTag {
    DWORD displayId;
    BYTE success;
    BYTE padding[3];
};
typedef struct RimFt2GetDisplayIdCnfTag RimFt2GetDisplayIdCnf;
struct RimFt2SetActiveDisplayReqTag {
    BYTE displayId;
    BYTE padding[3];
};
typedef struct RimFt2SetActiveDisplayReqTag RimFt2SetActiveDisplayReq;
struct RimFt2MallocReqTag {
    DWORD numBytes;
};
typedef struct RimFt2MallocReqTag RimFt2MallocReq;
struct RimFt2MallocCnfTag {
    DWORD bufferId;
    BYTE success;
    BYTE padding[3];
};
typedef struct RimFt2MallocCnfTag RimFt2MallocCnf;
struct RimFt2FreeReqTag {
    DWORD bufferId;
};
typedef struct RimFt2FreeReqTag RimFt2FreeReq;
struct RimFt2MemsetReqTag {
    DWORD bufferId;
    DWORD offset;
    DWORD numBytes;
    BYTE value;
    BYTE padding[3];
};
typedef struct RimFt2MemsetReqTag RimFt2MemsetReq;
struct RimFt2MemcpyReqTag {
    DWORD srcBufferId;
    DWORD srcOffset;
    DWORD dstBufferId;
    DWORD dstOffset;
    DWORD numBytes;
};
typedef struct RimFt2MemcpyReqTag RimFt2MemcpyReq;
struct RimFt2WriteToBufferReqTag {
    DWORD bufferId;
    DWORD offset;
    DWORD numBytes;
    BYTE data[3000];
};
typedef struct RimFt2WriteToBufferReqTag RimFt2WriteToBufferReq;
struct RimFt2ReadFromBufferReqTag {
    DWORD bufferId;
    DWORD offset;
    DWORD numBytes;
};
typedef struct RimFt2ReadFromBufferReqTag RimFt2ReadFromBufferReq;
struct RimFt2ReadFromBufferCnfTag {
    BYTE success;
    BYTE padding[3];
    BYTE data[3000];
};
typedef struct RimFt2ReadFromBufferCnfTag RimFt2ReadFromBufferCnf;
struct RimFt2DrawBitmapReqTag {
    WORD bmWidth;
    WORD bmHeight;
    BYTE bmType;
    BYTE padding1;
    WORD srcX;
    WORD srcY;
    WORD width;
    WORD height;
    WORD dstX;
    WORD dstY;
    BYTE displayId;
    BYTE padding2;
    DWORD dataInline;
    DWORD bufferId;
    BYTE data[2048];
};
typedef struct RimFt2DrawBitmapReqTag RimFt2DrawBitmapReq;
typedef enum {
    BIND_FAILED_ALREADY_BOUND = 9,
    BIND_FAILED_PLATFORM_FUSES = 8,
    BIND_FAILED_KEY_FUSES = 7,
    BIND_FAILED_VALIDATION_ERROR = 6,
    BIND_FAILED_HARDWARE_ERROR = 5,
    BIND_FAILED_BAD_BOOT_HEADER = 4,
    BIND_FAILED_OUT_OF_MEMORY = 3,
    BIND_FAILED_INVALID_BOOT_MODE = 2,
    BIND_FAILED_BAD_BOOTROM = 1,
    BIND_OK = 0
} BindProcessorStatus;
struct BugDispReqTag {
    BYTE requestType;
    BYTE readWrite;
    WORD value;
};
typedef struct BugDispReqTag BugDispReq;
struct BugDispCnfTag {
    WORD success;
    WORD result;
};
typedef struct BugDispCnfTag BugDispCnf;
struct NvramVerifySigReqTag {
    DWORD recordNum;
};
typedef struct NvramVerifySigReqTag NvramVerifySigReq;
struct NvramMakeSigReqTag {
    DWORD recordNum;
};
typedef struct NvramMakeSigReqTag NvramMakeSigReq;
typedef enum {
    nvSigReqUnknown = 65535,
    nvSigReqNvNotExist = 3,
    nvSigReqNvTooBig = 2,
    nvSigReqFailed = 1,
    nvSigReqSuccess = 0
} NvRequestResult;
struct NvramMakeSigCnfTag {
    DWORD result;
    WORD challengeLen;
    BYTE restOfChallenge[510];
};
typedef struct NvramMakeSigCnfTag NvramMakeSigCnf;
struct NvramStoreSigReqTag {
    WORD challengeLen;
    WORD sigLen;
};
typedef struct NvramStoreSigReqTag NvramStoreSigReq;
struct NvramRequiredSigsCnfTag {
    DWORD numRecords;
    DWORD requiredRecords;
};
typedef struct NvramRequiredSigsCnfTag NvramRequiredSigsCnf;
struct TestLcdReqTag {
    WORD testId;
    WORD numLoops;
};
typedef struct TestLcdReqTag TestLcdReq;
struct RimSTPRefurbishedFlagReqTag {
    BYTE set;
    BYTE status;
    BYTE _padding[6];
    QWORD currentTime;
};
typedef struct RimSTPRefurbishedFlagReqTag STPRefurbishedFlagReq;
struct RimSTPRefurbishedFlagCnfTag {
    BYTE success;
    BYTE flagValue;
    BYTE _padding[6];
    QWORD setTime;
};
typedef struct RimSTPRefurbishedFlagCnfTag STPRefurbishedFlagCnf;
struct RimAudioLoggingTimersCnfTag {
    DWORD timers[59];
};
typedef struct RimAudioLoggingTimersCnfTag RimAudioLoggingTimersCnf;
struct RimKeyCodeReqTag {
    BYTE events;
    BYTE numberOfKeys;
    BYTE delayBetweenEvents;
    BYTE delayBetweenKeys;
    BYTE keyCodes[32];
};
typedef struct RimKeyCodeReqTag RimKeyCodeReq;
typedef BOOL *funcProcessSTPCommand;
typedef BOOL vbdHandler;
struct _sbdxCmd {
    char token;
    vbdHandler *xCmdHandler;
    DWORD xCmdParam;
};
typedef struct _sbdxCmd tbdxCmd;
typedef struct {
    DWORD version;
    DWORD screenId;
    DWORD idCookie;
    DWORD numItems;
    DWORD numUserItems;
    DWORD numModes;
    DWORD flags;
    char *title;
    int titleLength;
    DWORD accessLevel;
} ESCREEN_INFO;
typedef struct {
    DWORD version;
    DWORD screenId;
    DWORD screenIdCookie;
    DWORD itemId;
    DWORD mode;
    DWORD accessLevel;
} ESCREEN_ITEM;
typedef struct {
    DWORD version;
    DWORD flags;
    DWORD id;
    DWORD idCookie;
} ESCREEN_ITEM_INFO;
typedef struct {
    DWORD version;
    char *buffer;
    int bufferLength;
} ESCREEN_ITEM_DATA;
typedef struct {
    DWORD version;
    DWORD actionId;
    DWORD actionIdCookie;
    char *userData;
    int userDataLength;
} ESCREEN_ACTION;
typedef struct {
    DWORD version;
    DWORD menuId;
    DWORD idCookie;
} ESCREEN_MENU_INFO;
typedef enum {
    RESET_CALLED = 12,
    BATTERY_PULL = 11,
    USER_INITIATED_RESET = 10,
    THREE_G_RESET = 9,
    IDEN_RESET = 8,
    CDMA_RESET = 7,
    MWAF_RESET = 6,
    OS_RESET = 5,
    UMTS_RESET = 4,
    GPRS_RESET = 3,
    WIFI_RESET = 2,
    APPS_RESET = 1,
    UNKNOWN_RESET = 0
} LikelyResetCause;
typedef enum {
    NUM_PERIPHERALS = 29,
    CLOCK_MMC2 = 28,
    CLOCK_MVED = 27,
    CLOCK_TVOUT = 26,
    CLOCK_VBROM = 25,
    CLOCK_ABC = 24,
    CLOCK_NAND = 23,
    CLOCK_CADDO = 22,
    CLOCK_ANTIOCH = 21,
    CLOCK_GRAPHICS = 20,
    CLOCK_GPS = 19,
    CLOCK_FAKE = 18,
    CLOCK_ROLLER = 17,
    CLOCK_MSL = 16,
    CLOCK_SSP4 = 15,
    CLOCK_SSP3 = 14,
    CLOCK_SSP2 = 13,
    CLOCK_SSP1 = 12,
    CLOCK_UART3 = 11,
    CLOCK_UART2 = 10,
    CLOCK_UART1 = 9,
    CLOCK_KEYPAD = 8,
    CLOCK_MMC1 = 7,
    CLOCK_MMC0 = 6,
    CLOCK_CAMERA = 5,
    CLOCK_USIM1 = 4,
    CLOCK_USIM0 = 3,
    CLOCK_LCD = 2,
    CLOCK_I2C = 1,
    CLOCK_USB = 0
} PeripheralClock;
typedef enum {
    CLOCK_GUARD_CRITICALINT = 2,
    CLOCK_GUARD_SEM = 1,
    CLOCK_GUARD_INT = 0
} ClockGuard;
struct ClockTag {
    ClockControlFunction function;
    DWORD param;
    DWORD peripherals;
    ClockGuard guard;
};
typedef struct ClockTag Clock;
struct PeripheralMapTag {
    WORD numClocks;
    Clock *clocks[4];
};
typedef struct PeripheralMapTag PeripheralMap;
typedef struct {
    DWORD RunningClocks;
    DWORD UsedClocks;
} ClockStatsStruct;
typedef struct {
    BOOL bIsProcessorIdle;
} ProcessorState_t;
typedef struct {
    int CatfailCode;
    DWORD ChipID;
    DWORD CoreSharedMemSize;
    DWORD CoreBootFlags;
    DWORD CoreBootRequest;
    DWORD DspLdrStart;
    DWORD DspL1SleepTime[2];
    struct {
        WORD svn;
        WORD _padding;
        DWORD hwCapCache[2];
        DWORD swCapCache;
    } device_info;
} SharedMemStruct;
typedef enum {
    FREQ_CHANGE_BLOCK_NAND = 1,
    FREQ_CHANGE_BLOCK_LCD = 0
} FrequencyChangeBlocker;
typedef enum {
    FREQ_CHANGE_MAX_CAMERA_I2C = 2,
    FREQ_CHANGE_MAX_CAMERA_CLOCK = 1,
    FREQ_CHANGE_MAX_GRAPHICS = 0
} FrequencyChangeMaxer;
typedef enum {
    MAX_CONTROLLERS = 22,
    SECONDARY_INT51 = 21,
    SECONDARY_INT35 = 20,
    SECONDARY_INT17 = 19,
    SECONDARY_INT5 = 18,
    SECONDARY_INT4 = 17,
    IPU_IRQ = 16,
    BDMA_IRQ = 15,
    SDMA_IRQ = 14,
    MU_GP_IRQ = 13,
    REMOTE_MSA_IRQ = 12,
    REMOTE_ARM9_IRQ = 11,
    REMOTE_XSCALE_IRQ = 10,
    WCDMA_HL_IRQ = 9,
    WCDMA_L_IRQ = 8,
    WCDMA_H_IRQ = 7,
    SECONDARY_H_IRQ = 6,
    SECONDARY_L_IRQ = 5,
    GSM_IRQ = 4,
    DMA_IRQ = 3,
    GPIO_IRQ = 2,
    SECONDARY_IRQ = 1,
    PRIMARY_IRQ = 0
} IntController;
typedef DWORD IntId;
typedef DWORD IntPriority;
typedef signed char INT8;
typedef unsigned char UINT8;
typedef char *STRING;
typedef signed short INT16;
typedef unsigned short UINT16;
typedef signed long INT32;
typedef unsigned long UINT32;
typedef signed char INT8E;
typedef unsigned char UINT8E;
typedef signed short INT16E;
typedef unsigned short UINT16E;
typedef signed long INT32E;
typedef unsigned long UINT32E;
typedef unsigned long GSM_SIZE_T;
typedef unsigned int BOOLEAN;
typedef enum {
    size_4G = 31,
    size_2G = 30,
    size_1G = 29,
    size_512M = 28,
    size_256M = 27,
    size_128M = 26,
    size_64M = 25,
    size_32M = 24,
    size_16M = 23,
    size_8M = 22,
    size_4M = 21,
    size_2M = 20,
    size_1M = 19,
    size_512k = 18,
    size_256k = 17,
    size_128k = 16,
    size_64k = 15,
    size_32k = 14,
    size_16k = 13,
    size_8k = 12,
    size_4k = 11
} regionSize;
typedef struct {
    UINT32 index;
    UINT32 tag;
    UINT32 addr;
    UINT32 data;
} CACHE_ENTRY;
typedef enum {
    MMU_Domain15 = 15,
    MMU_Domain14 = 14,
    MMU_Domain13 = 13,
    MMU_Domain12 = 12,
    MMU_Domain11 = 11,
    MMU_Domain10 = 10,
    MMU_Domain9 = 9,
    MMU_Domain8 = 8,
    MMU_Domain7 = 7,
    MMU_Domain6 = 6,
    MMU_Domain5 = 5,
    MMU_Domain4 = 4,
    MMU_Domain3 = 3,
    MMU_Domain2 = 2,
    MMU_Domain1 = 1,
    MMU_Domain0 = 0
} MMUDomain;
typedef enum {
    MMU_Manager = 3,
    MMU_Reserved = 2,
    MMU_Client = 1,
    MMU_NoAccess = 0
} MMUDomainAC;
typedef enum {
    MMU_CacheEnable = 1,
    MMU_CacheDisable = 0
} MMUCacheSet;
typedef enum {
    MMU_WBBufEnable = 1,
    MMU_WBBufDisable = 0
} MMUWriteBackBufferSet;
typedef struct {
    UINT32 MVABeginAddr;
    UINT32 MVAEndAddr;
    UINT32 PhyBeginAddr;
    MMUDomain Domain;
    MMUCacheSet Cache;
    MMUWriteBackBufferSet WBBuf;
} MMUSectionLayout;
typedef struct {
    UINT32 MVABeginAddr;
    UINT32 MVAEndAddr;
    UINT32 PhyBeginAddr;
    MMUDomain Domain;
    MMUCacheSet Cache;
    MMUWriteBackBufferSet WBBuf;
} PageLayout;
typedef struct {
    UINT16 PageLayoutEntries;
    PageLayout *PageLayoutStruct;
} PageStruct;
typedef enum {
    FAST_FREQUENCY = 1,
    SLOW_FREQUENCY = 0
} TickFrequency;
typedef enum {
    N_HSIO_CLKS = 3,
    HSIO_CLK_208 = 2,
    HSIO_CLK_156 = 1,
    HSIO_CLK_104 = 0
} HsioClk;
typedef struct {
    DWORD freq;
    DWORD xl;
    DWORD xn;
    DWORD smcfs;
    DWORD sflfs;
    DWORD vuaf;
    DWORD vuaf_s;
    DWORD hss;
    DWORD dmcfs;
} ProductPointInfo;
typedef enum {
    NUM_TIMERS = 4,
    SLOWCLOCKING_WAKEUP_TIMER = 3,
    EARLY_WATCHDOG_TIMER = 2,
    JVM_TIMESLICE_TIMER = 1,
    NTIMERS_TIMER = 0
} TimerType;
typedef enum {
    BUGDISP_BUFFER_SPEECH = 5,
    BUGDISP_BUFFER_DSP_LP = 4,
    BUGDISP_BUFFER_RADIO_LP = 3,
    BUGDISP_BUFFER_DSP = 2,
    BUGDISP_BUFFER_RADIO = 1,
    BUGDISP_BUFFER_APPS = 0
} BugdispBufferType;
struct DebugTxStruct {
    DWORD ReadIndex;
    DWORD WriteIndex;
    DWORD WrappedAround;
    BYTE bBuffer[131072];
    BYTE TailBuffer[256];
    DWORD Signature;
};
typedef unsigned int GspId;
struct RegisterTypeTag {
    DWORD RegisteredPattern;
    TASK RegisteredTask;
};
typedef struct RegisterTypeTag RegisterType;
struct RimSerialPortTag {
    BOOL HasOwner;
    TASK Owner;
    BYTE Mode;
    BOOL DTR;
    BOOL DSR;
};
typedef struct RimSerialPortTag RimSerialPort;
struct UartGpioTag {
    DWORD UartIndex;
    DWORD UartRxPin;
    DWORD UartTxPin;
    DWORD UartAltMode;
};
typedef struct UartGpioTag UartGpioInfo;
typedef WORD IoTaskTimer;
typedef BYTE BBSubItfTypes;
struct BBSubItfDescriptorTag {
    BYTE bIndex;
    BBSubItfTypes Type;
    BYTE bNumEps;
};
typedef struct BBSubItfDescriptorTag BBSubItfDescriptor;
struct BBItfDescriptorTag {
    WORD wLength;
    WORD bcdVersion;
    BYTE bNumSubItfs;
};
typedef struct BBItfDescriptorTag BBItfDescriptor;
struct BBUSBHostVersionsTag {
    WORD wHostVID;
    WORD wHostPID;
    DWORD dwHostOsVersion;
    DWORD dwHostDriverVersion;
};
typedef struct BBUSBHostVersionsTag BBUSBHostVersions;
typedef struct {
    WORD bcdVersion;
    WORD bmSubItf;
    BYTE size;
    struct {
        WORD a1;
        BYTE a2;
    } align;
} BBNotificationHeader;
typedef struct {
    BBNotificationHeader header;
    BYTE data;
} BBNotificationPacket;
enum UsbChannelTag {
    USB_DEBUG_CONTROL_MSG = 255,
    USB_THREAD_CONTROL_MSG = 254,
    USB_BROADCAST_CONTROL_MSG = 253,
    USB_INVALID_CHANNEL = 4,
    USB_HOST_VERSIONS_CHANNEL = 3,
    USB_MUX_CHANNEL = 2,
    USB_BUGDISP_CHANNEL = 1,
    USB_CONTROL_CHANNEL = 0
};
typedef enum UsbChannelTag UsbChannel;
enum UsbEnumModeTag {
    USB_ENUM_HIGH_POWER = 2,
    USB_ENUM_LOW_POWER = 1,
    USB_ENUM_RE_ENUM = 0
};
typedef enum UsbEnumModeTag UsbEnumMode;
enum UsbPowerLevelTag {
    USB_PWR_HIGH = 250,
    USB_PWR_LOW = 50
};
typedef enum UsbPowerLevelTag UsbPowerLevel;
enum SetupXferStateTag {
    SXS_STATUS = 2,
    SXS_DATA = 1,
    SXS_SETUP = 0
};
typedef enum SetupXferStateTag SetupXferState;
struct UsbBufferTag {
    BYTE *pBuffer;
    DWORD usingSize;
    DWORD allocSize;
};
typedef struct UsbBufferTag UsbBuffer;
struct UsbTransferTag {
    UsbChannel chan;
    UsbBuffer *pBufArray;
    DWORD maxNum;
    BOOL completeXfer;
    UsbChannel sendChan;
};
typedef struct UsbTransferTag UsbTransfer;
struct RimUsbReadPipeTag {
    DWORD buffSize;
    DWORD special_xfer_size;
    DWORD bytes_recvd;
};
typedef struct RimUsbReadPipeTag RimUsbReadPipe;
struct RimUsbWritePipeTag {
    BYTE *pAlignedBuffer;
    DWORD alignedBufSize;
    DWORD cur_buff_idx;
    DWORD cur_buff_offset;
    BOOL end_of_xfer;
    DWORD num_buffers;
    BOOL merging;
    UsbBuffer send_buf_array[2];
    DWORD num_send_bufs;
};
typedef struct RimUsbWritePipeTag RimUsbWritePipe;
struct RimUsbPipeTag {
    BYTE *pBuffer;
    UsbBuffer *pBufArray;
    DWORD buffNum;
    BOOL completeXfer;
    BYTE status;
    BOOL halted;
    BOOL disableClearStallFeature;
    union {
        RimUsbReadPipe read;
        RimUsbWritePipe write;
    } details;
    BOOL channelNotificationPending;
    UsbChannel sourceChannel;
};
typedef struct RimUsbPipeTag RimUsbPipe;
struct UsbSetupReqTag {
    BYTE bmRequestType;
    BYTE bRequest;
    WORD wValue;
    WORD wIndex;
    WORD wLength;
};
typedef struct UsbSetupReqTag UsbSetupReq;
typedef WORD UsbMode;
typedef BYTE UsbSpeed;
typedef BYTE UsbSDOwner;
struct UsbHostVersionsTag {
    WORD wHostVID;
    WORD wHostPID;
    DWORD wHostOSVersion;
    DWORD wHostDriverVersion;
};
typedef struct UsbHostVersionsTag UsbHostVersions;
typedef enum {
    LANGUAGE_CUSTOM = 10000,
    LANGUAGE_MAX = 37,
    LANGUAGE_TURKISH = 36,
    LANGUAGE_HUNGARIAN = 35,
    LANGUAGE_HEBREW = 34,
    LANGUAGE_GREEK = 33,
    LANGUAGE_DANISH = 32,
    LANGUAGE_CZECH = 31,
    LANGUAGE_CATALAN = 30,
    LANGUAGE_ARABIC = 29,
    LANGUAGE_AFRIKAANS = 28,
    LANGUAGE_UKRAINIAN = 27,
    LANGUAGE_POLISH = 26,
    LANGUAGE_JAPANESE = 25,
    LANGUAGE_NORWEGIAN = 24,
    LANGUAGE_SWEDISH = 23,
    LANGUAGE_DUTCH = 22,
    LANGUAGE_ZEHK_SIMPLIFIED = 21,
    LANGUAGE_ZEHK_TRADITIONAL = 20,
    LANGUAGE_MANGLISH_TRADITIONAL = 19,
    LANGUAGE_MANGLISH_SIMPLIFIED = 18,
    LANGUAGE_RUSSIAN = 17,
    LANGUAGE_CANTONESE_SIMPLIFIED = 16,
    LANGUAGE_CANTONESE_TRADITIONAL = 15,
    LANGUAGE_FINNISH = 14,
    LANGUAGE_PORTUGUESE_EUROPEAN = 13,
    LANGUAGE_SPANISH = 12,
    LANGUAGE_ITALIAN = 11,
    LANGUAGE_FRENCH_CANADA = 10,
    LANGUAGE_PORTUGUESE_BRAZIL = 9,
    LANGUAGE_SPANISH_US = 8,
    LANGUAGE_GERMAN = 7,
    LANGUAGE_FRENCH = 6,
    LANGUAGE_ENGLISH_UK = 5,
    LANGUAGE_MANDARIN_TRADITIONAL = 4,
    LANGUAGE_MANDARIN_SIMPLIFIED = 3,
    LANGUAGE_KOREAN = 2,
    LANGUAGE_ENGLISH = 1
} Language_t;
typedef enum {
    FILE_OPERATION_COMMIT = 15,
    FILE_OPERATION_SET_ATTRIB = 14,
    FILE_OPERATION_CHECK_EOF = 13,
    FILE_OPERATION_RM_DIR = 12,
    FILE_OPERATION_MK_DIR = 11,
    FILE_OPERATION_FILE_LOCK = 10,
    FILE_OPERATION_FILE_SEEK = 9,
    FILE_OPERATION_FILE_FIND_NEXT = 8,
    FILE_OPERATION_FILE_FIND_FIRST = 7,
    FILE_OPERATION_DELETE = 6,
    FILE_OPERATION_RENAME = 5,
    FILE_OPERATION_READ = 4,
    FILE_OPERATION_WRITE = 3,
    FILE_OPERATION_CLOSE = 2,
    FILE_OPERATION_OPEN = 1,
    FILE_OPERATION_GET_FS_INFO = 0
} _FILE_OPERATION_TYPE;
typedef unsigned char FILE_OPERATION_TYPE;
typedef enum {
    NUM_FS_TYPES = 6,
    FS_TYPE_RAMDISK = 5,
    FS_TYPE_BUILT_IN_SECONDARY = 4,
    FS_TYPE_INTERNAL_FLASH = 3,
    FS_TYPE_BUILT_IN = 2,
    FS_TYPE_SDCARD = 1,
    FS_TYPE_PATRIOT = 0
} FS_TYPE;
typedef unsigned int FILE_MODE;
typedef unsigned int FILE_ATTRIB;
typedef unsigned int FS_SUPPORT;
typedef unsigned int FS_PARTITION_STATUS;
typedef unsigned int FILE_HANDLE;
typedef enum {
    FILE_SEEK_END = 2,
    FILE_SEEK_RELATIVE = 1,
    FILE_SEEK_ABSOLUTE = 0
} FILE_SEEK_MODE;
typedef unsigned int FILE_SEARCH_MODE;
typedef enum {
    FILE_STATUS_DIRPATH_TOO_LONG = 30,
    FILE_STATUS_FILEPATH_TOO_LONG = 29,
    FILE_STATUS_OUT_OF_MEMORY = 28,
    FILE_STATUS_HANDLE_FORCIBLY_CLOSED = 27,
    FILE_STATUS_FS_IRREPARABLE = 26,
    FILE_STATUS_FILE_BUSY = 25,
    FILE_STATUS_FILE_SYSTEM_UNSUPPORTED = 24,
    FILE_STATUS_INVALID_PARTITION_SIZE = 23,
    FILE_STATUS_FS_VERIFICATION_FAILED = 22,
    FILE_STATUS_FS_NOT_MOUNTED = 21,
    FILE_STATUS_FILE_HANDLES_OPEN = 20,
    FILE_STATUS_FS_ALREADY_MOUNTED = 19,
    FILE_STATUS_MEDIUM_NOT_FORMATTED = 18,
    FILE_STATUS_DIRECTORY_NOT_EMPTY = 17,
    FILE_STATUS_DIRECTORY_NOT_FOUND = 16,
    FILE_STATUS_DIRECTORY_ALREADY_EXISTS = 15,
    FILE_STATUS_DIRECTORY_FULL = 14,
    FILE_STATUS_FILENAME_TOO_LONG = 13,
    FILE_STATUS_INVALID_OPERATION = 12,
    FILE_STATUS_NO_FREE_HANDLES = 11,
    FILE_STATUS_FILESYSTEM_EMPTY = 10,
    FILE_STATUS_FILESYSTEM_FULL = 9,
    FILE_STATUS_FILENAME_NOT_FOUND = 8,
    FILE_STATUS_FILENAME_ALREADY_EXISTS = 7,
    FILE_STATUS_GENERAL_ERROR = 6,
    FILE_STATUS_OS_BUSY = 5,
    FILE_STATUS_FILE_SYSTEM_UNAVAILABLE = 4,
    FILE_STATUS_INVALID_PARAMETER = 3,
    FILE_STATUS_INVALID_HANDLE = 2,
    FILE_STATUS_PENDING = 1,
    FILE_STATUS_SUCCESS = 0
} FILE_STATUS;
typedef struct {
    DWORD version;
    FS_PARTITION_STATUS status;
    QWORD partitionSize;
    QWORD minPartitionSize;
    QWORD mediumSize;
    FS_TYPE primaryFSType;
    BYTE padding[7];
} FS_PARTITION_INFO;
typedef struct {
    DWORD version;
    DWORD minWriteLength;
    DWORD maxWriteLength;
    DWORD minReadLength;
    DWORD maxReadLength;
    DWORD maxFilenameLength;
    QWORD totalSpace;
    QWORD freeSpace;
    DWORD maxOpenHandles;
    FS_SUPPORT featureSupport;
    DWORD maxFilePathLength;
    DWORD maxDirectoryPathLength;
} FS_INFO;
typedef struct {
    DWORD version;
    char *fileName;
    QWORD fileSize;
    QWORD UTCtime;
    FILE_ATTRIB attribute;
    WORD *fileNameW;
    QWORD UTCCreatedTime;
} FILE_INFO;
typedef struct {
    DWORD version;
    QWORD *fileSize;
    QWORD *UTCtime;
    FILE_ATTRIB *attribute;
    DWORD fileArraySize;
    char *nameSpace;
    DWORD nameSpaceSize;
    WORD *nameSpaceW;
    DWORD nameSpaceWSize;
    DWORD readCount;
    QWORD *UTCCreatedTime;
} FILE_INFO_LIST;
typedef struct {
    DWORD version;
    FILE_SEARCH_MODE mode;
} FILE_SEARCH_CRITERIA;
typedef struct {
    DWORD version;
    BOOL saveLostClustersToFiles;
} FS_REPAIR_INFO;
typedef struct {
    WORD Version;
    WORD Length;
    WORD QoS;
    WORD MTU;
    WORD MaxTransmitBuffers;
    WORD MRU;
    WORD MaxReceiveBuffers;
    WORD UselessWord;
} ChannelParameters;
typedef enum {
    USB_SWITCH_NO_VALID_MODE = 15,
    USB_SWITCH_MODE_DISABLED = 14,
    USB_SWITCH_MODE_UNAVAILABLE = 13,
    USB_SWITCH_NO_CHANGE = 12,
    USB_SWITCH_VETOED = 11,
    USB_MS_NOT_AVAILABLE = 10,
    USB_MS_BUSY = 9,
    USB_PARAMETER_ERROR = 8,
    USB_OPEN_OVERFLOW = 7,
    USB_REG_OVERFLOW = 6,
    USB_CHANNEL_BUFFER_OVERFLOW = 5,
    USB_CHANNEL_NAME_ERROR = 4,
    USB_CHANNEL_BUFFER_ERROR = 3,
    USB_CHANNEL_STATE_ERROR = 2,
    USB_CHANNEL_ILLEGAL = 1,
    USB_NO_ERROR = 0
} USB_ERROR_CODE;
typedef enum {
    RIM_NUM_FUNCTIONALITIES = 2,
    RIM_MODEM = 1,
    RIM_HANDHELD = 0
} USB_FUNCTIONALITY;
typedef enum {
    USB_MASS_STORAGE = 2,
    USB_VIRTUAL_SERIAL_PORT = 1,
    USB_BLACKBERRY = 0
} USB_FEATURE;
typedef enum {
    USB_VETO_ALL = 31,
    USB_VETO_BUGDISP = 16,
    USB_VETO_USBMS = 8,
    USB_VETO_CALTASK = 4,
    USB_VETO_VSP2 = 2,
    USB_VETO_VSP1 = 1
} USB_VETO_FUNCTIONS;
typedef enum {
    USB_ENUM_MODE_BBMSMTP = 4,
    USB_ENUM_MODE_BBMS = 1
} USB_ENUM_MODE;
typedef DWORD INT_STATUS;
typedef BYTE LOCK_STATE;
struct UsbDrvPortTag {
    void *ENABLE_XCVER;
    void *DISABLE_XCVER;
    void *ENABLE_USB_OUTPUTS;
    void *DISABLE_USB_OUTPUTS;
    void *SETUP_USB_INTERRUPTS;
    void *UNCONFIG_USB_INTERRUPTS;
    void *ENABLE_USB_INTERRUPTS;
    void *DISABLE_USB_INTERRUPTS;
    void *UsbDrvInit;
    void *UsbDrvUninit;
    void *UsbDrvEnable;
    void *UsbDrvDisable;
    void *UsbDrvInitPeriph;
    void *UsbDrvConfigForAcCharging;
    void *UsbDrvClearCD;
    void *UsbDrvClearInts;
    void *UsbDrvCancelIO;
    void *UsbDrvCancelOutXfer;
    BOOL *UsbDrvInitChannel;
    BOOL *UsbDrvSetupOutPipe;
    BOOL *UsbDrvSetupInPipe;
    void *UsbDrvDisableOutPipe;
    void *UsbDrvDisableInPipe;
    void *UsbDrvShutdown;
    void *UsbDrvDumpRegisters;
    void *UsbDrvStallPipe;
    void *UsbDrvControlSend;
    void *UsbDrvControlSendStatus;
    void *UsbDrvAttach;
    void *UsbDrvDetach;
    WORD *UsbDrvGetCurrentFrame;
    void *UsbDrvConfigureEndpoints;
    void *USB_IRQ_Handler;
    void *UsbDrvUnStallPipe;
    void *UsbDrvSetForceStall;
    BYTE *ConvertEPAntiochToRim;
    UsbChannel *UsbDrvEpToChan;
    void *UsbDrvHandleFailure;
    UsbSpeed *UsbDrvGetOperatingSpeed;
    UsbSpeed *UsbDrvGetMaxOperatingSpeed;
    BOOL *UsbDrvCoreHandlesZLPReads;
    void *UsbDrvCancelChanXfer;
    void *UsbDrvResumeChanXfer;
};
typedef struct UsbDrvPortTag UsbDrvPort;
typedef SWORD MemPool;
enum BatteryStatsTypeTag {
    BATT_STATS_TACHYON = 2,
    BATT_STATS_PROTON = 1,
    BATT_STATS_UNKNOWN = 0
};
typedef enum BatteryStatsTypeTag BatteryStatsType;
struct TachyonBattStatsTag {
    SDWORD batteryFull;
    SDWORD percentCurr;
    SDWORD percentAv;
    SDWORD mvRead;
    SDWORD state;
    SDWORD PmNotified;
    SDWORD wFilterOn;
    SDWORD ssChargedTrend;
    SDWORD tempMax;
    SDWORD tempMin;
    SDWORD tempLastComputed;
    SDWORD timesCharged;
    SDWORD timesDischarged;
    SDWORD timeTempAbove45;
    SDWORD timeTempAbove50;
    SDWORD timeTempBelow0;
};
typedef struct TachyonBattStatsTag TachyonBattStats;
struct BuildInfoTag {
    DWORD ticksFromReset;
    DWORD osVersion;
    DWORD osRevision;
    DWORD osBuildType;
    DWORD osBuild;
    BOOL deviceSecure;
    char buildUserName[16];
    char buildDate[12];
    char buildTime[9];
    BYTE unused[3];
};
typedef struct BuildInfoTag BuildInfo;
struct MemoryInfoTag {
    DWORD totalAllocBytes;
    DWORD numAllocBlocks;
    DWORD totalFreeBytes;
    DWORD numFreeBlocks;
    DWORD largestFreeBlocks[2];
};
typedef struct MemoryInfoTag MemoryInfo;
enum COMM_STATES {
    CS_OPENED_BY_TASK = 2,
    CS_OPENED_BY_DEBUG = 1,
    CS_CLOSED = 0
};
struct CommPortInfoTag {
    BOOL hasOwner;
    DWORD owner;
    DWORD mode;
    BOOL dsrHigh;
    BOOL dtrHigh;
    DWORD numPorts;
    struct {
        DWORD state;
        DWORD txBufferSize;
        DWORD rxBufferSize;
    } ports[4];
    DWORD numRegPatterns;
    DWORD patterns[12];
};
typedef struct CommPortInfoTag CommPortInfo;
typedef enum {
    USB_TERMINATE = 6,
    USB_OPEN = 5,
    USB_AUTHENTICATE_NO_UI = 4,
    USB_AUTHENTICATE = 3,
    USB_ESTABLISH2 = 2,
    USB_ESTABLISH = 1,
    USB_DEAD = 0
} USBChannelState;
struct USBInfoTag {
    DWORD numRegChannels;
    BOOL usbConnected;
    BYTE curAddress;
    BYTE maxUsbPower;
    BYTE unused1[2];
    struct {
        DWORD handle;
        WORD mtu;
        WORD mru;
        WORD maxTb;
        WORD maxRb;
        USBChannelState state;
        char name[16];
        BYTE unused2[3];
    } channels[20];
};
typedef struct USBInfoTag USBInfo;
typedef struct {
    DWORD nextTdPtr;
    DWORD tdToken;
    DWORD bufPtr[5];
    DWORD reserved;
} TD_STRUCT;
typedef enum {
    TRN_TYPE_OUT = 3,
    TRN_TYPE_IN = 2,
    TRN_TYPE_SETUP = 1,
    TRN_TYPE_NONE = 0
} TrnType;
typedef enum {
    NUM_DIR = 2,
    EP_IN = 1,
    EP_OUT = 0
} EP_DIR;
typedef struct {
    EP_DIR dir;
    DWORD len;
    BYTE *usrBufPtr;
    BOOL stalled;
    BOOL txPending;
} UsbDrvPipe;
typedef struct {
    DWORD haltErrorCount;
    DWORD dataBufferErrorCount;
    DWORD transactionErrorCount;
    DWORD intStatus;
} DriverFlags;
typedef enum {
    DESC_UNAVAILABLE = 2,
    DESC_AVAILABLE = 1,
    DESC_UNKNOWN = 0
} descriptorState;
typedef DWORD UsbBDispDebugEvent;
struct UsbBDispDebugEntryTag {
    UsbBDispDebugEvent bdEvent;
    DWORD tstamp;
};
typedef struct UsbBDispDebugEntryTag UsbBDispDebugEntry;
typedef enum {
    SOFTRECONNECT_STARTED_CABLE_REMOVED = 4,
    SOFTRECONNECT_STARTED = 3,
    SOFTRECONNECT_STOPPED_CABLE_REMOVED = 2,
    SOFTRECONNECT_STOPPED = 1,
    SOFTRECONNECT_INACTIVE = 0
} SoftReconnectState;
typedef DWORD FP_HIDDEN;
typedef enum {
    NUM_IDS = 1,
    NANDFLASH_FP = 0
} RegId;
typedef struct {
    DWORD ReadIndex;
    DWORD WriteIndex;
    DWORD WrappedAround;
    BYTE bBuffer[16384];
} LongPersistenceBuffer;
typedef struct {
    DWORD selector;
    BugdispBufferType whichBuffer;
    DWORD bufferNo;
    DWORD *pWriteIndex;
    DWORD *pSignature;
    BYTE *buffer;
    DWORD size;
    BOOL *pWrapFlag;
    BOOL saved;
} QuincyBufferDescription;
struct BugdispBufferInfo {
    DWORD FileLineLen;
    BufferInfo_t BufferInfo;
};
struct UsbQueueStruct {
    BYTE *ptr;
    WORD length;
    WORD bufferNo;
};
typedef struct UsbQueueStruct UsbQueueStruct;
union UsbCommandBufferUnion {
    DWORD dword[128];
    BYTE byte[512];
};
typedef union UsbCommandBufferUnion UsbCommandBufferUnion;
typedef struct {
    DWORD ReadIndex;
    DWORD WriteIndex;
    BOOL WrappedAround;
    DWORD Signature;
    BYTE bBuffer[16384];
} StagingBuffer;
typedef struct {
    BYTE *pBuffer;
    DWORD headIdx;
    DWORD tailIdx;
    DWORD maxSize;
    DWORD count;
} RingBuffer_t;
typedef enum {
    PERFMON_NUM_STATS = 184,
    PERFMON_ARM9_DDR_LOAD_ACCESS_CYCLES = 183,
    PERFMON_ARM9_DDR_STORES = 182,
    PERFMON_ARM9_DDR_LOAD_LINE_BUFFER_HITS = 181,
    PERFMON_ARM9_DDR_LOADS = 180,
    PERFMON_DDR_DMA_WAIT_CYCLES = 179,
    PERFMON_DDR_STORES = 178,
    PERFMON_DDR_LOAD_CYCLES = 177,
    PERFMON_DDR_LOADS = 176,
    PERFMON_ARM9_GPB_STORES = 175,
    PERFMON_ARM9_GPB_ACCESS_CYCLES = 174,
    PERFMON_ARM9_GPB_LOADS = 173,
    PERFMON_EX_DATA_HAZARD_STALL_CYCLES = 172,
    PERFMON_ARM9_L2_SRAM_CYCLES = 171,
    PERFMON_ARM9_L2_SRAM_LOAD_ARBITRATION_CYCLES = 170,
    PERFMON_ARM9_L2_SRAM_LOAD_DWORD_HITS = 169,
    PERFMON_ARM9_L2_SRAM_STORES = 168,
    PERFMON_ARM9_L2_SRAM_LOADS = 167,
    PERFMON_INSTRUCTION_ARBITRATION_CYCLES = 166,
    PERFMON_L2_ISRAM_DWORD_ACCESSES = 165,
    PERFMON_MMR_ACCESSES = 164,
    PERFMON_MMR_LOAD_STALL_CYCLES = 163,
    PERFMON_MMR_LOAD_REQUESTS = 162,
    PERFMON_DDR_DATA_REQUESTS = 161,
    PERFMON_DDR_DATA_LOAD_STALL_CYCLES = 160,
    PERFMON_DDR_DATA_LOAD_REQUESTS = 159,
    PERFMON_ASPEC_ACCESSES = 158,
    PERFMON_ASPEC_LOAD_STALL_CYCLES = 157,
    PERFMON_ASPEC_LOADS = 156,
    PERFMON_GPB_ACCESSES = 155,
    PERFMON_GPB_LOAD_STALL_CYCLES = 154,
    PERFMON_GPB_LOADS = 153,
    PERFMON_L2_DSRAM_REQUESTS = 152,
    PERFMON_L2_DSRAM_LOAD_STALL_CYCLES = 151,
    PERFMON_L2_DSRAM_LOAD_REQUESTS = 150,
    PERFMON_MSA_GPB_ACCESS_STALL_CYCLES = 149,
    PERFMON_MSA_GPB_ACCESSES = 148,
    PERFMON_DAG1_L1_STORE_CONFLICT_STALL_CYCLES = 147,
    PERFMON_DAG1_CONFLICTS = 146,
    PERFMON_L1_DCACHE_DAG_CONFLICTS = 145,
    PERFMON_L1_DSRAM_DAG_CONFLICTS = 144,
    PERFMON_WRITE_BUFFER_FULL_STALL_CYCLES = 143,
    PERFMON_STORE_BUFFER_FULL_STALL_CYCLES = 142,
    PERFMON_L2_DSRAM_DMA_CONFLICTS = 141,
    PERFMON_L2_DSRAM_DMA_ACCESSES = 140,
    PERFMON_L1_DSRAM_DMA_CONFLICTS = 139,
    PERFMON_L1_DSRAM_DMA_ACCESSES = 138,
    PERFMON_L1_ACCESSES = 137,
    PERFMON_LOAD_L1_HITS = 136,
    PERFMON_STORE_L1_MISS_STALL_CYCLES = 135,
    PERFMON_LOAD_L1_MISS_STALL_CYCLES = 134,
    PERFMON_STORE_L1_MISSES = 133,
    PERFMON_LOAD_L1_MISSES = 132,
    PERFMON_STORE_FILL_BUFFER_STALL_CYCLES = 131,
    PERFMON_STORE_FILL_BUFFER_HITS = 130,
    PERFMON_LOAD_FILL_BUFFER_STALL_CYCLES = 129,
    PERFMON_LOAD_FILL_BUFFER_HITS = 128,
    PERFMON_STORE_DCACHE_HITS = 127,
    PERFMON_LOAD_DCACHE_HITS = 126,
    PERFMON_CACHEABLE_STORES = 125,
    PERFMON_CACHEABLE_LOADS = 124,
    PERFMON_LOAD_HIT_STALL_CYCLES = 123,
    PERFMON_TAKEN_BRANCHES = 122,
    PERFMON_DDR_INSTRUCTION_STALL_CYCLES = 121,
    PERFMON_DDR_INSTRUCTIONS = 120,
    PERFMON_DMA_STALL_CYCLES = 119,
    PERFMON_ICACHE_DMA_ACCESSES = 118,
    PERFMON_CACHEABLE_INSTRUCTIONS = 117,
    PERFMON_SRAM_INSTRUCTIONS = 116,
    PERFMON_IMEM_BUBBLES = 115,
    PERFMON_INSTRUCTIONS_DISPATCHED = 114,
    PERFMON_L2_CLK_CYCLE = 113,
    PERFMON_L2_EMC0_OVERFLOW = 112,
    PERFMON_L2_EMC1_OVERFLOW = 111,
    PERFMON_L2_EMC2_OVERFLOW = 110,
    PERFMON_L2_EMC3_OVERFLOW = 109,
    PERFMON_L2_EMC4_OVERFLOW = 108,
    PERFMON_L2_EMC5_OVERFLOW = 107,
    PERFMON_L2_WRITE_ALLOCATION = 106,
    PERFMON_L2_INSTRUCTION_READ_REQUEST = 105,
    PERFMON_L2_INSTRUCTION_READ_HIT = 104,
    PERFMON_L2_DATA_WRITE_REQUEST_WITH_WRITE_THROUGH = 103,
    PERFMON_L2_DATA_WRITE_REQUEST = 102,
    PERFMON_L2_DATA_WRITE_HIT = 101,
    PERFMON_L2_DATA_READ_REQUEST = 100,
    PERFMON_L2_DATA_READ_HIT = 99,
    PERFMON_L2_CACHE_EVICTION = 98,
    PERFMON_L2_BUFFERED_WRITE_ABORT = 97,
    PERFMON_L2_COUNTER_DISABLE = 96,
    PERFMON_WRITE_BUFFER_DRAIN = 95,
    PERFMON_LOAD_STORE_UNIT_FULL = 94,
    PERFMON_MAIN_TLB_MISS = 93,
    PERFMON_DCACHE_ACCESSES_TOTAL = 92,
    PERFMON_DATA_BUS_TRANS_SELF = 91,
    PERFMON_DATA_BUS_TRANS = 90,
    PERFMON_BUS_CLOCK = 89,
    PERFMON_ADDR_BUS_TRANS_SELF = 88,
    PERFMON_ADDR_BUS_TRANS = 87,
    PERFMON_L2_MISSES = 86,
    PERFMON_L2_ACCESSES = 85,
    PERFMON_COPROC_STALL_CYCLES = 84,
    PERFMON_MULT_STALL_CYCLES = 83,
    PERFMON_MULT_ACTIVE_CYCLES = 82,
    PERFMON_BACKEND_STALL_CYCLES = 81,
    PERFMON_PIPELINE_FLUSH = 80,
    PERFMON_PC_CHANGES_ALL = 79,
    PERFMON_INST_ISSUE_CYCLES = 78,
    PERFMON_DIRECT_BRANCHES = 77,
    PERFMON_DATA_ACCESSES = 76,
    PERFMON_MEM_ACCESS_CYCLES = 75,
    PERFMON_MEM_ACCESSES = 74,
    PERFMON_CHIP_STAT7 = 73,
    PERFMON_CHIP_STAT6 = 72,
    PERFMON_CHIP_STAT5 = 71,
    PERFMON_CHIP_STAT4 = 70,
    PERFMON_CHIP_STAT3 = 69,
    PERFMON_CHIP_STAT2 = 68,
    PERFMON_CHIP_STAT1 = 67,
    PERFMON_CHIP_STAT0 = 66,
    PERFMON_CORE_STALL_CYCLES = 65,
    PERFMON_EX_DATA_HAZARDS_STALLS = 64,
    PERFMON_STORE_TO_LOAD_FORWARDS = 63,
    PERFMON_STORE_BUFFER_CANCEL_STALLS = 62,
    PERFMON_LMU_EXCEPTIONS = 61,
    PERFMON_LMU_STALLS_EX3 = 60,
    PERFMON_LMU_STALLS_EX2 = 59,
    PERFMON_DMA_WRITES = 58,
    PERFMON_DMA_READS = 57,
    PERFMON_SCRATCH_SRAM_HITS = 56,
    PERFMON_DAG_REGISTER_BANK_CONFLICTS = 55,
    PERFMON_CORE_BANK_CONFLICTS = 54,
    PERFMON_WRITE_BUFFER_FULL = 53,
    PERFMON_STORE_BUFFER_FULL = 52,
    PERFMON_DCACHE_MEMORY_MISSES = 51,
    PERFMON_DCACHE_MEMORY_HITS = 50,
    PERFMON_DATABANK_B_STORE_HITS = 49,
    PERFMON_DATABANK_B_LOAD_HITS = 48,
    PERFMON_DATABANK_A_STORE_HITS = 47,
    PERFMON_DATABANK_A_LOAD_HITS = 46,
    PERFMON_STORE_MISSES = 45,
    PERFMON_STORE_HITS = 44,
    PERFMON_LOAD_MISSES = 43,
    PERFMON_LOAD_HITS = 42,
    PERFMON_WRITE_AFTER_WRITE_STALLS = 41,
    PERFMON_READ_AFTER_WRITE_STALLS = 40,
    PERFMON_MISALIGNED_ADDRESS_EXCEPTIONS = 39,
    PERFMON_INTERRUPTS_TAKEN = 38,
    PERFMON_COMMITTED_INSTRUCTIONS = 37,
    PERFMON_CSYNC_SSYNC_INSTRUCTIONS = 36,
    PERFMON_EXCPT_INSTRUCTIONS = 35,
    PERFMON_CSYNC_SSYNC_STALLS = 34,
    PERFMON_NOT_TAKEN_BRANCHES = 33,
    PERFMON_TOTAL_BRANCHES = 32,
    PERFMON_INDIRECT_BRANCHES = 31,
    PERFMON_PC_RELATIVE_BRANCHES = 30,
    PERFMON_LOOP1_BUFFER_INVALIDATES = 29,
    PERFMON_LOOP0_BUFFER_INVALIDATES = 28,
    PERFMON_LOOP1_ITERATIONS = 27,
    PERFMON_LOOP0_ITERATIONS = 26,
    PERFMON_ICACHE_FILL_BUFFER_HITS = 25,
    PERFMON_ICACHE_BANK_CONFLICTS = 24,
    PERFMON_ICACHE_HITS = 23,
    PERFMON_ICACHE_PREFETCH_HITS = 22,
    PERFMON_DCACHE_STALL_CYCLES = 21,
    PERFMON_DCACHE_THRASHES_DUE_TO_SWEEP = 20,
    PERFMON_DCACHE_THRASHES_DUE_TO_MISS = 19,
    PERFMON_DCACHE_PREFETCH_HITS = 18,
    PERFMON_DCACHE_HITS = 17,
    PERFMON_32KHZ_TICKS = 16,
    PERFMON_PC_CHANGES = 15,
    PERFMON_DCACHE_WRITEBACKS = 14,
    PERFMON_DCACHE_MISSES = 13,
    PERFMON_DCACHE_ACCESSES = 12,
    PERFMON_DCACHE_FULL_STALLS = 11,
    PERFMON_DCACHE_FULL_STALL_CYCLES = 10,
    PERFMON_INSTRUCTIONS_EXECUTED = 9,
    PERFMON_MISPREDICTED_BRANCHES = 8,
    PERFMON_BRANCHES = 7,
    PERFMON_DTLB_MISSES = 6,
    PERFMON_ITLB_MISSES = 5,
    PERFMON_DATA_DEPENDENCY_STALL_CYCLES = 4,
    PERFMON_ICACHE_STALL_CYCLES = 3,
    PERFMON_ICACHE_MISSES = 2,
    PERFMON_CLOCK_FREQUENCY = 1,
    PERFMON_CLOCK = 0
} PERFMON_STAT;
typedef enum {
    PERFMON_DYNAMIC = 2,
    PERFMON_STATIC = 1,
    PERFMON_NOT_SUPPORTED = 0
} PERFMON_STAT_TYPE;
typedef struct {
    BYTE channel;
    BYTE qoSInfo;
    WORD length;
} RumpHeader;
typedef struct {
    RumpHeader header;
    BYTE data;
} RumpPacket;
typedef struct {
    BYTE code;
    BYTE channel;
    BYTE origin;
    BYTE id;
} CcpHeader;
typedef struct {
    WORD totalMessageLength;
    WORD currentOffset;
} CcpLargeMessageHeader;
typedef struct {
    WORD totalMessageLength;
    WORD currentOffset;
    BYTE data;
} CcpLargeMessageData;
typedef struct {
    WORD lengthOrOffset;
    WORD infoType;
} CcpInfoHeader;
typedef struct {
    WORD lengthOrOffset;
    WORD infoType;
    BYTE data;
} CcpInfoData;
typedef struct {
    BYTE dataType;
    char name;
} CcpQueryInfoReplyDataData;
typedef struct {
    DWORD encryptionCaps;
} CcpOpenReadyData;
typedef struct {
    char name[16];
} CcpOpenReqData;
typedef struct {
    char name[16];
    BYTE ackData[0];
} CcpOpenAckData;
typedef struct {
    char name[16];
    BYTE packedRejectCode[2];
} CcpOpenNakData;
typedef struct {
    WORD rejectCode;
} CcpTermNakData;
typedef struct {
    BYTE attemptsRem;
    BYTE reserved;
    WORD length;
} CcpAuthenDataHeader;
typedef struct {
    BYTE attemptsRem;
    BYTE reserved;
    WORD length;
    BYTE data[20];
} CcpAuthenData;
typedef struct {
    BYTE attemptsRem;
    BYTE maxAttempts;
    WORD length;
    BYTE blob;
} CcpEncryptionChallenge;
typedef struct {
    WORD length;
    BYTE decryptedBlob;
} CcpEncryptionResponse;
typedef struct {
    CcpHeader header;
    union {
        CcpInfoData info;
        CcpOpenReqData openReq;
        CcpOpenAckData openAck;
        CcpOpenReadyData openReady;
        CcpOpenNakData openNak;
        CcpAuthenData authenData;
        CcpEncryptionChallenge encryptionChallenge;
        CcpEncryptionResponse encryptionResponse;
        CcpTermNakData termNak;
        CcpLargeMessageData largeMsg;
        DWORD dword;
        BYTE generic;
    } data;
} CcpPacket;
enum PmInputRateTag {
    PM_INPUT_UNLIM = 2048,
    PM_INPUT_500mA = 500,
    PM_INPUT_100mA = 100,
    PM_INPUT_OFF = 0,
    PM_INPUT_UNSET = -1
};
typedef enum PmInputRateTag PmInputRate;
typedef SWORD PmChargeRate;
enum PowerModeTage {
    POWER_MODE_AUTO = 2,
    POWER_MODE_PWM = 1,
    POWER_MODE_NONE = 0
};
typedef enum PowerModeTage PowerMode;
typedef int *ScreenInfoFunc;
typedef int *ItemInfoFunc;
typedef int *ItemDataFunc;
typedef int *MenuInfoFunc;
typedef int *KeyPressedFunc;
typedef int *ActionFunc;
typedef struct {
    DWORD numItems;
    DWORD numUserItems;
    DWORD numModes;
    DWORD flags;
    ScreenInfoFunc screenInfoFunc;
    ItemInfoFunc itemInfoFunc;
    ItemDataFunc itemDataFunc;
    MenuInfoFunc menuInfoFunc;
    KeyPressedFunc keyPressedFunc;
    char *title;
} ENG_SCREEN;
typedef enum {
    ESCREEN_NUM_ITEM = 7,
    ESCREEN_POWER_OFF = 6,
    ESCREEN_TOGGLE_RADIO = 5,
    ESCREEN_EVENT_LOG = 4,
    ESCREEN_JVM_CONTENTS = 3,
    ESCREEN_OS_CONTENTS = 2,
    ESCREEN_WAF_CONTENTS = 1,
    ESCREEN_RADIO_CONTENTS = 0
} ESCREEN_MENU_ITEM;
struct UsbDeviceTag {
    BYTE bLength;
    BYTE bDesciptorType;
    WORD bcdUSB;
    BYTE bDeviceClass;
    BYTE bDeviceSubClass;
    BYTE bDeviceProtocol;
    BYTE bMaxPacketSize0;
    WORD idVendor;
    WORD idProduct;
    WORD bcdDevice;
    BYTE iManufacturer;
    BYTE iProduct;
    BYTE iSerialNumber;
    BYTE bNumConfigurations;
};
typedef struct UsbDeviceTag UsbDevice;
struct UsbDevQualTag {
    BYTE bLength;
    BYTE bDescriptorType;
    WORD bcdUSB;
    BYTE bDeviceClass;
    BYTE bDeviceSubClass;
    BYTE bDeviceProtocol;
    BYTE bMaxPacketSize0;
    BYTE bNumConfigurations;
    BYTE bReserved;
};
typedef struct UsbDevQualTag UsbDevQual;
struct UsbConfigurationTag {
    BYTE bLength;
    BYTE bDescriptorType;
    WORD wTotalLength;
    BYTE bNumInterfaces;
    BYTE bConfigurationValue;
    BYTE iConfiguration;
    BYTE bmAttributes;
    BYTE MaxPower;
};
typedef struct UsbConfigurationTag UsbConfiguration;
struct UsbInterfaceTag {
    BYTE bLength;
    BYTE bDescriptorType;
    BYTE bInterfaceNumber;
    BYTE bAlternateSetting;
    BYTE bNumEndpoints;
    BYTE bInterfaceClass;
    BYTE bInterfaceSubClass;
    BYTE bInterfaceProtocol;
    BYTE iInterface;
};
typedef struct UsbInterfaceTag UsbInterface;
struct UsbEndpointTag {
    BYTE bLength;
    BYTE bDescriptorType;
    BYTE bEndpointAddress;
    BYTE bmAttributes;
    WORD wMaxPacketSize;
    BYTE bInterval;
};
typedef struct UsbEndpointTag UsbEndpoint;
struct UsbStringDescTag {
    BYTE bLength;
    BYTE bDescriptorType;
    WORD pString;
};
typedef struct UsbStringDescTag UsbStringDesc;
struct UsbInterfaceAssociationTag {
    BYTE bLength;
    BYTE bDescriptorType;
    BYTE bFirstInterface;
    BYTE bInterfaceCount;
    BYTE bFunctionClass;
    BYTE bFunctionSubClass;
    BYTE bFunctionProtocol;
    BYTE iFunction;
};
typedef struct UsbInterfaceAssociationTag UsbInterfaceAssociation;

